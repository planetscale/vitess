/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"flag"
	"fmt"
	"go/types"
	"log"
	"path"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

const FileHeader = `Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.`

type Sizegen struct {
	DebugTypes bool
	mod        *packages.Module
	sizes      types.Sizes
	codegen    map[string]*File
	known      map[*types.Named]*TypeState
}

type Impl struct {
	name string
	code jen.Code
}

type File struct {
	pkg   string
	impls []Impl
}

type TypeState struct {
	generated bool
	local     bool
	pod       bool
}

func NewSizegen(mod *packages.Module, sizes types.Sizes) *Sizegen {
	return &Sizegen{
		DebugTypes: true,
		mod:        mod,
		sizes:      sizes,
		known:      make(map[*types.Named]*TypeState),
		codegen:    make(map[string]*File),
	}
}

func isPod(tt types.Type) bool {
	switch tt := tt.(type) {
	case *types.Struct:
		for i := 0; i < tt.NumFields(); i++ {
			if !isPod(tt.Field(i).Type()) {
				return false
			}
		}
		return true

	case *types.Basic:
		switch tt.Kind() {
		case types.String, types.UnsafePointer:
			return false
		}
		return true

	default:
		return false
	}
}

func (sizegen *Sizegen) getKnownType(named *types.Named) *TypeState {
	ts := sizegen.known[named]
	if ts == nil {
		local := strings.HasPrefix(named.Obj().Pkg().Path(), sizegen.mod.Path)
		ts = &TypeState{
			local: local,
			pod:   isPod(named.Underlying()),
		}
		sizegen.known[named] = ts
	}
	return ts
}

func (sizegen *Sizegen) generateType(pkg *types.Package, file *File, named *types.Named) {
	ts := sizegen.getKnownType(named)
	if ts.generated {
		return
	}
	ts.generated = true

	switch tt := named.Underlying().(type) {
	case *types.Struct:
		if impl := sizegen.sizeImplForStruct(named.Obj(), tt); impl != nil {
			file.impls = append(file.impls, Impl{
				code: impl,
				name: named.String(),
			})
		}
	case *types.Interface:
		findImplementations(pkg.Scope(), tt, func(tt types.Type) {
			if _, isStruct := tt.Underlying().(*types.Struct); isStruct {
				sizegen.generateType(pkg, file, tt.(*types.Named))
			}
		})
	default:
		// no-op
	}
}

func (sizegen *Sizegen) GenerateKnownType(named *types.Named) {
	pkgInfo := named.Obj().Pkg()
	file := sizegen.codegen[pkgInfo.Path()]
	if file == nil {
		file = &File{pkg: pkgInfo.Name()}
		sizegen.codegen[pkgInfo.Path()] = file
	}

	sizegen.generateType(pkgInfo, file, named)
}

func findImplementations(scope *types.Scope, iff *types.Interface, impl func(types.Type)) {
	for _, name := range scope.Names() {
		obj := scope.Lookup(name)
		baseType := obj.Type()
		if types.Implements(baseType, iff) || types.Implements(types.NewPointer(baseType), iff) {
			impl(baseType)
		}
	}
}

func (sizegen *Sizegen) GenerateForInterface(pkg *types.Package, iff *types.Interface) {
	findImplementations(pkg.Scope(), iff, func(tt types.Type) {
		if named, ok := tt.(*types.Named); ok {
			sizegen.GenerateKnownType(named)
		}
	})
}

func (sizegen *Sizegen) Finalize() {
	var complete bool

	for !complete {
		complete = true
		for tt, ts := range sizegen.known {
			if ts.local && !ts.pod && !ts.generated {
				sizegen.GenerateKnownType(tt)
				complete = false
			}
		}
	}

	for pkg, file := range sizegen.codegen {
		if len(file.impls) == 0 {
			continue
		}
		if !strings.HasPrefix(pkg, sizegen.mod.Path) {
			log.Printf("failed to generate code for foreign package '%s'", pkg)
			log.Printf("DEBUG:\n%#v", file)
			continue
		}

		out := jen.NewFile(file.pkg)
		out.HeaderComment(FileHeader)
		out.HeaderComment("Code generated by Sizegen. DO NOT EDIT.")
		out.Add(jen.Type().Id("cachedObject").InterfaceFunc(func(i *jen.Group) {
			i.Id("CachedSize").Params(jen.Id("alloc").Id("bool")).Int64()
		}))

		sort.Slice(file.impls, func(i, j int) bool {
			return strings.Compare(file.impls[i].name, file.impls[j].name) < 0
		})

		for _, impl := range file.impls {
			out.Add(impl.code)
		}

		fullPath := path.Join(sizegen.mod.Dir, strings.TrimPrefix(pkg, sizegen.mod.Path), "cached_size.go")
		if err := out.Save(fullPath); err != nil {
			log.Printf("failed to save '%s': %v", fullPath, err)
			continue
		}
		log.Printf("saved %s at '%s'", pkg, fullPath)
	}
}

func (sizegen *Sizegen) sizeImplForStruct(name *types.TypeName, st *types.Struct) jen.Code {
	if sizegen.sizes.Sizeof(st) == 0 {
		return nil
	}

	var stmt []jen.Code
	for i := 0; i < st.NumFields(); i++ {
		field := st.Field(i)
		fieldType := field.Type()
		fieldName := jen.Id("cached").Dot(field.Name())
		if s := sizegen.sizeStmtForType(fieldName, fieldType, false); s != nil {
			if sizegen.DebugTypes {
				stmt = append(stmt, jen.Commentf("%s", field.String()))
			}
			stmt = append(stmt, s)
		}
	}

	f := jen.Func()
	f.Params(jen.Id("cached").Op("*").Id(name.Name()))
	f.Id("CachedSize").Params(jen.Id("alloc").Id("bool")).Int64()
	f.BlockFunc(func(b *jen.Group) {
		b.Add(jen.If(jen.Id("cached").Op("==").Nil()).Block(jen.Return(jen.Lit(int64(0)))))
		b.Add(jen.Id("size").Op(":=").Lit(int64(0)))
		b.Add(jen.If(jen.Id("alloc")).Block(
			jen.Id("size").Op("+=").Lit(sizegen.sizes.Sizeof(st)),
		))
		for _, s := range stmt {
			b.Add(s)
		}
		b.Add(jen.Return(jen.Id("size")))
	})
	return f
}

func (sizegen *Sizegen) sizeStmtForMap(fieldName *jen.Statement, m *types.Map) []jen.Code {
	const bucketCnt = 8
	const sizeofHmap = int64(6 * 8)

	/*
		type bmap struct {
			// tophash generally contains the top byte of the hash value
			// for each key in this bucket. If tophash[0] < minTopHash,
			// tophash[0] is a bucket evacuation state instead.
			tophash [bucketCnt]uint8
			// Followed by bucketCnt keys and then bucketCnt elems.
			// NOTE: packing all the keys together and then all the elems together makes the
			// code a bit more complicated than alternating key/elem/key/elem/... but it allows
			// us to eliminate padding which would be needed for, e.g., map[int64]int8.
			// Followed by an overflow pointer.
		}
	*/
	sizeOfBucket := int(
		bucketCnt + // tophash
			bucketCnt*sizegen.sizes.Sizeof(m.Key()) +
			bucketCnt*sizegen.sizes.Sizeof(m.Elem()) +
			8, // overflow pointer
	)

	return []jen.Code{
		jen.Id("size").Op("+=").Lit(sizeofHmap),

		jen.Id("hmap").Op(":=").Qual("reflect", "ValueOf").Call(fieldName),

		jen.Id("numBuckets").Op(":=").Id("int").Call(
			jen.Qual("math", "Pow").Call(jen.Lit(2), jen.Id("float64").Call(
				jen.Parens(jen.Op("*").Parens(jen.Op("*").Id("uint8")).Call(
					jen.Qual("unsafe", "Pointer").Call(jen.Id("hmap").Dot("Pointer").Call().
						Op("+").Id("uintptr").Call(jen.Lit(9)))))))),

		jen.Id("numOldBuckets").Op(":=").Parens(jen.Op("*").Parens(jen.Op("*").Id("uint16")).Call(
			jen.Qual("unsafe", "Pointer").Call(
				jen.Id("hmap").Dot("Pointer").Call().Op("+").Id("uintptr").Call(jen.Lit(10))))),

		jen.Id("size").Op("+=").Id("int64").Call(jen.Id("numOldBuckets").Op("*").Lit(sizeOfBucket)),

		jen.If(jen.Id("len").Call(fieldName).Op(">").Lit(0).Op("||").Id("numBuckets").Op(">").Lit(1)).Block(
			jen.Id("size").Op("+=").Id("int64").Call(
				jen.Id("numBuckets").Op("*").Lit(sizeOfBucket))),
	}
}

func (sizegen *Sizegen) sizeStmtForType(fieldName *jen.Statement, field types.Type, alloc bool) jen.Code {
	if sizegen.sizes.Sizeof(field) == 0 {
		return nil
	}

	switch node := field.(type) {
	case *types.Slice:
		elemT := node.Elem()
		elemSize := sizegen.sizes.Sizeof(elemT)

		switch elemSize {
		case 0:
			return nil

		case 1:
			return jen.Id("size").Op("+=").Int64().Call(jen.Cap(fieldName))

		default:
			return jen.BlockFunc(func(b *jen.Group) {
				b.Add(
					jen.Id("size").
						Op("+=").
						Int64().Call(jen.Cap(fieldName)).
						Op("*").
						Lit(sizegen.sizes.Sizeof(elemT)))

				if stmt := sizegen.sizeStmtForType(jen.Id("elem"), elemT, false); stmt != nil {
					b.Add(jen.For(jen.List(jen.Id("_"), jen.Id("elem")).Op(":=").Range().Add(fieldName))).Block(stmt)
				}
			})
		}

	case *types.Map:
		return jen.If(fieldName.Clone().Op("!=").Nil()).BlockFunc(func(b *jen.Group) {
			for _, stmt := range sizegen.sizeStmtForMap(fieldName, node) {
				b.Add(stmt)
			}

			var forLoopVars []jen.Code
			keySize := sizegen.sizeStmtForType(jen.Id("k"), node.Key(), false)
			valSize := sizegen.sizeStmtForType(jen.Id("v"), node.Elem(), false)

			switch {
			case keySize != nil && valSize != nil:
				forLoopVars = []jen.Code{jen.Id("k"), jen.Id("v")}
			case keySize == nil && valSize != nil:
				forLoopVars = []jen.Code{jen.Id("_"), jen.Id("v")}
			case keySize != nil && valSize == nil:
				forLoopVars = []jen.Code{jen.Id("k")}
			case keySize == nil && valSize == nil:
				return
			}

			b.Add(jen.For(jen.List(forLoopVars...).Op(":=").Range().Add(fieldName))).BlockFunc(func(b *jen.Group) {
				if keySize != nil {
					b.Add(keySize)
				}
				if valSize != nil {
					b.Add(valSize)
				}
			})
		})

	case *types.Pointer:
		return sizegen.sizeStmtForType(fieldName, node.Elem(), true)

	case *types.Named:
		ts := sizegen.getKnownType(node)
		if ts.pod || !ts.local {
			if alloc {
				if !ts.local {
					log.Printf("WARNING: size of external type %s cannot be fully calculated", node)
				}
				return jen.If(fieldName.Clone().Op("!=").Nil()).Block(
					jen.Id("size").Op("+=").Lit(sizegen.sizes.Sizeof(node.Underlying())),
				)
			}
			return nil
		}
		return sizegen.sizeStmtForType(fieldName, node.Underlying(), alloc)

	case *types.Interface:
		if node.Empty() {
			return nil
		}
		return jen.If(
			jen.List(
				jen.Id("cc"), jen.Id("ok")).
				Op(":=").
				Add(fieldName.Clone().Assert(jen.Id("cachedObject"))),
			jen.Id("ok"),
		).Block(
			jen.Id("size").
				Op("+=").
				Id("cc").
				Dot("CachedSize").
				Call(jen.True()),
		)

	case *types.Struct:
		return jen.Id("size").Op("+=").Add(fieldName.Clone().Dot("CachedSize").Call(jen.Lit(alloc)))

	case *types.Basic:
		if !alloc {
			if node.Info()&types.IsString != 0 {
				return jen.Id("size").Op("+=").Int64().Call(jen.Len(fieldName))
			}
			return nil
		}
		return jen.Id("size").Op("+=").Lit(sizegen.sizes.Sizeof(node))
	default:
		log.Printf("unhandled type: %T", node)
	}

	return nil
}

type typePaths []string

func (t *typePaths) String() string {
	return fmt.Sprintf("%v", *t)
}

func (t *typePaths) Set(path string) error {
	*t = append(*t, path)
	return nil
}

func main() {
	var patterns typePaths
	var generate typePaths
	flag.Var(&patterns, "in", "Go packages to load the generator")
	flag.Var(&generate, "gen", "Typename of the Go struct to generate size info for")
	flag.Parse()

	loaded, err := packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedTypesSizes | packages.NeedTypesInfo | packages.NeedDeps | packages.NeedImports | packages.NeedModule,
		Logf: log.Printf,
	}, patterns...)

	if err != nil {
		log.Fatal(err)
	}

	sizegen := NewSizegen(loaded[0].Module, loaded[0].TypesSizes)

	scopes := make(map[string]*types.Scope)
	for _, pkg := range loaded {
		scopes[pkg.PkgPath] = pkg.Types.Scope()
	}

	for _, gen := range generate {
		pos := strings.LastIndexByte(gen, '.')
		if pos < 0 {
			log.Fatalf("unexpected input type: %s", gen)
		}

		pkgname := gen[:pos]
		typename := gen[pos+1:]

		scope := scopes[pkgname]
		if scope == nil {
			log.Fatalf("no scope found for type '%s'", gen)
		}

		tt := scope.Lookup(typename)
		if tt == nil {
			log.Fatalf("no type called '%s' found in '%s'", typename, pkgname)
		}

		sizegen.GenerateKnownType(tt.Type().(*types.Named))
	}

	sizegen.Finalize()
}
