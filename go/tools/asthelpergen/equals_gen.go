package asthelpergen

import (
	"go/types"
	"log"

	"github.com/dave/jennifer/jen"
)

type equalsGen struct {
	todo    []types.Type
	methods []jen.Code
}

var _ generator = (*equalsGen)(nil)

func newEqualsGen() *equalsGen {
	return &equalsGen{}
}

func (e *equalsGen) visitStruct(t types.Type, stroct *types.Struct) error {
	return nil
}

func (e *equalsGen) visitSlice(t types.Type, slice *types.Slice) error {
	return nil
}

func (e *equalsGen) visitInterface(t types.Type, iface *types.Interface) error {
	e.todo = append(e.todo, t)
	return nil
}

func (e *equalsGen) createFile(pkgName string) (string, *jen.File) {
	out := jen.NewFile(pkgName)
	out.HeaderComment(licenseFileHeader)
	out.HeaderComment("Code generated by ASTHelperGen. DO NOT EDIT.")

	alreadyDone := map[string]bool{}
	for len(e.todo) > 0 {
		t := e.todo[0]
		underlying := t.Underlying()
		typeName := printableTypeName(t)
		e.todo = e.todo[1:]

		if alreadyDone[typeName] {
			continue
		}

		if e.tryInterface(underlying, t) {
			alreadyDone[typeName] = true
			continue
		}

		log.Fatalf("don't know how to handle %s %T", typeName, underlying)
	}

	for _, method := range e.methods {
		out.Add(method)
	}

	return "equals.go", out
}

func (e *equalsGen) tryInterface(underlying, t types.Type) bool {
	iface, ok := underlying.(*types.Interface)
	if !ok {
		return false
	}

	err := e.makeInterfaceEqualsMethod(t, iface)
	if err != nil {
		log.Fatalf("%v", err)
	}
	return true
}

const equalsName = "Equals"

func (e *equalsGen) makeInterfaceEqualsMethod(t types.Type, iface *types.Interface) error {

	/*
		func EqualsAST(a, b *AST) bool {
			if a == b {
				return true
			}
			if a == nil || b == nil {
				return false
			}
			return false
		}
	*/
	typeString := types.TypeString(t, noQualifier)
	typeName := printableTypeName(t)

	stmts := []jen.Code{
		jen.If(jen.Id("a == b")).Block(jen.Return(jen.True())),
		jen.If(jen.Id("a == nil").Op("||").Id("b == nil")).Block(jen.Return(jen.False())),
		jen.Return(jen.False()),
	}

	funcName := equalsName + typeName
	funcDecl := jen.Func().Id(funcName).Call(jen.List(jen.Id("a"), jen.Id("b")).Id(typeString)).Bool().Block(stmts...)
	e.addFunc(funcName, funcDecl)

	return nil
}

func (e *equalsGen) addFunc(name string, code jen.Code) {
	e.methods = append(e.methods, jen.Comment(name+" does deep equals."), code)
}
