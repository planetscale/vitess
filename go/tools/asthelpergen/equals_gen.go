package asthelpergen

import (
	"go/types"
	"log"

	"github.com/dave/jennifer/jen"
)

type equalsGen struct {
	todo    []types.Type
	methods []jen.Code
	scope   *types.Scope
}

var _ generator = (*equalsGen)(nil)

func newEqualsGen(scope *types.Scope) *equalsGen {
	return &equalsGen{
		scope: scope,
	}
}

func (e *equalsGen) visitStruct(t types.Type, stroct *types.Struct) error {
	return nil
}

func (e *equalsGen) visitSlice(t types.Type, slice *types.Slice) error {
	return nil
}

func (e *equalsGen) visitInterface(t types.Type, iface *types.Interface) error {
	e.todo = append(e.todo, t)
	return nil
}

func (e *equalsGen) createFile(pkgName string) (string, *jen.File) {
	out := jen.NewFile(pkgName)
	out.HeaderComment(licenseFileHeader)
	out.HeaderComment("Code generated by ASTHelperGen. DO NOT EDIT.")

	alreadyDone := map[string]bool{}
	for len(e.todo) > 0 {
		t := e.todo[0]
		underlying := t.Underlying()
		typeName := printableTypeName(t)
		e.todo = e.todo[1:]

		if alreadyDone[typeName] {
			continue
		}

		if e.tryInterface(underlying, t) {
			alreadyDone[typeName] = true
			continue
		}

		log.Fatalf("don't know how to handle %s %T", typeName, underlying)
	}

	for _, method := range e.methods {
		out.Add(method)
	}

	return "equals.go", out
}

func (e *equalsGen) tryInterface(underlying, t types.Type) bool {
	iface, ok := underlying.(*types.Interface)
	if !ok {
		return false
	}

	err := e.makeInterfaceEqualsMethod(t, iface)
	if err != nil {
		log.Fatalf("%v", err)
	}
	return true
}

const equalsName = "Equals"

func (e *equalsGen) makeInterfaceEqualsMethod(t types.Type, iface *types.Interface) error {

	/*
		func EqualsAST(a, b *AST) bool {
			if a == b {
				return true
			}
			if a == nil || b == nil {
				return false
			}
			switch a := inA.(type) {
			case *SubImpl:
				b, ok := inB.(*SubImpl)
				if !ok {
					return false
				}
				return EqualsSubImpl(a, b)
			}
			return false
		}
	*/
	typeString := types.TypeString(t, noQualifier)
	typeName := printableTypeName(t)

	stmts := []jen.Code{
		jen.If(jen.Id("inA == inB")).Block(jen.Return(jen.True())),
		jen.If(jen.Id("inA == nil").Op("||").Id("inB == nil")).Block(jen.Return(jen.False())),
	}

	var cases []jen.Code
	_ = findImplementations(e.scope, iface, func(t types.Type) error {
		if _, ok := t.Underlying().(*types.Interface); ok {
			return nil
		}
		typeString := types.TypeString(t, noQualifier)
		caseBlock := jen.Case(jen.Id(typeString)).Block(
			jen.Id("b, ok := inB.").Call(jen.Id(typeString)),
			jen.If(jen.Id("!ok")).Block(jen.Return(jen.False())),
			jen.Return(jen.Id(equalsName+printableTypeName(t)).Call(jen.Id("a, b"))),
		)
		cases = append(cases, caseBlock)
		e.todo = append(e.todo, t)
		return nil
	})

	cases = append(cases,
		jen.Default().Block(
			jen.Comment("this should never happen"),
			jen.Return(jen.False()),
		))

	stmts = append(stmts, jen.Switch(jen.Id("a := inA.(type)").Block(
		cases...,
	)))

	stmts = append(stmts, jen.Return(jen.False()))

	funcName := equalsName + typeName
	funcDecl := jen.Func().Id(funcName).Call(jen.List(jen.Id("inA"), jen.Id("inB")).Id(typeString)).Bool().Block(stmts...)
	e.addFunc(funcName, funcDecl)

	return nil
}

func (e *equalsGen) addFunc(name string, code jen.Code) {
	e.methods = append(e.methods, jen.Comment(name+" does deep equals."), code)
}
