// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packet.proto

package packet

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	dataflow "vitess.io/vitess/go/boost/dataflow"
	vitess_io_vitess_go_boost_dataflow "vitess.io/vitess/go/boost/dataflow"
	flownodepb "vitess.io/vitess/go/boost/dataflow/flownode/flownodepb"
	sql "vitess.io/vitess/go/boost/sql"
	vitess_io_vitess_go_boost_sql "vitess.io/vitess/go/boost/sql"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TableOperation_Tag int32

const (
	TableOperation_Insert         TableOperation_Tag = 0
	TableOperation_Delete         TableOperation_Tag = 1
	TableOperation_InsertOrUpdate TableOperation_Tag = 2
	TableOperation_Update         TableOperation_Tag = 3
)

var TableOperation_Tag_name = map[int32]string{
	0: "Insert",
	1: "Delete",
	2: "InsertOrUpdate",
	3: "Update",
}

var TableOperation_Tag_value = map[string]int32{
	"Insert":         0,
	"Delete":         1,
	"InsertOrUpdate": 2,
	"Update":         3,
}

func (x TableOperation_Tag) String() string {
	return proto.EnumName(TableOperation_Tag_name, int32(x))
}

func (TableOperation_Tag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{1, 0}
}

type SourceSelection_Kind int32

const (
	SourceSelection_KEY_SHARD  SourceSelection_Kind = 0
	SourceSelection_SAME_SHARD SourceSelection_Kind = 1
	SourceSelection_ALL_SHARDS SourceSelection_Kind = 2
)

var SourceSelection_Kind_name = map[int32]string{
	0: "KEY_SHARD",
	1: "SAME_SHARD",
	2: "ALL_SHARDS",
}

var SourceSelection_Kind_value = map[string]int32{
	"KEY_SHARD":  0,
	"SAME_SHARD": 1,
	"ALL_SHARDS": 2,
}

func (x SourceSelection_Kind) String() string {
	return proto.EnumName(SourceSelection_Kind_name, int32(x))
}

func (SourceSelection_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6, 0}
}

type TriggerEndpoint_Kind int32

const (
	TriggerEndpoint_NONE     TriggerEndpoint_Kind = 0
	TriggerEndpoint_START    TriggerEndpoint_Kind = 1
	TriggerEndpoint_END      TriggerEndpoint_Kind = 2
	TriggerEndpoint_LOCAL    TriggerEndpoint_Kind = 3
	TriggerEndpoint_EXTERNAL TriggerEndpoint_Kind = 4
)

var TriggerEndpoint_Kind_name = map[int32]string{
	0: "NONE",
	1: "START",
	2: "END",
	3: "LOCAL",
	4: "EXTERNAL",
}

var TriggerEndpoint_Kind_value = map[string]int32{
	"NONE":     0,
	"START":    1,
	"END":      2,
	"LOCAL":    3,
	"EXTERNAL": 4,
}

func (x TriggerEndpoint_Kind) String() string {
	return proto.EnumName(TriggerEndpoint_Kind_name, int32(x))
}

func (TriggerEndpoint_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{7, 0}
}

type SourceChannelIdentifier struct {
	Token uint64                                 `protobuf:"varint,1,opt,name=token,proto3" json:"token,omitempty"`
	Epoch uint64                                 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Tag   vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,3,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
}

func (m *SourceChannelIdentifier) Reset()         { *m = SourceChannelIdentifier{} }
func (m *SourceChannelIdentifier) String() string { return proto.CompactTextString(m) }
func (*SourceChannelIdentifier) ProtoMessage()    {}
func (*SourceChannelIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{0}
}
func (m *SourceChannelIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceChannelIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceChannelIdentifier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceChannelIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceChannelIdentifier.Merge(m, src)
}
func (m *SourceChannelIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *SourceChannelIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceChannelIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_SourceChannelIdentifier proto.InternalMessageInfo

type TableOperation struct {
	Tag TableOperation_Tag                `protobuf:"varint,1,opt,name=tag,proto3,enum=packet.TableOperation_Tag" json:"tag,omitempty"`
	Key vitess_io_vitess_go_boost_sql.Row `protobuf:"bytes,2,opt,name=key,proto3,casttype=vitess.io/vitess/go/boost/sql.Row" json:"key,omitempty"`
}

func (m *TableOperation) Reset()         { *m = TableOperation{} }
func (m *TableOperation) String() string { return proto.CompactTextString(m) }
func (*TableOperation) ProtoMessage()    {}
func (*TableOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{1}
}
func (m *TableOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableOperation.Merge(m, src)
}
func (m *TableOperation) XXX_Size() int {
	return m.Size()
}
func (m *TableOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_TableOperation.DiscardUnknown(m)
}

var xxx_messageInfo_TableOperation proto.InternalMessageInfo

type FlowInput struct {
	Dst  vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=dst,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"dst,omitempty"`
	Data []*TableOperation                               `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *FlowInput) Reset()         { *m = FlowInput{} }
func (m *FlowInput) String() string { return proto.CompactTextString(m) }
func (*FlowInput) ProtoMessage()    {}
func (*FlowInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{2}
}
func (m *FlowInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowInput.Merge(m, src)
}
func (m *FlowInput) XXX_Size() int {
	return m.Size()
}
func (m *FlowInput) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowInput.DiscardUnknown(m)
}

var xxx_messageInfo_FlowInput proto.InternalMessageInfo

type Link struct {
	Src vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=src,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"src,omitempty"`
	Dst vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,2,opt,name=dst,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"dst,omitempty"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{3}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

type ColumnIndex struct {
	Key       []int                                    `protobuf:"varint,1,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	Tags      []vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,2,rep,packed,name=tags,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tags,omitempty"`
	IsPrimary bool                                     `protobuf:"varint,3,opt,name=is_primary,json=isPrimary,proto3" json:"is_primary,omitempty"`
}

func (m *ColumnIndex) Reset()         { *m = ColumnIndex{} }
func (m *ColumnIndex) String() string { return proto.CompactTextString(m) }
func (*ColumnIndex) ProtoMessage()    {}
func (*ColumnIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{4}
}
func (m *ColumnIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ColumnIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ColumnIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ColumnIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ColumnIndex.Merge(m, src)
}
func (m *ColumnIndex) XXX_Size() int {
	return m.Size()
}
func (m *ColumnIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_ColumnIndex.DiscardUnknown(m)
}

var xxx_messageInfo_ColumnIndex proto.InternalMessageInfo

type ReplayPathSegment struct {
	Node       vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	ForceTagTo vitess_io_vitess_go_boost_dataflow.Tag          `protobuf:"varint,2,opt,name=force_tag_to,json=forceTagTo,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"force_tag_to,omitempty"`
	PartialKey []int                                           `protobuf:"varint,3,rep,packed,name=partial_key,json=partialKey,proto3,casttype=int" json:"partial_key,omitempty"`
}

func (m *ReplayPathSegment) Reset()         { *m = ReplayPathSegment{} }
func (m *ReplayPathSegment) String() string { return proto.CompactTextString(m) }
func (*ReplayPathSegment) ProtoMessage()    {}
func (*ReplayPathSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{5}
}
func (m *ReplayPathSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPathSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPathSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPathSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPathSegment.Merge(m, src)
}
func (m *ReplayPathSegment) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPathSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPathSegment.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPathSegment proto.InternalMessageInfo

type SourceSelection struct {
	Kind          SourceSelection_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=packet.SourceSelection_Kind" json:"kind,omitempty"`
	NumShards     uint                 `protobuf:"varint,2,opt,name=num_shards,json=numShards,proto3,casttype=uint" json:"num_shards,omitempty"`
	KeyIdxToShard int                  `protobuf:"varint,3,opt,name=key_idx_to_shard,json=keyIdxToShard,proto3,casttype=int" json:"key_idx_to_shard,omitempty"`
}

func (m *SourceSelection) Reset()         { *m = SourceSelection{} }
func (m *SourceSelection) String() string { return proto.CompactTextString(m) }
func (*SourceSelection) ProtoMessage()    {}
func (*SourceSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6}
}
func (m *SourceSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceSelection.Merge(m, src)
}
func (m *SourceSelection) XXX_Size() int {
	return m.Size()
}
func (m *SourceSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceSelection.DiscardUnknown(m)
}

var xxx_messageInfo_SourceSelection proto.InternalMessageInfo

type TriggerEndpoint struct {
	Kind            TriggerEndpoint_Kind                         `protobuf:"varint,1,opt,name=kind,proto3,enum=packet.TriggerEndpoint_Kind" json:"kind,omitempty"`
	Cols            []int                                        `protobuf:"varint,2,rep,packed,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Domain          vitess_io_vitess_go_boost_dataflow.DomainIdx `protobuf:"varint,3,opt,name=domain,proto3,casttype=vitess.io/vitess/go/boost/dataflow.DomainIdx" json:"domain,omitempty"`
	SourceSelection *SourceSelection                             `protobuf:"bytes,4,opt,name=source_selection,json=sourceSelection,proto3" json:"source_selection,omitempty"`
}

func (m *TriggerEndpoint) Reset()         { *m = TriggerEndpoint{} }
func (m *TriggerEndpoint) String() string { return proto.CompactTextString(m) }
func (*TriggerEndpoint) ProtoMessage()    {}
func (*TriggerEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{7}
}
func (m *TriggerEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEndpoint.Merge(m, src)
}
func (m *TriggerEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEndpoint proto.InternalMessageInfo

type SetupReplayPathRequest struct {
	Tag                   vitess_io_vitess_go_boost_dataflow.Tag          `protobuf:"varint,1,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Source                vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,2,opt,name=source,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"source,omitempty"`
	Path                  []*ReplayPathSegment                            `protobuf:"bytes,3,rep,name=path,proto3" json:"path,omitempty"`
	PartialUnicastSharder vitess_io_vitess_go_boost_dataflow.NodeIdx      `protobuf:"varint,4,opt,name=partial_unicast_sharder,json=partialUnicastSharder,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"partial_unicast_sharder,omitempty"`
	NotifyDone            bool                                            `protobuf:"varint,5,opt,name=notify_done,json=notifyDone,proto3" json:"notify_done,omitempty"`
	Trigger               *TriggerEndpoint                                `protobuf:"bytes,6,opt,name=trigger,proto3" json:"trigger,omitempty"`
	Upquery               string                                          `protobuf:"bytes,7,opt,name=upquery,proto3" json:"upquery,omitempty"`
	LastSegment           bool                                            `protobuf:"varint,8,opt,name=last_segment,json=lastSegment,proto3" json:"last_segment,omitempty"`
}

func (m *SetupReplayPathRequest) Reset()         { *m = SetupReplayPathRequest{} }
func (m *SetupReplayPathRequest) String() string { return proto.CompactTextString(m) }
func (*SetupReplayPathRequest) ProtoMessage()    {}
func (*SetupReplayPathRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8}
}
func (m *SetupReplayPathRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetupReplayPathRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetupReplayPathRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetupReplayPathRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetupReplayPathRequest.Merge(m, src)
}
func (m *SetupReplayPathRequest) XXX_Size() int {
	return m.Size()
}
func (m *SetupReplayPathRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SetupReplayPathRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SetupReplayPathRequest proto.InternalMessageInfo

type ReadyRequest struct {
	Node  vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	Index []*ColumnIndex                                  `protobuf:"bytes,3,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *ReadyRequest) Reset()         { *m = ReadyRequest{} }
func (m *ReadyRequest) String() string { return proto.CompactTextString(m) }
func (*ReadyRequest) ProtoMessage()    {}
func (*ReadyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9}
}
func (m *ReadyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadyRequest.Merge(m, src)
}
func (m *ReadyRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReadyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReadyRequest proto.InternalMessageInfo

type Input struct {
	Inner   *FlowInput                 `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	Src     *SourceChannelIdentifier   `protobuf:"bytes,2,opt,name=src,proto3" json:"src,omitempty"`
	Senders []*SourceChannelIdentifier `protobuf:"bytes,3,rep,name=senders,proto3" json:"senders,omitempty"`
}

func (m *Input) Reset()         { *m = Input{} }
func (m *Input) String() string { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()    {}
func (*Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{10}
}
func (m *Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Input.Merge(m, src)
}
func (m *Input) XXX_Size() int {
	return m.Size()
}
func (m *Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Input proto.InternalMessageInfo

type Message struct {
	Link     *Link          `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Records  []sql.Record   `protobuf:"bytes,2,rep,name=records,proto3" json:"records"`
	SeenTags []Message_Seen `protobuf:"bytes,3,rep,name=seen_tags,json=seenTags,proto3" json:"seen_tags"`
	Gtid     string         `protobuf:"bytes,4,opt,name=gtid,proto3" json:"gtid,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{11}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type Message_Seen struct {
	Offset int32                                  `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Tag    vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,2,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
}

func (m *Message_Seen) Reset()         { *m = Message_Seen{} }
func (m *Message_Seen) String() string { return proto.CompactTextString(m) }
func (*Message_Seen) ProtoMessage()    {}
func (*Message_Seen) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{11, 0}
}
func (m *Message_Seen) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message_Seen) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message_Seen.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message_Seen) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message_Seen.Merge(m, src)
}
func (m *Message_Seen) XXX_Size() int {
	return m.Size()
}
func (m *Message_Seen) XXX_DiscardUnknown() {
	xxx_messageInfo_Message_Seen.DiscardUnknown(m)
}

var xxx_messageInfo_Message_Seen proto.InternalMessageInfo

type ReplayPiece struct {
	Link    *Link                                  `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Tag     vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,2,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Records []sql.Record                           `protobuf:"bytes,3,rep,name=records,proto3" json:"records"`
	// Types that are valid to be assigned to Context:
	//	*ReplayPiece_Partial
	//	*ReplayPiece_Regular
	//	*ReplayPiece_Replace
	Context  isReplayPiece_Context `protobuf_oneof:"context"`
	External *ReplayPiece_External `protobuf:"bytes,8,opt,name=external,proto3" json:"external,omitempty"`
}

func (m *ReplayPiece) Reset()         { *m = ReplayPiece{} }
func (m *ReplayPiece) String() string { return proto.CompactTextString(m) }
func (*ReplayPiece) ProtoMessage()    {}
func (*ReplayPiece) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{12}
}
func (m *ReplayPiece) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPiece) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPiece.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPiece) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPiece.Merge(m, src)
}
func (m *ReplayPiece) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPiece) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPiece.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPiece proto.InternalMessageInfo

type isReplayPiece_Context interface {
	isReplayPiece_Context()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReplayPiece_Partial struct {
	Partial *ReplayPiece_ContextPartial `protobuf:"bytes,4,opt,name=partial,proto3,oneof" json:"partial,omitempty"`
}
type ReplayPiece_Regular struct {
	Regular *ReplayPiece_ContextRegular `protobuf:"bytes,5,opt,name=regular,proto3,oneof" json:"regular,omitempty"`
}
type ReplayPiece_Replace struct {
	Replace *ReplayPiece_ContextReplace `protobuf:"bytes,6,opt,name=replace,proto3,oneof" json:"replace,omitempty"`
}

func (*ReplayPiece_Partial) isReplayPiece_Context() {}
func (*ReplayPiece_Regular) isReplayPiece_Context() {}
func (*ReplayPiece_Replace) isReplayPiece_Context() {}

func (m *ReplayPiece) GetContext() isReplayPiece_Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ReplayPiece) GetPartial() *ReplayPiece_ContextPartial {
	if x, ok := m.GetContext().(*ReplayPiece_Partial); ok {
		return x.Partial
	}
	return nil
}

func (m *ReplayPiece) GetRegular() *ReplayPiece_ContextRegular {
	if x, ok := m.GetContext().(*ReplayPiece_Regular); ok {
		return x.Regular
	}
	return nil
}

func (m *ReplayPiece) GetReplace() *ReplayPiece_ContextReplace {
	if x, ok := m.GetContext().(*ReplayPiece_Replace); ok {
		return x.Replace
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReplayPiece) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReplayPiece_Partial)(nil),
		(*ReplayPiece_Regular)(nil),
		(*ReplayPiece_Replace)(nil),
	}
}

type ReplayPiece_ContextPartial struct {
	ForKeys         map[vitess_io_vitess_go_boost_sql.Row]bool `protobuf:"bytes,1,rep,name=for_keys,json=forKeys,proto3,castkey=vitess.io/vitess/go/boost/sql.Row" json:"for_keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RequestingShard uint                                       `protobuf:"varint,2,opt,name=requesting_shard,json=requestingShard,proto3,casttype=uint" json:"requesting_shard,omitempty"`
	Unishard        bool                                       `protobuf:"varint,3,opt,name=unishard,proto3" json:"unishard,omitempty"`
	Ignore          bool                                       `protobuf:"varint,4,opt,name=ignore,proto3" json:"ignore,omitempty"`
}

func (m *ReplayPiece_ContextPartial) Reset()         { *m = ReplayPiece_ContextPartial{} }
func (m *ReplayPiece_ContextPartial) String() string { return proto.CompactTextString(m) }
func (*ReplayPiece_ContextPartial) ProtoMessage()    {}
func (*ReplayPiece_ContextPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{12, 0}
}
func (m *ReplayPiece_ContextPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPiece_ContextPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPiece_ContextPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPiece_ContextPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPiece_ContextPartial.Merge(m, src)
}
func (m *ReplayPiece_ContextPartial) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPiece_ContextPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPiece_ContextPartial.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPiece_ContextPartial proto.InternalMessageInfo

type ReplayPiece_ContextRegular struct {
	Last bool `protobuf:"varint,1,opt,name=last,proto3" json:"last,omitempty"`
}

func (m *ReplayPiece_ContextRegular) Reset()         { *m = ReplayPiece_ContextRegular{} }
func (m *ReplayPiece_ContextRegular) String() string { return proto.CompactTextString(m) }
func (*ReplayPiece_ContextRegular) ProtoMessage()    {}
func (*ReplayPiece_ContextRegular) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{12, 1}
}
func (m *ReplayPiece_ContextRegular) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPiece_ContextRegular) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPiece_ContextRegular.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPiece_ContextRegular) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPiece_ContextRegular.Merge(m, src)
}
func (m *ReplayPiece_ContextRegular) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPiece_ContextRegular) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPiece_ContextRegular.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPiece_ContextRegular proto.InternalMessageInfo

type ReplayPiece_ContextReplace struct {
	OriginalLink *Link `protobuf:"bytes,1,opt,name=original_link,json=originalLink,proto3" json:"original_link,omitempty"`
}

func (m *ReplayPiece_ContextReplace) Reset()         { *m = ReplayPiece_ContextReplace{} }
func (m *ReplayPiece_ContextReplace) String() string { return proto.CompactTextString(m) }
func (*ReplayPiece_ContextReplace) ProtoMessage()    {}
func (*ReplayPiece_ContextReplace) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{12, 2}
}
func (m *ReplayPiece_ContextReplace) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPiece_ContextReplace) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPiece_ContextReplace.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPiece_ContextReplace) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPiece_ContextReplace.Merge(m, src)
}
func (m *ReplayPiece_ContextReplace) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPiece_ContextReplace) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPiece_ContextReplace.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPiece_ContextReplace proto.InternalMessageInfo

type ReplayPiece_External struct {
	Gtid         string `protobuf:"bytes,1,opt,name=gtid,proto3" json:"gtid,omitempty"`
	Slot         uint32 `protobuf:"varint,2,opt,name=slot,proto3" json:"slot,omitempty"`
	Intermediate bool   `protobuf:"varint,3,opt,name=intermediate,proto3" json:"intermediate,omitempty"`
	Failed       bool   `protobuf:"varint,4,opt,name=failed,proto3" json:"failed,omitempty"`
}

func (m *ReplayPiece_External) Reset()         { *m = ReplayPiece_External{} }
func (m *ReplayPiece_External) String() string { return proto.CompactTextString(m) }
func (*ReplayPiece_External) ProtoMessage()    {}
func (*ReplayPiece_External) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{12, 3}
}
func (m *ReplayPiece_External) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPiece_External) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPiece_External.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPiece_External) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPiece_External.Merge(m, src)
}
func (m *ReplayPiece_External) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPiece_External) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPiece_External.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPiece_External proto.InternalMessageInfo

type EvictRequest struct {
	Node     vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	NumBytes int64                                           `protobuf:"varint,2,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *EvictRequest) Reset()         { *m = EvictRequest{} }
func (m *EvictRequest) String() string { return proto.CompactTextString(m) }
func (*EvictRequest) ProtoMessage()    {}
func (*EvictRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{13}
}
func (m *EvictRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvictRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvictRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvictRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvictRequest.Merge(m, src)
}
func (m *EvictRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvictRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvictRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvictRequest proto.InternalMessageInfo

type EvictKeysRequest struct {
	Link *Link                                  `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Tag  vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,2,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Keys []vitess_io_vitess_go_boost_sql.Row    `protobuf:"bytes,3,rep,name=keys,proto3,casttype=vitess.io/vitess/go/boost/sql.Row" json:"keys,omitempty"`
}

func (m *EvictKeysRequest) Reset()         { *m = EvictKeysRequest{} }
func (m *EvictKeysRequest) String() string { return proto.CompactTextString(m) }
func (*EvictKeysRequest) ProtoMessage()    {}
func (*EvictKeysRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{14}
}
func (m *EvictKeysRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EvictKeysRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EvictKeysRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EvictKeysRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EvictKeysRequest.Merge(m, src)
}
func (m *EvictKeysRequest) XXX_Size() int {
	return m.Size()
}
func (m *EvictKeysRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EvictKeysRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EvictKeysRequest proto.InternalMessageInfo

type FinishReplayRequest struct {
	Tag        vitess_io_vitess_go_boost_dataflow.Tag          `protobuf:"varint,1,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Node       vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,2,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	Gtid       string                                          `protobuf:"bytes,3,opt,name=gtid,proto3" json:"gtid,omitempty"`
	NotifyDone bool                                            `protobuf:"varint,4,opt,name=notify_done,json=notifyDone,proto3" json:"notify_done,omitempty"`
}

func (m *FinishReplayRequest) Reset()         { *m = FinishReplayRequest{} }
func (m *FinishReplayRequest) String() string { return proto.CompactTextString(m) }
func (*FinishReplayRequest) ProtoMessage()    {}
func (*FinishReplayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{15}
}
func (m *FinishReplayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishReplayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishReplayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishReplayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishReplayRequest.Merge(m, src)
}
func (m *FinishReplayRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishReplayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishReplayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishReplayRequest proto.InternalMessageInfo

type AddNodeRequest struct {
	Node    *flownodepb.Node                                  `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	Parents []vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,2,rep,packed,name=parents,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"parents,omitempty"`
}

func (m *AddNodeRequest) Reset()         { *m = AddNodeRequest{} }
func (m *AddNodeRequest) String() string { return proto.CompactTextString(m) }
func (*AddNodeRequest) ProtoMessage()    {}
func (*AddNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{16}
}
func (m *AddNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddNodeRequest.Merge(m, src)
}
func (m *AddNodeRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddNodeRequest proto.InternalMessageInfo

type RemoveNodesRequest struct {
	Nodes []vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,rep,packed,name=nodes,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"nodes,omitempty"`
}

func (m *RemoveNodesRequest) Reset()         { *m = RemoveNodesRequest{} }
func (m *RemoveNodesRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveNodesRequest) ProtoMessage()    {}
func (*RemoveNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{17}
}
func (m *RemoveNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveNodesRequest.Merge(m, src)
}
func (m *RemoveNodesRequest) XXX_Size() int {
	return m.Size()
}
func (m *RemoveNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveNodesRequest proto.InternalMessageInfo

type UpdateEgressRequest struct {
	Node   vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	NewTx  *UpdateEgressRequest_Tx                         `protobuf:"bytes,2,opt,name=new_tx,json=newTx,proto3" json:"new_tx,omitempty"`
	NewTag *UpdateEgressRequest_Tag                        `protobuf:"bytes,3,opt,name=new_tag,json=newTag,proto3" json:"new_tag,omitempty"`
}

func (m *UpdateEgressRequest) Reset()         { *m = UpdateEgressRequest{} }
func (m *UpdateEgressRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateEgressRequest) ProtoMessage()    {}
func (*UpdateEgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{18}
}
func (m *UpdateEgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEgressRequest.Merge(m, src)
}
func (m *UpdateEgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEgressRequest proto.InternalMessageInfo

type UpdateEgressRequest_Tx struct {
	Node   uint32               `protobuf:"varint,1,opt,name=node,proto3" json:"node,omitempty"`
	Local  uint32               `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
	Domain *dataflow.DomainAddr `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *UpdateEgressRequest_Tx) Reset()         { *m = UpdateEgressRequest_Tx{} }
func (m *UpdateEgressRequest_Tx) String() string { return proto.CompactTextString(m) }
func (*UpdateEgressRequest_Tx) ProtoMessage()    {}
func (*UpdateEgressRequest_Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{18, 0}
}
func (m *UpdateEgressRequest_Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEgressRequest_Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEgressRequest_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEgressRequest_Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEgressRequest_Tx.Merge(m, src)
}
func (m *UpdateEgressRequest_Tx) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEgressRequest_Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEgressRequest_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEgressRequest_Tx proto.InternalMessageInfo

type UpdateEgressRequest_Tag struct {
	Tag  vitess_io_vitess_go_boost_dataflow.Tag     `protobuf:"varint,1,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Node vitess_io_vitess_go_boost_dataflow.NodeIdx `protobuf:"varint,2,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"node,omitempty"`
}

func (m *UpdateEgressRequest_Tag) Reset()         { *m = UpdateEgressRequest_Tag{} }
func (m *UpdateEgressRequest_Tag) String() string { return proto.CompactTextString(m) }
func (*UpdateEgressRequest_Tag) ProtoMessage()    {}
func (*UpdateEgressRequest_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{18, 1}
}
func (m *UpdateEgressRequest_Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateEgressRequest_Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateEgressRequest_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateEgressRequest_Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateEgressRequest_Tag.Merge(m, src)
}
func (m *UpdateEgressRequest_Tag) XXX_Size() int {
	return m.Size()
}
func (m *UpdateEgressRequest_Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateEgressRequest_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateEgressRequest_Tag proto.InternalMessageInfo

type UpdateSharderRequest struct {
	Node   vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	NewTxs []*UpdateSharderRequest_Tx                      `protobuf:"bytes,2,rep,name=new_txs,json=newTxs,proto3" json:"new_txs,omitempty"`
}

func (m *UpdateSharderRequest) Reset()         { *m = UpdateSharderRequest{} }
func (m *UpdateSharderRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateSharderRequest) ProtoMessage()    {}
func (*UpdateSharderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{19}
}
func (m *UpdateSharderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSharderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSharderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSharderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSharderRequest.Merge(m, src)
}
func (m *UpdateSharderRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSharderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSharderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSharderRequest proto.InternalMessageInfo

type UpdateSharderRequest_Tx struct {
	Local  vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=local,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"local,omitempty"`
	Domain *dataflow.DomainAddr                            `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *UpdateSharderRequest_Tx) Reset()         { *m = UpdateSharderRequest_Tx{} }
func (m *UpdateSharderRequest_Tx) String() string { return proto.CompactTextString(m) }
func (*UpdateSharderRequest_Tx) ProtoMessage()    {}
func (*UpdateSharderRequest_Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{19, 0}
}
func (m *UpdateSharderRequest_Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateSharderRequest_Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateSharderRequest_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateSharderRequest_Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateSharderRequest_Tx.Merge(m, src)
}
func (m *UpdateSharderRequest_Tx) XXX_Size() int {
	return m.Size()
}
func (m *UpdateSharderRequest_Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateSharderRequest_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateSharderRequest_Tx proto.InternalMessageInfo

type PrepareStateRequest struct {
	Node vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	// Types that are valid to be assigned to State:
	//	*PrepareStateRequest_PartialLocal_
	//	*PrepareStateRequest_IndexedLocal_
	//	*PrepareStateRequest_PartialGlobal_
	//	*PrepareStateRequest_Global_
	State isPrepareStateRequest_State `protobuf_oneof:"state"`
}

func (m *PrepareStateRequest) Reset()         { *m = PrepareStateRequest{} }
func (m *PrepareStateRequest) String() string { return proto.CompactTextString(m) }
func (*PrepareStateRequest) ProtoMessage()    {}
func (*PrepareStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20}
}
func (m *PrepareStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest.Merge(m, src)
}
func (m *PrepareStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest proto.InternalMessageInfo

type isPrepareStateRequest_State interface {
	isPrepareStateRequest_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type PrepareStateRequest_PartialLocal_ struct {
	PartialLocal *PrepareStateRequest_PartialLocal `protobuf:"bytes,2,opt,name=partial_local,json=partialLocal,proto3,oneof" json:"partial_local,omitempty"`
}
type PrepareStateRequest_IndexedLocal_ struct {
	IndexedLocal *PrepareStateRequest_IndexedLocal `protobuf:"bytes,3,opt,name=indexed_local,json=indexedLocal,proto3,oneof" json:"indexed_local,omitempty"`
}
type PrepareStateRequest_PartialGlobal_ struct {
	PartialGlobal *PrepareStateRequest_PartialGlobal `protobuf:"bytes,4,opt,name=partial_global,json=partialGlobal,proto3,oneof" json:"partial_global,omitempty"`
}
type PrepareStateRequest_Global_ struct {
	Global *PrepareStateRequest_Global `protobuf:"bytes,5,opt,name=global,proto3,oneof" json:"global,omitempty"`
}

func (*PrepareStateRequest_PartialLocal_) isPrepareStateRequest_State()  {}
func (*PrepareStateRequest_IndexedLocal_) isPrepareStateRequest_State()  {}
func (*PrepareStateRequest_PartialGlobal_) isPrepareStateRequest_State() {}
func (*PrepareStateRequest_Global_) isPrepareStateRequest_State()        {}

func (m *PrepareStateRequest) GetState() isPrepareStateRequest_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *PrepareStateRequest) GetPartialLocal() *PrepareStateRequest_PartialLocal {
	if x, ok := m.GetState().(*PrepareStateRequest_PartialLocal_); ok {
		return x.PartialLocal
	}
	return nil
}

func (m *PrepareStateRequest) GetIndexedLocal() *PrepareStateRequest_IndexedLocal {
	if x, ok := m.GetState().(*PrepareStateRequest_IndexedLocal_); ok {
		return x.IndexedLocal
	}
	return nil
}

func (m *PrepareStateRequest) GetPartialGlobal() *PrepareStateRequest_PartialGlobal {
	if x, ok := m.GetState().(*PrepareStateRequest_PartialGlobal_); ok {
		return x.PartialGlobal
	}
	return nil
}

func (m *PrepareStateRequest) GetGlobal() *PrepareStateRequest_Global {
	if x, ok := m.GetState().(*PrepareStateRequest_Global_); ok {
		return x.Global
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PrepareStateRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PrepareStateRequest_PartialLocal_)(nil),
		(*PrepareStateRequest_IndexedLocal_)(nil),
		(*PrepareStateRequest_PartialGlobal_)(nil),
		(*PrepareStateRequest_Global_)(nil),
	}
}

type PrepareStateRequest_PartialLocal struct {
	Index []*ColumnIndex `protobuf:"bytes,1,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *PrepareStateRequest_PartialLocal) Reset()         { *m = PrepareStateRequest_PartialLocal{} }
func (m *PrepareStateRequest_PartialLocal) String() string { return proto.CompactTextString(m) }
func (*PrepareStateRequest_PartialLocal) ProtoMessage()    {}
func (*PrepareStateRequest_PartialLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20, 0}
}
func (m *PrepareStateRequest_PartialLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest_PartialLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest_PartialLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest_PartialLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest_PartialLocal.Merge(m, src)
}
func (m *PrepareStateRequest_PartialLocal) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest_PartialLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest_PartialLocal.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest_PartialLocal proto.InternalMessageInfo

type PrepareStateRequest_IndexedLocal struct {
	Index []*ColumnIndex `protobuf:"bytes,1,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *PrepareStateRequest_IndexedLocal) Reset()         { *m = PrepareStateRequest_IndexedLocal{} }
func (m *PrepareStateRequest_IndexedLocal) String() string { return proto.CompactTextString(m) }
func (*PrepareStateRequest_IndexedLocal) ProtoMessage()    {}
func (*PrepareStateRequest_IndexedLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20, 1}
}
func (m *PrepareStateRequest_IndexedLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest_IndexedLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest_IndexedLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest_IndexedLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest_IndexedLocal.Merge(m, src)
}
func (m *PrepareStateRequest_IndexedLocal) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest_IndexedLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest_IndexedLocal.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest_IndexedLocal proto.InternalMessageInfo

type PrepareStateRequest_PartialGlobal struct {
	Gid           vitess_io_vitess_go_boost_dataflow.NodeIdx       `protobuf:"varint,1,opt,name=gid,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"gid,omitempty"`
	Cols          int                                              `protobuf:"varint,2,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Key           []int                                            `protobuf:"varint,3,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	TriggerDomain *PrepareStateRequest_PartialGlobal_TriggerDomain `protobuf:"bytes,4,opt,name=trigger_domain,json=triggerDomain,proto3" json:"trigger_domain,omitempty"`
}

func (m *PrepareStateRequest_PartialGlobal) Reset()         { *m = PrepareStateRequest_PartialGlobal{} }
func (m *PrepareStateRequest_PartialGlobal) String() string { return proto.CompactTextString(m) }
func (*PrepareStateRequest_PartialGlobal) ProtoMessage()    {}
func (*PrepareStateRequest_PartialGlobal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20, 2}
}
func (m *PrepareStateRequest_PartialGlobal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest_PartialGlobal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest_PartialGlobal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest_PartialGlobal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest_PartialGlobal.Merge(m, src)
}
func (m *PrepareStateRequest_PartialGlobal) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest_PartialGlobal) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest_PartialGlobal.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest_PartialGlobal proto.InternalMessageInfo

type PrepareStateRequest_PartialGlobal_TriggerDomain struct {
	Domain vitess_io_vitess_go_boost_dataflow.DomainIdx `protobuf:"varint,1,opt,name=domain,proto3,casttype=vitess.io/vitess/go/boost/dataflow.DomainIdx" json:"domain,omitempty"`
	Shards uint                                         `protobuf:"varint,2,opt,name=shards,proto3,casttype=uint" json:"shards,omitempty"`
}

func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) Reset() {
	*m = PrepareStateRequest_PartialGlobal_TriggerDomain{}
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) String() string {
	return proto.CompactTextString(m)
}
func (*PrepareStateRequest_PartialGlobal_TriggerDomain) ProtoMessage() {}
func (*PrepareStateRequest_PartialGlobal_TriggerDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20, 2, 0}
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest_PartialGlobal_TriggerDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest_PartialGlobal_TriggerDomain.Merge(m, src)
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest_PartialGlobal_TriggerDomain.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest_PartialGlobal_TriggerDomain proto.InternalMessageInfo

type PrepareStateRequest_Global struct {
	Gid  vitess_io_vitess_go_boost_dataflow.NodeIdx `protobuf:"varint,1,opt,name=gid,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"gid,omitempty"`
	Cols int                                        `protobuf:"varint,2,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Key  []int                                      `protobuf:"varint,3,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
}

func (m *PrepareStateRequest_Global) Reset()         { *m = PrepareStateRequest_Global{} }
func (m *PrepareStateRequest_Global) String() string { return proto.CompactTextString(m) }
func (*PrepareStateRequest_Global) ProtoMessage()    {}
func (*PrepareStateRequest_Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{20, 3}
}
func (m *PrepareStateRequest_Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrepareStateRequest_Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrepareStateRequest_Global.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrepareStateRequest_Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrepareStateRequest_Global.Merge(m, src)
}
func (m *PrepareStateRequest_Global) XXX_Size() int {
	return m.Size()
}
func (m *PrepareStateRequest_Global) XXX_DiscardUnknown() {
	xxx_messageInfo_PrepareStateRequest_Global.DiscardUnknown(m)
}

var xxx_messageInfo_PrepareStateRequest_Global proto.InternalMessageInfo

type PartialReplayRequest struct {
	Tag             vitess_io_vitess_go_boost_dataflow.Tag `protobuf:"varint,1,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	Keys            []vitess_io_vitess_go_boost_sql.Row    `protobuf:"bytes,2,rep,name=keys,proto3,casttype=vitess.io/vitess/go/boost/sql.Row" json:"keys,omitempty"`
	Unishard        bool                                   `protobuf:"varint,3,opt,name=unishard,proto3" json:"unishard,omitempty"`
	RequestingShard uint                                   `protobuf:"varint,4,opt,name=requesting_shard,json=requestingShard,proto3,casttype=uint" json:"requesting_shard,omitempty"`
}

func (m *PartialReplayRequest) Reset()         { *m = PartialReplayRequest{} }
func (m *PartialReplayRequest) String() string { return proto.CompactTextString(m) }
func (*PartialReplayRequest) ProtoMessage()    {}
func (*PartialReplayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{21}
}
func (m *PartialReplayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PartialReplayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PartialReplayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PartialReplayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PartialReplayRequest.Merge(m, src)
}
func (m *PartialReplayRequest) XXX_Size() int {
	return m.Size()
}
func (m *PartialReplayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PartialReplayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PartialReplayRequest proto.InternalMessageInfo

type ReaderReplayRequest struct {
	Node vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,1,opt,name=node,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"node,omitempty"`
	Cols []int                                           `protobuf:"varint,2,rep,packed,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Keys []vitess_io_vitess_go_boost_sql.Row             `protobuf:"bytes,3,rep,name=keys,proto3,casttype=vitess.io/vitess/go/boost/sql.Row" json:"keys,omitempty"`
}

func (m *ReaderReplayRequest) Reset()         { *m = ReaderReplayRequest{} }
func (m *ReaderReplayRequest) String() string { return proto.CompactTextString(m) }
func (*ReaderReplayRequest) ProtoMessage()    {}
func (*ReaderReplayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{22}
}
func (m *ReaderReplayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReaderReplayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReaderReplayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReaderReplayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReaderReplayRequest.Merge(m, src)
}
func (m *ReaderReplayRequest) XXX_Size() int {
	return m.Size()
}
func (m *ReaderReplayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ReaderReplayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ReaderReplayRequest proto.InternalMessageInfo

type StartReplayRequest struct {
	Tag  vitess_io_vitess_go_boost_dataflow.Tag          `protobuf:"varint,1,opt,name=tag,proto3,casttype=vitess.io/vitess/go/boost/dataflow.Tag" json:"tag,omitempty"`
	From vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,2,opt,name=from,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"from,omitempty"`
}

func (m *StartReplayRequest) Reset()         { *m = StartReplayRequest{} }
func (m *StartReplayRequest) String() string { return proto.CompactTextString(m) }
func (*StartReplayRequest) ProtoMessage()    {}
func (*StartReplayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{23}
}
func (m *StartReplayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartReplayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartReplayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartReplayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartReplayRequest.Merge(m, src)
}
func (m *StartReplayRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartReplayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartReplayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartReplayRequest proto.InternalMessageInfo

type WaitForReplayRequest struct {
}

func (m *WaitForReplayRequest) Reset()         { *m = WaitForReplayRequest{} }
func (m *WaitForReplayRequest) String() string { return proto.CompactTextString(m) }
func (*WaitForReplayRequest) ProtoMessage()    {}
func (*WaitForReplayRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{24}
}
func (m *WaitForReplayRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WaitForReplayRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WaitForReplayRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WaitForReplayRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WaitForReplayRequest.Merge(m, src)
}
func (m *WaitForReplayRequest) XXX_Size() int {
	return m.Size()
}
func (m *WaitForReplayRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WaitForReplayRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WaitForReplayRequest proto.InternalMessageInfo

type Sync struct {
}

func (m *Sync) Reset()         { *m = Sync{} }
func (m *Sync) String() string { return proto.CompactTextString(m) }
func (*Sync) ProtoMessage()    {}
func (*Sync) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{25}
}
func (m *Sync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sync.Merge(m, src)
}
func (m *Sync) XXX_Size() int {
	return m.Size()
}
func (m *Sync) XXX_DiscardUnknown() {
	xxx_messageInfo_Sync.DiscardUnknown(m)
}

var xxx_messageInfo_Sync proto.InternalMessageInfo

type Async struct {
}

func (m *Async) Reset()         { *m = Async{} }
func (m *Async) String() string { return proto.CompactTextString(m) }
func (*Async) ProtoMessage()    {}
func (*Async) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{26}
}
func (m *Async) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Async) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Async.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Async) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Async.Merge(m, src)
}
func (m *Async) XXX_Size() int {
	return m.Size()
}
func (m *Async) XXX_DiscardUnknown() {
	xxx_messageInfo_Async.DiscardUnknown(m)
}

var xxx_messageInfo_Async proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("packet.TableOperation_Tag", TableOperation_Tag_name, TableOperation_Tag_value)
	proto.RegisterEnum("packet.SourceSelection_Kind", SourceSelection_Kind_name, SourceSelection_Kind_value)
	proto.RegisterEnum("packet.TriggerEndpoint_Kind", TriggerEndpoint_Kind_name, TriggerEndpoint_Kind_value)
	proto.RegisterType((*SourceChannelIdentifier)(nil), "packet.SourceChannelIdentifier")
	proto.RegisterType((*TableOperation)(nil), "packet.TableOperation")
	proto.RegisterType((*FlowInput)(nil), "packet.FlowInput")
	proto.RegisterType((*Link)(nil), "packet.Link")
	proto.RegisterType((*ColumnIndex)(nil), "packet.ColumnIndex")
	proto.RegisterType((*ReplayPathSegment)(nil), "packet.ReplayPathSegment")
	proto.RegisterType((*SourceSelection)(nil), "packet.SourceSelection")
	proto.RegisterType((*TriggerEndpoint)(nil), "packet.TriggerEndpoint")
	proto.RegisterType((*SetupReplayPathRequest)(nil), "packet.SetupReplayPathRequest")
	proto.RegisterType((*ReadyRequest)(nil), "packet.ReadyRequest")
	proto.RegisterType((*Input)(nil), "packet.Input")
	proto.RegisterType((*Message)(nil), "packet.Message")
	proto.RegisterType((*Message_Seen)(nil), "packet.Message.Seen")
	proto.RegisterType((*ReplayPiece)(nil), "packet.ReplayPiece")
	proto.RegisterType((*ReplayPiece_ContextPartial)(nil), "packet.ReplayPiece.ContextPartial")
	proto.RegisterMapType((map[vitess_io_vitess_go_boost_sql.Row]bool)(nil), "packet.ReplayPiece.ContextPartial.ForKeysEntry")
	proto.RegisterType((*ReplayPiece_ContextRegular)(nil), "packet.ReplayPiece.ContextRegular")
	proto.RegisterType((*ReplayPiece_ContextReplace)(nil), "packet.ReplayPiece.ContextReplace")
	proto.RegisterType((*ReplayPiece_External)(nil), "packet.ReplayPiece.External")
	proto.RegisterType((*EvictRequest)(nil), "packet.EvictRequest")
	proto.RegisterType((*EvictKeysRequest)(nil), "packet.EvictKeysRequest")
	proto.RegisterType((*FinishReplayRequest)(nil), "packet.FinishReplayRequest")
	proto.RegisterType((*AddNodeRequest)(nil), "packet.AddNodeRequest")
	proto.RegisterType((*RemoveNodesRequest)(nil), "packet.RemoveNodesRequest")
	proto.RegisterType((*UpdateEgressRequest)(nil), "packet.UpdateEgressRequest")
	proto.RegisterType((*UpdateEgressRequest_Tx)(nil), "packet.UpdateEgressRequest.Tx")
	proto.RegisterType((*UpdateEgressRequest_Tag)(nil), "packet.UpdateEgressRequest.Tag")
	proto.RegisterType((*UpdateSharderRequest)(nil), "packet.UpdateSharderRequest")
	proto.RegisterType((*UpdateSharderRequest_Tx)(nil), "packet.UpdateSharderRequest.Tx")
	proto.RegisterType((*PrepareStateRequest)(nil), "packet.PrepareStateRequest")
	proto.RegisterType((*PrepareStateRequest_PartialLocal)(nil), "packet.PrepareStateRequest.PartialLocal")
	proto.RegisterType((*PrepareStateRequest_IndexedLocal)(nil), "packet.PrepareStateRequest.IndexedLocal")
	proto.RegisterType((*PrepareStateRequest_PartialGlobal)(nil), "packet.PrepareStateRequest.PartialGlobal")
	proto.RegisterType((*PrepareStateRequest_PartialGlobal_TriggerDomain)(nil), "packet.PrepareStateRequest.PartialGlobal.TriggerDomain")
	proto.RegisterType((*PrepareStateRequest_Global)(nil), "packet.PrepareStateRequest.Global")
	proto.RegisterType((*PartialReplayRequest)(nil), "packet.PartialReplayRequest")
	proto.RegisterType((*ReaderReplayRequest)(nil), "packet.ReaderReplayRequest")
	proto.RegisterType((*StartReplayRequest)(nil), "packet.StartReplayRequest")
	proto.RegisterType((*WaitForReplayRequest)(nil), "packet.WaitForReplayRequest")
	proto.RegisterType((*Sync)(nil), "packet.Sync")
	proto.RegisterType((*Async)(nil), "packet.Async")
}

func init() { proto.RegisterFile("packet.proto", fileDescriptor_e9ef1a6541f9f9e7) }

var fileDescriptor_e9ef1a6541f9f9e7 = []byte{
	// 2323 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcb, 0x6f, 0x1b, 0xc7,
	0x19, 0xe7, 0x72, 0x97, 0xaf, 0x8f, 0x0f, 0xd1, 0x23, 0xd5, 0x66, 0xe8, 0x56, 0x52, 0x16, 0x4d,
	0x23, 0x3b, 0x0e, 0x65, 0xcb, 0x35, 0x6c, 0xa7, 0x4e, 0x5a, 0xd1, 0xa6, 0x2d, 0xc1, 0xf2, 0x03,
	0x4b, 0x06, 0x7d, 0x20, 0x28, 0xb1, 0xe6, 0x0e, 0xd7, 0x0b, 0xad, 0x66, 0xe9, 0xdd, 0xa1, 0x45,
	0xa2, 0x68, 0x0f, 0xce, 0x21, 0xd7, 0x1e, 0x7a, 0x28, 0x50, 0xa0, 0xb7, 0x02, 0xbd, 0xe4, 0x9a,
	0xfe, 0x03, 0x3d, 0x18, 0xe8, 0x25, 0x05, 0x5a, 0xa0, 0x27, 0x35, 0xb5, 0x81, 0xfe, 0x11, 0xba,
	0xb4, 0x98, 0xc7, 0x92, 0xcb, 0x15, 0x65, 0x49, 0xa6, 0x8a, 0x5e, 0x88, 0x99, 0xd9, 0xef, 0x35,
	0xdf, 0x63, 0xe6, 0xf7, 0x0d, 0xa1, 0xd0, 0x33, 0x3b, 0xdb, 0x98, 0xd6, 0x7a, 0xbe, 0x47, 0x3d,
	0x94, 0x16, 0xb3, 0x6a, 0xc9, 0x32, 0xa9, 0xd9, 0x75, 0xbd, 0x5d, 0xb1, 0x5e, 0x2d, 0xb1, 0x31,
	0xf1, 0x2c, 0x2c, 0xe7, 0xb9, 0xe0, 0x99, 0x2b, 0x87, 0x0b, 0xb6, 0x67, 0x7b, 0x7c, 0xb8, 0xca,
	0x46, 0x62, 0x55, 0xff, 0x5c, 0x81, 0x73, 0x4d, 0xaf, 0xef, 0x77, 0xf0, 0xed, 0xa7, 0x26, 0x21,
	0xd8, 0xdd, 0xb4, 0x30, 0xa1, 0x4e, 0xd7, 0xc1, 0x3e, 0x5a, 0x80, 0x14, 0xf5, 0xb6, 0x31, 0xa9,
	0x28, 0xcb, 0xca, 0x8a, 0x66, 0x88, 0x09, 0x5b, 0xc5, 0x3d, 0xaf, 0xf3, 0xb4, 0x92, 0x14, 0xab,
	0x7c, 0x82, 0x6e, 0x81, 0x4a, 0x4d, 0xbb, 0xa2, 0x2e, 0x2b, 0x2b, 0xc5, 0xfa, 0xc5, 0xfd, 0xbd,
	0xa5, 0xef, 0x3d, 0x77, 0x28, 0x0e, 0x82, 0x9a, 0xe3, 0xad, 0x8a, 0xd1, 0xaa, 0xed, 0xad, 0x3e,
	0xf1, 0xbc, 0x80, 0xae, 0x8e, 0x6c, 0x6e, 0x99, 0xb6, 0xc1, 0xd8, 0xf4, 0xaf, 0x14, 0x28, 0xb5,
	0xcc, 0x27, 0x2e, 0x7e, 0xd4, 0xc3, 0xbe, 0x49, 0x1d, 0x8f, 0xa0, 0x4b, 0x42, 0x20, 0x53, 0x5d,
	0x5a, 0xab, 0xd6, 0xe4, 0xee, 0x27, 0x89, 0x46, 0x02, 0xd0, 0x75, 0x50, 0xb7, 0xf1, 0x90, 0x9b,
	0x94, 0xab, 0xbf, 0xb7, 0xbf, 0xb7, 0xf4, 0xee, 0xe1, 0xea, 0x99, 0x4b, 0x0c, 0x6f, 0xd7, 0x60,
	0x1c, 0xfa, 0xc7, 0xa0, 0xb6, 0x4c, 0x1b, 0x01, 0xa4, 0x37, 0x49, 0x80, 0x7d, 0x5a, 0x4e, 0xb0,
	0xf1, 0x1d, 0xec, 0x62, 0x8a, 0xcb, 0x0a, 0x42, 0x50, 0x12, 0xeb, 0x8f, 0xfc, 0x4f, 0x7b, 0x96,
	0x49, 0x71, 0x39, 0xc9, 0xbe, 0xcb, 0xb1, 0xaa, 0xff, 0x0a, 0x72, 0x77, 0x5d, 0x6f, 0x77, 0x93,
	0xf4, 0xfa, 0x14, 0x35, 0x40, 0xb5, 0x02, 0xca, 0x4d, 0x2e, 0xd6, 0xaf, 0xee, 0xef, 0x2d, 0xad,
	0x1e, 0xc3, 0x07, 0x5b, 0x5e, 0xc7, 0x74, 0x1f, 0x7a, 0x16, 0xde, 0xb4, 0x06, 0x06, 0xe3, 0x47,
	0x17, 0x41, 0x63, 0x5f, 0x2b, 0xc9, 0x65, 0x75, 0x25, 0xbf, 0x76, 0x76, 0xfa, 0xd6, 0x0d, 0x4e,
	0xa3, 0xff, 0x46, 0x01, 0x6d, 0xcb, 0x21, 0xdb, 0x4c, 0x77, 0xe0, 0x77, 0x66, 0xd2, 0x1d, 0xf8,
	0x9d, 0x70, 0x0b, 0xc9, 0xd9, 0xb6, 0xa0, 0x7f, 0xa1, 0x40, 0xfe, 0xb6, 0xe7, 0xf6, 0x77, 0xc8,
	0x26, 0xb1, 0xf0, 0x00, 0xbd, 0x23, 0xc2, 0xa3, 0x2c, 0xab, 0x2b, 0x6a, 0x3d, 0xb3, 0xbf, 0xb7,
	0xa4, 0x3a, 0x84, 0xf2, 0x00, 0xa0, 0x4f, 0x40, 0xa3, 0xa6, 0x1d, 0xf0, 0xdd, 0x9e, 0x2c, 0x73,
	0x38, 0x1f, 0xfa, 0x0e, 0x80, 0x13, 0xb4, 0x7b, 0xbe, 0xb3, 0x63, 0xfa, 0x43, 0x9e, 0x7f, 0x59,
	0x23, 0xe7, 0x04, 0x8f, 0xc5, 0x82, 0xfe, 0x37, 0x05, 0xce, 0x18, 0xb8, 0xe7, 0x9a, 0xc3, 0xc7,
	0x26, 0x7d, 0xda, 0xc4, 0xf6, 0x0e, 0x26, 0x14, 0xdd, 0x03, 0x8d, 0x15, 0xc9, 0x2c, 0xee, 0xe2,
	0x02, 0xd0, 0x16, 0x14, 0xba, 0x9e, 0xdf, 0xc1, 0x6d, 0x6a, 0xda, 0x6d, 0xea, 0x49, 0xc7, 0x9d,
	0x64, 0x17, 0xc0, 0xf9, 0x5b, 0xa6, 0xdd, 0xf2, 0xd0, 0x0a, 0xe4, 0x7b, 0xa6, 0x4f, 0x1d, 0xd3,
	0x6d, 0x33, 0x77, 0xa9, 0x93, 0xee, 0x02, 0xf9, 0xed, 0x3e, 0x1e, 0xea, 0x7f, 0x57, 0x60, 0x4e,
	0x94, 0x6d, 0x13, 0xbb, 0xb8, 0xc3, 0x2b, 0xe6, 0x32, 0x68, 0xdb, 0x0e, 0xb1, 0x64, 0xc9, 0x7c,
	0x3b, 0xcc, 0x9b, 0x18, 0x59, 0xed, 0xbe, 0x43, 0x2c, 0x83, 0x53, 0xa2, 0xf7, 0x01, 0x48, 0x7f,
	0xa7, 0x1d, 0x3c, 0x35, 0x7d, 0x2b, 0x10, 0xf5, 0x5c, 0xcf, 0xee, 0xef, 0x2d, 0x69, 0x7d, 0xa6,
	0x2f, 0x47, 0xfa, 0x3b, 0x4d, 0xfe, 0x09, 0x5d, 0x86, 0xf2, 0x36, 0x1e, 0xb6, 0x1d, 0x6b, 0xd0,
	0xa6, 0x9e, 0xa0, 0xe7, 0xae, 0x8e, 0x58, 0x57, 0xdc, 0xc6, 0xc3, 0x4d, 0x6b, 0xd0, 0xf2, 0x38,
	0x8b, 0x7e, 0x0d, 0x34, 0xa6, 0x08, 0x15, 0x21, 0x77, 0xbf, 0xf1, 0xd3, 0x76, 0x73, 0x63, 0xdd,
	0xb8, 0x53, 0x4e, 0xa0, 0x12, 0x40, 0x73, 0xfd, 0x41, 0x43, 0xce, 0x15, 0x36, 0x5f, 0xdf, 0xda,
	0x12, 0xd3, 0x66, 0x39, 0xa9, 0x7f, 0x99, 0x84, 0xb9, 0x96, 0xef, 0xd8, 0x36, 0xf6, 0x1b, 0xc4,
	0xea, 0x79, 0x0e, 0xa1, 0x87, 0xed, 0x2b, 0x46, 0x16, 0xdd, 0xd7, 0x79, 0xd0, 0x3a, 0x9e, 0x2b,
	0x72, 0x2a, 0x62, 0x22, 0x5f, 0x44, 0x1b, 0x90, 0xb6, 0xbc, 0x1d, 0xd3, 0x21, 0x7c, 0x07, 0x5a,
	0xfd, 0xf2, 0xfe, 0xde, 0xd2, 0xa5, 0x63, 0x04, 0xeb, 0x0e, 0x67, 0x62, 0xa1, 0x97, 0xfc, 0xa8,
	0x0e, 0xe5, 0x80, 0x3b, 0xb7, 0x1d, 0x84, 0xde, 0xad, 0x68, 0xcb, 0xca, 0x4a, 0x7e, 0xed, 0xdc,
	0x21, 0xce, 0x37, 0xe6, 0x82, 0xc9, 0x05, 0xfd, 0x63, 0xe9, 0xa7, 0x2c, 0x68, 0x0f, 0x1f, 0x3d,
	0x6c, 0x94, 0x13, 0x28, 0x07, 0xa9, 0x66, 0x6b, 0xdd, 0x68, 0x95, 0x15, 0x94, 0x01, 0xb5, 0xf1,
	0xf0, 0x4e, 0x39, 0xc9, 0xd6, 0xb6, 0x1e, 0xdd, 0x5e, 0xdf, 0x2a, 0xab, 0xa8, 0x00, 0xd9, 0xc6,
	0x4f, 0x5a, 0x0d, 0xe3, 0xe1, 0xfa, 0x56, 0x59, 0xd3, 0xff, 0xa2, 0xc2, 0xd9, 0x26, 0xa6, 0xfd,
	0xde, 0x38, 0xc7, 0x0d, 0xfc, 0xac, 0x8f, 0x03, 0x1a, 0x9e, 0xc8, 0xca, 0x5b, 0x9d, 0xc8, 0xe8,
	0x3e, 0xa4, 0x85, 0xa9, 0xb3, 0x9c, 0x05, 0x52, 0x04, 0xfa, 0x10, 0xb4, 0x9e, 0x49, 0x9f, 0xf2,
	0x84, 0xce, 0xaf, 0xbd, 0x13, 0x3a, 0xe7, 0x40, 0x5d, 0x1a, 0x9c, 0x0c, 0x75, 0xe1, 0x5c, 0x58,
	0x06, 0x7d, 0xe2, 0x74, 0xcc, 0x80, 0x8a, 0x94, 0xc3, 0x3e, 0x77, 0x6f, 0xb1, 0x5e, 0xdb, 0xdf,
	0x5b, 0xba, 0x78, 0x0c, 0x63, 0x42, 0x3b, 0xbe, 0x25, 0xc5, 0x7d, 0x2a, 0xa4, 0x35, 0x85, 0x30,
	0xb4, 0x04, 0x79, 0xe2, 0x51, 0xa7, 0x3b, 0x6c, 0x5b, 0x1e, 0xc1, 0x95, 0x14, 0x3f, 0x3b, 0x40,
	0x2c, 0xdd, 0xf1, 0x08, 0x46, 0x57, 0x20, 0x43, 0x45, 0x96, 0x55, 0xd2, 0x93, 0x71, 0x8d, 0x25,
	0x9f, 0x11, 0xd2, 0xa1, 0x0a, 0x64, 0xfa, 0xbd, 0x67, 0x7d, 0xec, 0x0f, 0x2b, 0x19, 0x76, 0x19,
	0x19, 0xe1, 0x14, 0xbd, 0x0b, 0x05, 0x97, 0x6f, 0x45, 0xec, 0xb5, 0x92, 0xe5, 0xea, 0xf2, 0x6c,
	0x4d, 0x6e, 0x5f, 0x7f, 0xa1, 0x40, 0xc1, 0xc0, 0xa6, 0x35, 0x0c, 0x63, 0x78, 0x6a, 0xe7, 0xd4,
	0x05, 0x48, 0x39, 0xec, 0x24, 0x96, 0x21, 0x98, 0x0f, 0xf7, 0x11, 0x39, 0xa4, 0x0d, 0x41, 0xa1,
	0xff, 0x5e, 0x81, 0x94, 0xb8, 0xcf, 0xde, 0x67, 0x4c, 0x04, 0xfb, 0x5c, 0x7d, 0x7e, 0xed, 0x4c,
	0xc8, 0x34, 0xba, 0xf1, 0x0c, 0xf1, 0x1d, 0x5d, 0x11, 0x97, 0x4f, 0x92, 0x93, 0x2d, 0x4d, 0xe6,
	0xfe, 0x01, 0x58, 0x21, 0x2e, 0x9a, 0x9b, 0x90, 0x09, 0x30, 0xb1, 0xb0, 0x1f, 0x48, 0x93, 0x8e,
	0x64, 0x0b, 0xe9, 0xf5, 0xcf, 0x93, 0x90, 0x79, 0x80, 0x83, 0xc0, 0xb4, 0x31, 0x5a, 0x06, 0xcd,
	0x75, 0xc8, 0xb6, 0xb4, 0xb0, 0x10, 0xca, 0x60, 0x57, 0xa2, 0xc1, 0xbf, 0xa0, 0x0f, 0x20, 0xe3,
	0xe3, 0x8e, 0x27, 0x0e, 0x38, 0xa6, 0x28, 0x5f, 0xe3, 0x00, 0x80, 0xaf, 0xd5, 0xb5, 0x97, 0x7b,
	0x4b, 0x09, 0x23, 0xa4, 0x40, 0xd7, 0x21, 0x17, 0x60, 0x4c, 0xda, 0xfc, 0x46, 0x12, 0x76, 0x2d,
	0x84, 0x32, 0xa5, 0xca, 0x5a, 0x13, 0x63, 0x22, 0xf9, 0xb2, 0x8c, 0xb8, 0xc5, 0x6e, 0x21, 0x04,
	0x9a, 0x4d, 0x1d, 0x8b, 0xe7, 0x67, 0xce, 0xe0, 0xe3, 0xea, 0x67, 0xa0, 0x31, 0x5a, 0x74, 0x16,
	0xd2, 0x5e, 0xb7, 0x1b, 0x60, 0x81, 0x0c, 0x52, 0x86, 0x9c, 0x85, 0x05, 0x9a, 0x7c, 0x3b, 0xc8,
	0xf4, 0x87, 0x0c, 0xe4, 0x65, 0x01, 0x39, 0xb8, 0x73, 0x1c, 0x4f, 0xcc, 0xa4, 0x2f, 0xea, 0x47,
	0xf5, 0x48, 0x3f, 0x7e, 0x02, 0x19, 0x59, 0x72, 0xf2, 0x40, 0xd4, 0x63, 0x35, 0xcf, 0x4c, 0xae,
	0xdd, 0xf6, 0x08, 0xc5, 0x03, 0xfa, 0x58, 0x50, 0x6e, 0x24, 0x8c, 0x90, 0x89, 0xf1, 0xfb, 0xd8,
	0xee, 0xbb, 0xa6, 0xcf, 0xab, 0xf2, 0xcd, 0xfc, 0x86, 0xa0, 0xdc, 0xe0, 0xfa, 0xf9, 0x50, 0xf0,
	0xf7, 0x5c, 0xb3, 0x83, 0x65, 0xe1, 0xbe, 0x99, 0x9f, 0x53, 0x0a, 0x7e, 0x3e, 0x44, 0x37, 0x20,
	0x8b, 0x07, 0x14, 0xfb, 0xc4, 0x74, 0x79, 0x9d, 0xe6, 0xc7, 0xd7, 0x4e, 0x54, 0x40, 0x43, 0xd2,
	0x18, 0x23, 0xea, 0xea, 0x1f, 0x93, 0x50, 0x9a, 0xdc, 0x17, 0x7a, 0x06, 0xd9, 0xae, 0xe7, 0xb3,
	0x1b, 0x3d, 0xe0, 0x08, 0x28, 0xbf, 0xb6, 0x7a, 0xb4, 0x37, 0x6a, 0x77, 0x3d, 0xff, 0x3e, 0x1e,
	0x06, 0x0d, 0x42, 0xfd, 0x61, 0xfd, 0xbd, 0x17, 0xff, 0x3c, 0x0e, 0xa2, 0xcd, 0x74, 0x05, 0x13,
	0xba, 0x0a, 0x65, 0x5f, 0x1c, 0x21, 0x0e, 0xb1, 0xe5, 0x7d, 0x1d, 0xbf, 0xde, 0xe7, 0xc6, 0x14,
	0xfc, 0x40, 0x44, 0x55, 0xc8, 0xf6, 0x89, 0x33, 0xbe, 0xdc, 0xb3, 0xc6, 0x68, 0xce, 0x72, 0xd8,
	0xb1, 0x89, 0xe7, 0x63, 0x1e, 0xcf, 0xac, 0x21, 0x67, 0xd5, 0x8f, 0xa0, 0x10, 0x35, 0x14, 0x95,
	0x43, 0xa0, 0xc7, 0xca, 0x80, 0xe3, 0xbb, 0x05, 0x48, 0x3d, 0x37, 0xdd, 0xbe, 0xb8, 0x47, 0xb2,
	0x86, 0x98, 0x7c, 0x94, 0xbc, 0xa1, 0x54, 0xbf, 0x3b, 0xf2, 0x94, 0x8c, 0x20, 0xab, 0x22, 0x76,
	0x1c, 0x72, 0xf6, 0xac, 0xc1, 0xc7, 0xd5, 0xdb, 0x11, 0x2a, 0x11, 0x9c, 0x2b, 0x50, 0xf4, 0x7c,
	0xc7, 0x76, 0x88, 0xe9, 0xb6, 0x0f, 0x4d, 0xf9, 0x42, 0x48, 0xc2, 0x66, 0x55, 0x02, 0xd9, 0x30,
	0x56, 0xa3, 0x52, 0x55, 0xc6, 0xa5, 0xca, 0xd6, 0x02, 0xd7, 0x93, 0xb8, 0xd7, 0xe0, 0x63, 0xa4,
	0x43, 0xc1, 0x21, 0x14, 0xfb, 0x3b, 0xd8, 0x72, 0x4c, 0x8a, 0xa5, 0x4b, 0x26, 0xd6, 0x98, 0x5b,
	0xba, 0xa6, 0xe3, 0x62, 0x2b, 0x74, 0x8b, 0x98, 0xd5, 0x73, 0x90, 0xe9, 0x08, 0xa3, 0x75, 0x0a,
	0x85, 0xc6, 0x73, 0xa7, 0x43, 0x4f, 0xfd, 0x48, 0x3f, 0x0f, 0x0c, 0xa0, 0xb5, 0x9f, 0x0c, 0x29,
	0x16, 0xd8, 0x4d, 0x35, 0xb2, 0xa4, 0xbf, 0x53, 0x67, 0x73, 0xfd, 0x4b, 0x05, 0xca, 0x5c, 0x2d,
	0x0b, 0x4d, 0xa8, 0xfa, 0x7f, 0x7d, 0x44, 0xdc, 0x04, 0x8d, 0x27, 0x39, 0x3b, 0x1f, 0x8e, 0xdd,
	0x85, 0x71, 0x16, 0xfd, 0xaf, 0x0a, 0xcc, 0xdf, 0x75, 0x58, 0xb6, 0x89, 0x92, 0x38, 0x1d, 0x10,
	0x13, 0xfa, 0x3a, 0x39, 0xab, 0xaf, 0xc3, 0x9c, 0x51, 0x23, 0x39, 0x13, 0x43, 0x0f, 0x5a, 0x1c,
	0x3d, 0xb0, 0xd6, 0xba, 0xb4, 0x6e, 0x59, 0x4c, 0x52, 0xb8, 0x1d, 0x3d, 0x12, 0xfc, 0xfc, 0x5a,
	0xa9, 0x36, 0xea, 0xd6, 0x39, 0x91, 0xd0, 0xf5, 0x80, 0x9f, 0x9d, 0x98, 0xd0, 0xb0, 0x27, 0x7a,
	0x2b, 0xbb, 0x43, 0x19, 0x7a, 0x1b, 0x90, 0x81, 0x77, 0xbc, 0xe7, 0x98, 0x7d, 0x19, 0xa5, 0xc2,
	0x26, 0xa4, 0x98, 0x32, 0x71, 0x20, 0xbd, 0xa5, 0x0a, 0x21, 0x41, 0xff, 0x93, 0x0a, 0xf3, 0xa2,
	0x1f, 0x6e, 0xd8, 0x3e, 0x0e, 0x82, 0x53, 0x4f, 0xf4, 0x6b, 0x90, 0x26, 0x78, 0xb7, 0x4d, 0x07,
	0x12, 0x60, 0x2c, 0x86, 0x89, 0x3b, 0x45, 0x6b, 0xad, 0xc5, 0xec, 0xc2, 0xbb, 0xad, 0x01, 0xba,
	0x01, 0x19, 0xce, 0x26, 0x5f, 0x25, 0x22, 0x08, 0x63, 0x2a, 0x9f, 0x69, 0x1b, 0x4c, 0x4d, 0xcb,
	0xb4, 0xab, 0x9f, 0x41, 0xb2, 0x35, 0x60, 0x31, 0x1f, 0xdb, 0x2f, 0x4d, 0x59, 0x80, 0x94, 0xcb,
	0x0c, 0x94, 0x07, 0x85, 0x98, 0xa0, 0x4b, 0x13, 0x1d, 0x05, 0x83, 0x0c, 0xb1, 0xa6, 0x61, 0xdd,
	0xb2, 0xfc, 0xb0, 0x6b, 0xa8, 0x7e, 0xa1, 0x88, 0x27, 0x87, 0xd9, 0x52, 0xbb, 0x3e, 0x91, 0xda,
	0x27, 0x05, 0xc4, 0x9c, 0x57, 0xff, 0x6d, 0x12, 0x16, 0x84, 0x2f, 0x24, 0x22, 0x3e, 0xf5, 0xd0,
	0x85, 0x31, 0x18, 0x84, 0xe0, 0x2b, 0x16, 0x83, 0x49, 0xbd, 0x2c, 0x78, 0x3c, 0x06, 0x83, 0xa0,
	0xfa, 0x4b, 0x1e, 0x83, 0xcd, 0xd0, 0xdf, 0x33, 0x58, 0x72, 0x20, 0x48, 0xc9, 0xa3, 0x83, 0xa4,
	0xff, 0x27, 0x03, 0xf3, 0x8f, 0x7d, 0xcc, 0x8a, 0xa8, 0x49, 0x4d, 0x8a, 0x4f, 0xdd, 0x33, 0x8f,
	0xa0, 0x18, 0xf6, 0x38, 0xe3, 0x8c, 0xca, 0xaf, 0xad, 0x84, 0xfe, 0x99, 0xa2, 0xbc, 0x26, 0xa1,
	0x01, 0x97, 0xb6, 0x91, 0x30, 0x0a, 0xbd, 0xc8, 0x9c, 0x09, 0xe4, 0xf8, 0x1d, 0x5b, 0x52, 0xa0,
	0x7a, 0xb4, 0xc0, 0x4d, 0xc1, 0x30, 0x12, 0xe8, 0x44, 0xe6, 0xc8, 0x80, 0x52, 0x68, 0xa1, 0xed,
	0x7a, 0x4f, 0x46, 0x50, 0xee, 0xc2, 0x31, 0x4c, 0xbc, 0xc7, 0x19, 0x36, 0x12, 0x46, 0xb8, 0x49,
	0xb1, 0x80, 0x6e, 0x41, 0x5a, 0xca, 0x8a, 0xc1, 0xba, 0x69, 0xb2, 0x46, 0x42, 0x24, 0x4f, 0xf5,
	0x26, 0x14, 0xa2, 0x2e, 0x18, 0x37, 0x35, 0xca, 0x51, 0x4d, 0x0d, 0x63, 0x8d, 0x6e, 0xf6, 0x24,
	0xac, 0xff, 0x4e, 0x42, 0x71, 0x62, 0x5b, 0xe8, 0x47, 0xa0, 0xda, 0x12, 0x40, 0x9c, 0xbc, 0xf4,
	0x18, 0x6b, 0xe4, 0x81, 0x42, 0x59, 0x49, 0xc5, 0x1f, 0x28, 0xe4, 0x63, 0x99, 0x3a, 0xe5, 0xb1,
	0xec, 0xe7, 0x50, 0x92, 0x8d, 0x66, 0x5b, 0x26, 0xb3, 0x88, 0xc9, 0xf5, 0x63, 0xc7, 0x24, 0xec,
	0x5c, 0x45, 0xce, 0x1b, 0x45, 0x1a, 0x9d, 0x56, 0x7f, 0x01, 0xc5, 0x89, 0xef, 0x91, 0xc7, 0x12,
	0x65, 0xc6, 0xc7, 0x92, 0x65, 0x48, 0x1f, 0xf2, 0xce, 0x24, 0xd7, 0xab, 0x2f, 0x14, 0x48, 0xff,
	0xbf, 0x3d, 0x5c, 0xcf, 0x40, 0x2a, 0x60, 0xce, 0xd3, 0xbf, 0x51, 0x60, 0x41, 0x7a, 0xee, 0x34,
	0x21, 0x49, 0x88, 0x91, 0x92, 0x27, 0xc6, 0x48, 0x6f, 0xc4, 0xe7, 0xd3, 0x00, 0xbf, 0x76, 0x04,
	0xe0, 0xd7, 0xbf, 0x52, 0x60, 0xde, 0xc0, 0x26, 0x3f, 0x80, 0xa3, 0x3b, 0x3c, 0x45, 0x88, 0xfa,
	0x86, 0x77, 0xb8, 0x19, 0xd0, 0xe2, 0xef, 0x14, 0x40, 0x4d, 0x6a, 0xfa, 0xf4, 0x94, 0xc1, 0x62,
	0xd7, 0xf7, 0x76, 0x66, 0x02, 0x8b, 0x4c, 0x80, 0x7e, 0x16, 0x16, 0x7e, 0x6c, 0x3a, 0xf4, 0xae,
	0x37, 0xe9, 0x56, 0x3d, 0x0d, 0x5a, 0x73, 0x48, 0x3a, 0x7a, 0x06, 0x52, 0xeb, 0xc1, 0x90, 0x74,
	0xd6, 0xfe, 0x9c, 0x81, 0xb4, 0xac, 0xb3, 0x0b, 0x90, 0x6b, 0x62, 0x62, 0x89, 0x77, 0x97, 0x62,
	0x58, 0xcd, 0x7c, 0x5a, 0x1d, 0x4d, 0x39, 0x17, 0xfa, 0x10, 0xf2, 0x8c, 0x34, 0x7c, 0x01, 0x99,
	0x8b, 0xbd, 0x4f, 0xc4, 0xc9, 0xaf, 0xc1, 0x1c, 0x23, 0x8f, 0x3e, 0x15, 0xcc, 0x4f, 0x69, 0x3f,
	0xe3, 0x6c, 0x97, 0x20, 0xc5, 0xfb, 0x07, 0x34, 0x7a, 0xff, 0x88, 0x76, 0x31, 0x71, 0xea, 0xef,
	0x43, 0x6e, 0xd4, 0x6d, 0xa0, 0xca, 0x04, 0x47, 0xa4, 0x01, 0x89, 0x73, 0xad, 0xcb, 0x28, 0x4e,
	0x94, 0x19, 0x1a, 0x75, 0xda, 0xd3, 0xaa, 0x2f, 0x2e, 0xe2, 0x87, 0x70, 0x46, 0x26, 0xc2, 0x38,
	0x8d, 0xd1, 0xf9, 0xf1, 0xfe, 0x0e, 0x24, 0x77, 0x5c, 0xc0, 0x0d, 0xc8, 0x47, 0x32, 0x09, 0x8d,
	0xfe, 0x68, 0x3a, 0x98, 0x5e, 0x71, 0x4e, 0xd6, 0xfa, 0x46, 0x3a, 0x96, 0xb1, 0xd6, 0x29, 0x7d,
	0x4c, 0x9c, 0xf7, 0x32, 0x64, 0x64, 0x67, 0x80, 0x46, 0xff, 0xef, 0x4c, 0xb6, 0x0a, 0x53, 0xec,
	0x8c, 0xc0, 0xf8, 0xb1, 0x9d, 0x07, 0xb1, 0xfd, 0x14, 0x3b, 0xa3, 0x80, 0x77, 0x6c, 0xe7, 0x14,
	0x18, 0x1c, 0xe7, 0xbd, 0x05, 0xc5, 0x09, 0xa0, 0x36, 0x0e, 0xce, 0x34, 0xfc, 0x36, 0x45, 0x73,
	0xf4, 0x3e, 0x1a, 0x6b, 0x9e, 0x72, 0x4b, 0x1d, 0x0c, 0xec, 0x5c, 0xec, 0x5d, 0x1b, 0x8d, 0x70,
	0xff, 0xf4, 0x07, 0xef, 0xea, 0xa8, 0xa1, 0x65, 0x55, 0x86, 0x3e, 0x80, 0x14, 0x7f, 0x4a, 0x1d,
	0x27, 0x70, 0xf4, 0x65, 0x35, 0x46, 0xfc, 0x03, 0x28, 0x4e, 0x94, 0xec, 0x78, 0x9f, 0xd3, 0x2a,
	0x79, 0x92, 0xb9, 0x7e, 0xef, 0xe5, 0xbf, 0x16, 0x13, 0x2f, 0x5f, 0x2d, 0x2a, 0x5f, 0xbf, 0x5a,
	0x54, 0xbe, 0x79, 0xb5, 0xa8, 0xfc, 0xfa, 0xf5, 0x62, 0xe2, 0xeb, 0xd7, 0x8b, 0x89, 0x7f, 0xbc,
	0x5e, 0x4c, 0xfc, 0xec, 0xc2, 0xe1, 0x87, 0x08, 0xff, 0xf5, 0x7b, 0x9d, 0x55, 0x21, 0xed, 0x49,
	0x9a, 0xff, 0x25, 0x7b, 0xf5, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xcd, 0x69, 0x9f, 0xc2, 0xeb,
	0x1d, 0x00, 0x00,
}

func (m *SourceChannelIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceChannelIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceChannelIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Token != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Token))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dst != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Dst))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dst != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Dst))
		i--
		dAtA[i] = 0x10
	}
	if m.Src != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Src))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ColumnIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ColumnIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ColumnIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsPrimary {
		i--
		if m.IsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Tags) > 0 {
		dAtA2 := make([]byte, len(m.Tags)*10)
		var j1 int
		for _, num := range m.Tags {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPacket(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		dAtA4 := make([]byte, len(m.Key)*10)
		var j3 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintPacket(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPathSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPathSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPathSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartialKey) > 0 {
		dAtA6 := make([]byte, len(m.PartialKey)*10)
		var j5 int
		for _, num1 := range m.PartialKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintPacket(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if m.ForceTagTo != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.ForceTagTo))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SourceSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyIdxToShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.KeyIdxToShard))
		i--
		dAtA[i] = 0x18
	}
	if m.NumShards != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.NumShards))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SourceSelection != nil {
		{
			size, err := m.SourceSelection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Domain != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Cols) > 0 {
		dAtA9 := make([]byte, len(m.Cols)*10)
		var j8 int
		for _, num1 := range m.Cols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPacket(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x12
	}
	if m.Kind != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetupReplayPathRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetupReplayPathRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetupReplayPathRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSegment {
		i--
		if m.LastSegment {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Upquery) > 0 {
		i -= len(m.Upquery)
		copy(dAtA[i:], m.Upquery)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Upquery)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.NotifyDone {
		i--
		if m.NotifyDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PartialUnicastSharder != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.PartialUnicastSharder))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Path) > 0 {
		for iNdEx := len(m.Path) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Path[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Source != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Input) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Senders) > 0 {
		for iNdEx := len(m.Senders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Senders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SeenTags) > 0 {
		for iNdEx := len(m.SeenTags) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SeenTags[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Message_Seen) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message_Seen) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Seen) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPiece) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPiece) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.External != nil {
		{
			size, err := m.External.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Context != nil {
		{
			size := m.Context.Size()
			i -= size
			if _, err := m.Context.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPiece_Partial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_Partial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Partial != nil {
		{
			size, err := m.Partial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReplayPiece_Regular) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_Regular) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Regular != nil {
		{
			size, err := m.Regular.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReplayPiece_Replace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_Replace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Replace != nil {
		{
			size, err := m.Replace.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReplayPiece_ContextPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPiece_ContextPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_ContextPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ignore {
		i--
		if m.Ignore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Unishard {
		i--
		if m.Unishard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RequestingShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.RequestingShard))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ForKeys) > 0 {
		for k := range m.ForKeys {
			v := m.ForKeys[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPacket(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPacket(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPiece_ContextRegular) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPiece_ContextRegular) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_ContextRegular) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Last {
		i--
		if m.Last {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPiece_ContextReplace) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPiece_ContextReplace) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_ContextReplace) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OriginalLink != nil {
		{
			size, err := m.OriginalLink.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPiece_External) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPiece_External) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPiece_External) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Failed {
		i--
		if m.Failed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Intermediate {
		i--
		if m.Intermediate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Slot != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Slot))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EvictRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvictRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvictRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBytes != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EvictKeysRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EvictKeysRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EvictKeysRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishReplayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishReplayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishReplayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NotifyDone {
		i--
		if m.NotifyDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parents) > 0 {
		dAtA22 := make([]byte, len(m.Parents)*10)
		var j21 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintPacket(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x12
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		dAtA25 := make([]byte, len(m.Nodes)*10)
		var j24 int
		for _, num := range m.Nodes {
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintPacket(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewTag != nil {
		{
			size, err := m.NewTag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NewTx != nil {
		{
			size, err := m.NewTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEgressRequest_Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEgressRequest_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEgressRequest_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Local != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Local))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateEgressRequest_Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateEgressRequest_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateEgressRequest_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSharderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSharderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSharderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewTxs) > 0 {
		for iNdEx := len(m.NewTxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewTxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateSharderRequest_Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSharderRequest_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateSharderRequest_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Local != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Local))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest_PartialLocal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_PartialLocal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartialLocal != nil {
		{
			size, err := m.PartialLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *PrepareStateRequest_IndexedLocal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_IndexedLocal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexedLocal != nil {
		{
			size, err := m.IndexedLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *PrepareStateRequest_PartialGlobal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_PartialGlobal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartialGlobal != nil {
		{
			size, err := m.PartialGlobal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *PrepareStateRequest_Global_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_Global_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *PrepareStateRequest_PartialLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest_PartialLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_PartialLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest_IndexedLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest_IndexedLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_IndexedLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest_PartialGlobal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest_PartialGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_PartialGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TriggerDomain != nil {
		{
			size, err := m.TriggerDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		dAtA36 := make([]byte, len(m.Key)*10)
		var j35 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintPacket(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cols != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shards != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Shards))
		i--
		dAtA[i] = 0x10
	}
	if m.Domain != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrepareStateRequest_Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrepareStateRequest_Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrepareStateRequest_Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA38 := make([]byte, len(m.Key)*10)
		var j37 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		i -= j37
		copy(dAtA[i:], dAtA38[:j37])
		i = encodeVarintPacket(dAtA, i, uint64(j37))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cols != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PartialReplayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PartialReplayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PartialReplayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestingShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.RequestingShard))
		i--
		dAtA[i] = 0x20
	}
	if m.Unishard {
		i--
		if m.Unishard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReaderReplayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReaderReplayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReaderReplayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Cols) > 0 {
		dAtA40 := make([]byte, len(m.Cols)*10)
		var j39 int
		for _, num1 := range m.Cols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		i -= j39
		copy(dAtA[i:], dAtA40[:j39])
		i = encodeVarintPacket(dAtA, i, uint64(j39))
		i--
		dAtA[i] = 0x12
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StartReplayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartReplayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartReplayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WaitForReplayRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WaitForReplayRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WaitForReplayRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Sync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Async) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Async) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Async) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintPacket(dAtA []byte, offset int, v uint64) int {
	offset -= sovPacket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SourceChannelIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != 0 {
		n += 1 + sovPacket(uint64(m.Token))
	}
	if m.Epoch != 0 {
		n += 1 + sovPacket(uint64(m.Epoch))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	return n
}

func (m *TableOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *FlowInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dst != 0 {
		n += 1 + sovPacket(uint64(m.Dst))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != 0 {
		n += 1 + sovPacket(uint64(m.Src))
	}
	if m.Dst != 0 {
		n += 1 + sovPacket(uint64(m.Dst))
	}
	return n
}

func (m *ColumnIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if len(m.Tags) > 0 {
		l = 0
		for _, e := range m.Tags {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if m.IsPrimary {
		n += 2
	}
	return n
}

func (m *ReplayPathSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.ForceTagTo != 0 {
		n += 1 + sovPacket(uint64(m.ForceTagTo))
	}
	if len(m.PartialKey) > 0 {
		l = 0
		for _, e := range m.PartialKey {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *SourceSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovPacket(uint64(m.Kind))
	}
	if m.NumShards != 0 {
		n += 1 + sovPacket(uint64(m.NumShards))
	}
	if m.KeyIdxToShard != 0 {
		n += 1 + sovPacket(uint64(m.KeyIdxToShard))
	}
	return n
}

func (m *TriggerEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovPacket(uint64(m.Kind))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if m.Domain != 0 {
		n += 1 + sovPacket(uint64(m.Domain))
	}
	if m.SourceSelection != nil {
		l = m.SourceSelection.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *SetupReplayPathRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Source != 0 {
		n += 1 + sovPacket(uint64(m.Source))
	}
	if len(m.Path) > 0 {
		for _, e := range m.Path {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.PartialUnicastSharder != 0 {
		n += 1 + sovPacket(uint64(m.PartialUnicastSharder))
	}
	if m.NotifyDone {
		n += 2
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Upquery)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.LastSegment {
		n += 2
	}
	return n
}

func (m *ReadyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Senders) > 0 {
		for _, e := range m.Senders {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if len(m.SeenTags) > 0 {
		for _, e := range m.SeenTags {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Message_Seen) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovPacket(uint64(m.Offset))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	return n
}

func (m *ReplayPiece) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.Context != nil {
		n += m.Context.Size()
	}
	if m.External != nil {
		l = m.External.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *ReplayPiece_Partial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Partial != nil {
		l = m.Partial.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *ReplayPiece_Regular) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Regular != nil {
		l = m.Regular.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *ReplayPiece_Replace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Replace != nil {
		l = m.Replace.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *ReplayPiece_ContextPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ForKeys) > 0 {
		for k, v := range m.ForKeys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPacket(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovPacket(uint64(mapEntrySize))
		}
	}
	if m.RequestingShard != 0 {
		n += 1 + sovPacket(uint64(m.RequestingShard))
	}
	if m.Unishard {
		n += 2
	}
	if m.Ignore {
		n += 2
	}
	return n
}

func (m *ReplayPiece_ContextRegular) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Last {
		n += 2
	}
	return n
}

func (m *ReplayPiece_ContextReplace) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OriginalLink != nil {
		l = m.OriginalLink.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *ReplayPiece_External) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Slot != 0 {
		n += 1 + sovPacket(uint64(m.Slot))
	}
	if m.Intermediate {
		n += 2
	}
	if m.Failed {
		n += 2
	}
	return n
}

func (m *EvictRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.NumBytes != 0 {
		n += 1 + sovPacket(uint64(m.NumBytes))
	}
	return n
}

func (m *EvictKeysRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *FinishReplayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.NotifyDone {
		n += 2
	}
	return n
}

func (m *AddNodeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *RemoveNodesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		l = 0
		for _, e := range m.Nodes {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *UpdateEgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.NewTx != nil {
		l = m.NewTx.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.NewTag != nil {
		l = m.NewTag.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *UpdateEgressRequest_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.Local != 0 {
		n += 1 + sovPacket(uint64(m.Local))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *UpdateEgressRequest_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	return n
}

func (m *UpdateSharderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.NewTxs) > 0 {
		for _, e := range m.NewTxs {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *UpdateSharderRequest_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != 0 {
		n += 1 + sovPacket(uint64(m.Local))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *PrepareStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *PrepareStateRequest_PartialLocal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartialLocal != nil {
		l = m.PartialLocal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *PrepareStateRequest_IndexedLocal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexedLocal != nil {
		l = m.IndexedLocal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *PrepareStateRequest_PartialGlobal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartialGlobal != nil {
		l = m.PartialGlobal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *PrepareStateRequest_Global_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *PrepareStateRequest_PartialLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *PrepareStateRequest_IndexedLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *PrepareStateRequest_PartialGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovPacket(uint64(m.Gid))
	}
	if m.Cols != 0 {
		n += 1 + sovPacket(uint64(m.Cols))
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if m.TriggerDomain != nil {
		l = m.TriggerDomain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovPacket(uint64(m.Domain))
	}
	if m.Shards != 0 {
		n += 1 + sovPacket(uint64(m.Shards))
	}
	return n
}

func (m *PrepareStateRequest_Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovPacket(uint64(m.Gid))
	}
	if m.Cols != 0 {
		n += 1 + sovPacket(uint64(m.Cols))
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *PartialReplayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.Unishard {
		n += 2
	}
	if m.RequestingShard != 0 {
		n += 1 + sovPacket(uint64(m.RequestingShard))
	}
	return n
}

func (m *ReaderReplayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *StartReplayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.From != 0 {
		n += 1 + sovPacket(uint64(m.From))
	}
	return n
}

func (m *WaitForReplayRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Sync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Async) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovPacket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPacket(x uint64) (n int) {
	return sovPacket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SourceChannelIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceChannelIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceChannelIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			m.Token = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Token |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= TableOperation_Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = vitess_io_vitess_go_boost_sql.Row(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			m.Dst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dst |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &TableOperation{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			m.Dst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dst |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ColumnIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 2:
			if wireType == 0 {
				var v vitess_io_vitess_go_boost_dataflow.Tag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tags = append(m.Tags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Tags) == 0 {
					m.Tags = make([]vitess_io_vitess_go_boost_dataflow.Tag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v vitess_io_vitess_go_boost_dataflow.Tag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tags = append(m.Tags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPrimary = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPathSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplayPathSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplayPathSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceTagTo", wireType)
			}
			m.ForceTagTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceTagTo |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartialKey = append(m.PartialKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartialKey) == 0 {
					m.PartialKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartialKey = append(m.PartialKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialKey", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= SourceSelection_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumShards", wireType)
			}
			m.NumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumShards |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIdxToShard", wireType)
			}
			m.KeyIdxToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIdxToShard |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= TriggerEndpoint_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= vitess_io_vitess_go_boost_dataflow.DomainIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceSelection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SourceSelection == nil {
				m.SourceSelection = &SourceSelection{}
			}
			if err := m.SourceSelection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetupReplayPathRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetupReplayPathRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetupReplayPathRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, &ReplayPathSegment{})
			if err := m.Path[len(m.Path)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialUnicastSharder", wireType)
			}
			m.PartialUnicastSharder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialUnicastSharder |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotifyDone = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &TriggerEndpoint{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upquery", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upquery = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSegment", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastSegment = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &ColumnIndex{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &FlowInput{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &SourceChannelIdentifier{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Senders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Senders = append(m.Senders, &SourceChannelIdentifier{})
			if err := m.Senders[len(m.Senders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, sql.Record{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeenTags", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeenTags = append(m.SeenTags, Message_Seen{})
			if err := m.SeenTags[len(m.SeenTags)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message_Seen) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Seen: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Seen: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPiece) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplayPiece: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplayPiece: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, sql.Record{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplayPiece_ContextPartial{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &ReplayPiece_Partial{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regular", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplayPiece_ContextRegular{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &ReplayPiece_Regular{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replace", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ReplayPiece_ContextReplace{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &ReplayPiece_Replace{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field External", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.External == nil {
				m.External = &ReplayPiece_External{}
			}
			if err := m.External.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPiece_ContextPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForKeys == nil {
				m.ForKeys = make(map[vitess_io_vitess_go_boost_sql.Row]bool)
			}
			var mapkey vitess_io_vitess_go_boost_sql.Row
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = vitess_io_vitess_go_boost_sql.Row(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPacket(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPacket
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ForKeys[vitess_io_vitess_go_boost_sql.Row(mapkey)] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestingShard", wireType)
			}
			m.RequestingShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestingShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unishard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unishard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ignore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPiece_ContextRegular) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextRegular: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextRegular: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Last = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPiece_ContextReplace) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextReplace: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextReplace: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalLink", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginalLink == nil {
				m.OriginalLink = &Link{}
			}
			if err := m.OriginalLink.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPiece_External) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: External: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: External: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Slot", wireType)
			}
			m.Slot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Slot |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Intermediate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Intermediate = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Failed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvictRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvictRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvictRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EvictKeysRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvictKeysRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvictKeysRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, vitess_io_vitess_go_boost_sql.Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishReplayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishReplayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishReplayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotifyDone = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &flownodepb.Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parents) == 0 {
					m.Parents = make([]vitess_io_vitess_go_boost_dataflow.LocalNodeIdx, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nodes = append(m.Nodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Nodes) == 0 {
					m.Nodes = make([]vitess_io_vitess_go_boost_dataflow.LocalNodeIdx, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nodes = append(m.Nodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewTx == nil {
				m.NewTx = &UpdateEgressRequest_Tx{}
			}
			if err := m.NewTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewTag == nil {
				m.NewTag = &UpdateEgressRequest_Tag{}
			}
			if err := m.NewTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEgressRequest_Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			m.Local = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Local |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &dataflow.DomainAddr{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateEgressRequest_Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSharderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSharderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSharderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTxs = append(m.NewTxs, &UpdateSharderRequest_Tx{})
			if err := m.NewTxs[len(m.NewTxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSharderRequest_Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			m.Local = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Local |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &dataflow.DomainAddr{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrepareStateRequest_PartialLocal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &PrepareStateRequest_PartialLocal_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrepareStateRequest_IndexedLocal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &PrepareStateRequest_IndexedLocal_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrepareStateRequest_PartialGlobal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &PrepareStateRequest_PartialGlobal_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrepareStateRequest_Global{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &PrepareStateRequest_Global_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest_PartialLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &ColumnIndex{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest_IndexedLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &ColumnIndex{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest_PartialGlobal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialGlobal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialGlobal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerDomain == nil {
				m.TriggerDomain = &PrepareStateRequest_PartialGlobal_TriggerDomain{}
			}
			if err := m.TriggerDomain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest_PartialGlobal_TriggerDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= vitess_io_vitess_go_boost_dataflow.DomainIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrepareStateRequest_Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PartialReplayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialReplayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialReplayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, vitess_io_vitess_go_boost_sql.Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unishard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unishard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestingShard", wireType)
			}
			m.RequestingShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestingShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReaderReplayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReaderReplayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReaderReplayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, vitess_io_vitess_go_boost_sql.Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartReplayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartReplayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartReplayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= vitess_io_vitess_go_boost_dataflow.Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WaitForReplayRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WaitForReplayRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WaitForReplayRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Async) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Async: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Async: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPacket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPacket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPacket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPacket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPacket = fmt.Errorf("proto: unexpected end of group")
)
