// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: service.proto

package boostpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type WorkerSource struct {
	SourceUuid string `protobuf:"bytes,1,opt,name=source_uuid,json=sourceUuid,proto3" json:"source_uuid,omitempty"`
	Epoch      Epoch  `protobuf:"varint,2,opt,name=epoch,proto3,casttype=Epoch" json:"epoch,omitempty"`
}

func (m *WorkerSource) Reset()         { *m = WorkerSource{} }
func (m *WorkerSource) String() string { return proto.CompactTextString(m) }
func (*WorkerSource) ProtoMessage()    {}
func (*WorkerSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{0}
}
func (m *WorkerSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerSource.Merge(m, src)
}
func (m *WorkerSource) XXX_Size() int {
	return m.Size()
}
func (m *WorkerSource) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerSource.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerSource proto.InternalMessageInfo

type RegisterWorkerRequest struct {
	From           *WorkerSource `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Addr           string        `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
	ReadListenAddr string        `protobuf:"bytes,3,opt,name=read_listen_addr,json=readListenAddr,proto3" json:"read_listen_addr,omitempty"`
	LogFiles       []string      `protobuf:"bytes,4,rep,name=log_files,json=logFiles,proto3" json:"log_files,omitempty"`
}

func (m *RegisterWorkerRequest) Reset()         { *m = RegisterWorkerRequest{} }
func (m *RegisterWorkerRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerRequest) ProtoMessage()    {}
func (*RegisterWorkerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{1}
}
func (m *RegisterWorkerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerRequest.Merge(m, src)
}
func (m *RegisterWorkerRequest) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerRequest proto.InternalMessageInfo

type RegisterWorkerResponse struct {
}

func (m *RegisterWorkerResponse) Reset()         { *m = RegisterWorkerResponse{} }
func (m *RegisterWorkerResponse) String() string { return proto.CompactTextString(m) }
func (*RegisterWorkerResponse) ProtoMessage()    {}
func (*RegisterWorkerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{2}
}
func (m *RegisterWorkerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterWorkerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterWorkerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterWorkerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterWorkerResponse.Merge(m, src)
}
func (m *RegisterWorkerResponse) XXX_Size() int {
	return m.Size()
}
func (m *RegisterWorkerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterWorkerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterWorkerResponse proto.InternalMessageInfo

type AssignDomainRequest struct {
	From   *WorkerSource  `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Domain *DomainBuilder `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *AssignDomainRequest) Reset()         { *m = AssignDomainRequest{} }
func (m *AssignDomainRequest) String() string { return proto.CompactTextString(m) }
func (*AssignDomainRequest) ProtoMessage()    {}
func (*AssignDomainRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{3}
}
func (m *AssignDomainRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignDomainRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignDomainRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignDomainRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignDomainRequest.Merge(m, src)
}
func (m *AssignDomainRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssignDomainRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignDomainRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssignDomainRequest proto.InternalMessageInfo

type AssignDomainResponse struct {
	Shard uint   `protobuf:"varint,1,opt,name=shard,proto3,casttype=uint" json:"shard,omitempty"`
	Addr  string `protobuf:"bytes,2,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *AssignDomainResponse) Reset()         { *m = AssignDomainResponse{} }
func (m *AssignDomainResponse) String() string { return proto.CompactTextString(m) }
func (*AssignDomainResponse) ProtoMessage()    {}
func (*AssignDomainResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{4}
}
func (m *AssignDomainResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignDomainResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignDomainResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignDomainResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignDomainResponse.Merge(m, src)
}
func (m *AssignDomainResponse) XXX_Size() int {
	return m.Size()
}
func (m *AssignDomainResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignDomainResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AssignDomainResponse proto.InternalMessageInfo

type DomainDescriptor struct {
	Id    DomainIndex `protobuf:"varint,1,opt,name=id,proto3,casttype=DomainIndex" json:"id,omitempty"`
	Shard uint        `protobuf:"varint,2,opt,name=shard,proto3,casttype=uint" json:"shard,omitempty"`
	Addr  string      `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *DomainDescriptor) Reset()         { *m = DomainDescriptor{} }
func (m *DomainDescriptor) String() string { return proto.CompactTextString(m) }
func (*DomainDescriptor) ProtoMessage()    {}
func (*DomainDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{5}
}
func (m *DomainDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainDescriptor.Merge(m, src)
}
func (m *DomainDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *DomainDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_DomainDescriptor proto.InternalMessageInfo

type DomainBootedRequest struct {
	From   *WorkerSource     `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Domain *DomainDescriptor `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *DomainBootedRequest) Reset()         { *m = DomainBootedRequest{} }
func (m *DomainBootedRequest) String() string { return proto.CompactTextString(m) }
func (*DomainBootedRequest) ProtoMessage()    {}
func (*DomainBootedRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{6}
}
func (m *DomainBootedRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainBootedRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainBootedRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainBootedRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainBootedRequest.Merge(m, src)
}
func (m *DomainBootedRequest) XXX_Size() int {
	return m.Size()
}
func (m *DomainBootedRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainBootedRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DomainBootedRequest proto.InternalMessageInfo

type DomainBootedResponse struct {
}

func (m *DomainBootedResponse) Reset()         { *m = DomainBootedResponse{} }
func (m *DomainBootedResponse) String() string { return proto.CompactTextString(m) }
func (*DomainBootedResponse) ProtoMessage()    {}
func (*DomainBootedResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{7}
}
func (m *DomainBootedResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainBootedResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainBootedResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainBootedResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainBootedResponse.Merge(m, src)
}
func (m *DomainBootedResponse) XXX_Size() int {
	return m.Size()
}
func (m *DomainBootedResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainBootedResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DomainBootedResponse proto.InternalMessageInfo

type HeartbeatPacket struct {
}

func (m *HeartbeatPacket) Reset()         { *m = HeartbeatPacket{} }
func (m *HeartbeatPacket) String() string { return proto.CompactTextString(m) }
func (*HeartbeatPacket) ProtoMessage()    {}
func (*HeartbeatPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{8}
}
func (m *HeartbeatPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatPacket.Merge(m, src)
}
func (m *HeartbeatPacket) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatPacket.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatPacket proto.InternalMessageInfo

type AssignStreamRequest struct {
	Tables []*ExternalTableDescriptor `protobuf:"bytes,1,rep,name=tables,proto3" json:"tables,omitempty"`
}

func (m *AssignStreamRequest) Reset()         { *m = AssignStreamRequest{} }
func (m *AssignStreamRequest) String() string { return proto.CompactTextString(m) }
func (*AssignStreamRequest) ProtoMessage()    {}
func (*AssignStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{9}
}
func (m *AssignStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignStreamRequest.Merge(m, src)
}
func (m *AssignStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *AssignStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AssignStreamRequest proto.InternalMessageInfo

type AssignStreamResponse struct {
}

func (m *AssignStreamResponse) Reset()         { *m = AssignStreamResponse{} }
func (m *AssignStreamResponse) String() string { return proto.CompactTextString(m) }
func (*AssignStreamResponse) ProtoMessage()    {}
func (*AssignStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{10}
}
func (m *AssignStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AssignStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AssignStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AssignStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AssignStreamResponse.Merge(m, src)
}
func (m *AssignStreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *AssignStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AssignStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AssignStreamResponse proto.InternalMessageInfo

type PacketResponse struct {
}

func (m *PacketResponse) Reset()         { *m = PacketResponse{} }
func (m *PacketResponse) String() string { return proto.CompactTextString(m) }
func (*PacketResponse) ProtoMessage()    {}
func (*PacketResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{11}
}
func (m *PacketResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PacketResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PacketResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PacketResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PacketResponse.Merge(m, src)
}
func (m *PacketResponse) XXX_Size() int {
	return m.Size()
}
func (m *PacketResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PacketResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PacketResponse proto.InternalMessageInfo

type ViewReadRequest struct {
	TargetNode  GraphNodeIdx `protobuf:"varint,1,opt,name=target_node,json=targetNode,proto3,casttype=GraphNodeIdx" json:"target_node,omitempty"`
	TargetShard uint         `protobuf:"varint,2,opt,name=target_shard,json=targetShard,proto3,casttype=uint" json:"target_shard,omitempty"`
	Key         Row          `protobuf:"bytes,3,opt,name=key,proto3,casttype=Row" json:"key,omitempty"`
	Block       bool         `protobuf:"varint,4,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *ViewReadRequest) Reset()         { *m = ViewReadRequest{} }
func (m *ViewReadRequest) String() string { return proto.CompactTextString(m) }
func (*ViewReadRequest) ProtoMessage()    {}
func (*ViewReadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{12}
}
func (m *ViewReadRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewReadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewReadRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewReadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewReadRequest.Merge(m, src)
}
func (m *ViewReadRequest) XXX_Size() int {
	return m.Size()
}
func (m *ViewReadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewReadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ViewReadRequest proto.InternalMessageInfo

type ViewReadManyRequest struct {
	TargetNode  GraphNodeIdx `protobuf:"varint,1,opt,name=target_node,json=targetNode,proto3,casttype=GraphNodeIdx" json:"target_node,omitempty"`
	TargetShard uint         `protobuf:"varint,2,opt,name=target_shard,json=targetShard,proto3,casttype=uint" json:"target_shard,omitempty"`
	Keys        []Row        `protobuf:"bytes,3,rep,name=keys,proto3,casttype=Row" json:"keys,omitempty"`
	Block       bool         `protobuf:"varint,4,opt,name=block,proto3" json:"block,omitempty"`
}

func (m *ViewReadManyRequest) Reset()         { *m = ViewReadManyRequest{} }
func (m *ViewReadManyRequest) String() string { return proto.CompactTextString(m) }
func (*ViewReadManyRequest) ProtoMessage()    {}
func (*ViewReadManyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{13}
}
func (m *ViewReadManyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewReadManyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewReadManyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewReadManyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewReadManyRequest.Merge(m, src)
}
func (m *ViewReadManyRequest) XXX_Size() int {
	return m.Size()
}
func (m *ViewReadManyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewReadManyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ViewReadManyRequest proto.InternalMessageInfo

type ViewReadResponse struct {
	Rows []Row `protobuf:"bytes,1,rep,name=rows,proto3,casttype=Row" json:"rows,omitempty"`
	Hits int32 `protobuf:"varint,2,opt,name=hits,proto3" json:"hits,omitempty"`
}

func (m *ViewReadResponse) Reset()         { *m = ViewReadResponse{} }
func (m *ViewReadResponse) String() string { return proto.CompactTextString(m) }
func (*ViewReadResponse) ProtoMessage()    {}
func (*ViewReadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{14}
}
func (m *ViewReadResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewReadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewReadResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewReadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewReadResponse.Merge(m, src)
}
func (m *ViewReadResponse) XXX_Size() int {
	return m.Size()
}
func (m *ViewReadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewReadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ViewReadResponse proto.InternalMessageInfo

type ViewSizeRequest struct {
	TargetNode GraphNodeIdx `protobuf:"varint,1,opt,name=target_node,json=targetNode,proto3,casttype=GraphNodeIdx" json:"target_node,omitempty"`
	TargetCol  int          `protobuf:"varint,2,opt,name=target_col,json=targetCol,proto3,casttype=int" json:"target_col,omitempty"`
}

func (m *ViewSizeRequest) Reset()         { *m = ViewSizeRequest{} }
func (m *ViewSizeRequest) String() string { return proto.CompactTextString(m) }
func (*ViewSizeRequest) ProtoMessage()    {}
func (*ViewSizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{15}
}
func (m *ViewSizeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewSizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewSizeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewSizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewSizeRequest.Merge(m, src)
}
func (m *ViewSizeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ViewSizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewSizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ViewSizeRequest proto.InternalMessageInfo

type ViewSizeResponse struct {
	TotalSize int64 `protobuf:"varint,1,opt,name=total_size,json=totalSize,proto3" json:"total_size,omitempty"`
}

func (m *ViewSizeResponse) Reset()         { *m = ViewSizeResponse{} }
func (m *ViewSizeResponse) String() string { return proto.CompactTextString(m) }
func (*ViewSizeResponse) ProtoMessage()    {}
func (*ViewSizeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{16}
}
func (m *ViewSizeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewSizeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewSizeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewSizeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewSizeResponse.Merge(m, src)
}
func (m *ViewSizeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ViewSizeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewSizeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ViewSizeResponse proto.InternalMessageInfo

type TableDescriptor struct {
	Txs          []*DomainDescriptor `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	Node         GraphNodeIdx        `protobuf:"varint,2,opt,name=node,proto3,casttype=GraphNodeIdx" json:"node,omitempty"`
	Addr         LocalNodeIndex      `protobuf:"varint,3,opt,name=addr,proto3,casttype=LocalNodeIndex" json:"addr,omitempty"`
	KeyIsPrimary bool                `protobuf:"varint,4,opt,name=key_is_primary,json=keyIsPrimary,proto3" json:"key_is_primary,omitempty"`
	Key          []int               `protobuf:"varint,5,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	Dropped      map[int]Value       `protobuf:"bytes,6,rep,name=dropped,proto3,castkey=int,castvalue=Value" json:"dropped,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TableName    string              `protobuf:"bytes,7,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Columns      []string            `protobuf:"bytes,8,rep,name=columns,proto3" json:"columns,omitempty"`
	Schema       []Type              `protobuf:"bytes,9,rep,name=schema,proto3" json:"schema"`
}

func (m *TableDescriptor) Reset()         { *m = TableDescriptor{} }
func (m *TableDescriptor) String() string { return proto.CompactTextString(m) }
func (*TableDescriptor) ProtoMessage()    {}
func (*TableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{17}
}
func (m *TableDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableDescriptor.Merge(m, src)
}
func (m *TableDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *TableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TableDescriptor proto.InternalMessageInfo

type ExternalTableDescriptor struct {
	Txs          []*DomainAddr  `protobuf:"bytes,1,rep,name=txs,proto3" json:"txs,omitempty"`
	Node         GraphNodeIdx   `protobuf:"varint,2,opt,name=node,proto3,casttype=GraphNodeIdx" json:"node,omitempty"`
	Addr         LocalNodeIndex `protobuf:"varint,3,opt,name=addr,proto3,casttype=LocalNodeIndex" json:"addr,omitempty"`
	KeyIsPrimary bool           `protobuf:"varint,4,opt,name=key_is_primary,json=keyIsPrimary,proto3" json:"key_is_primary,omitempty"`
	Key          []int          `protobuf:"varint,5,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	TableName    string         `protobuf:"bytes,7,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
	Columns      []string       `protobuf:"bytes,8,rep,name=columns,proto3" json:"columns,omitempty"`
	Schema       []Type         `protobuf:"bytes,9,rep,name=schema,proto3" json:"schema"`
	Keyspace     string         `protobuf:"bytes,10,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
}

func (m *ExternalTableDescriptor) Reset()         { *m = ExternalTableDescriptor{} }
func (m *ExternalTableDescriptor) String() string { return proto.CompactTextString(m) }
func (*ExternalTableDescriptor) ProtoMessage()    {}
func (*ExternalTableDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{18}
}
func (m *ExternalTableDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalTableDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalTableDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalTableDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalTableDescriptor.Merge(m, src)
}
func (m *ExternalTableDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *ExternalTableDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalTableDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalTableDescriptor proto.InternalMessageInfo

type DomainBuilder struct {
	Index     DomainIndex              `protobuf:"varint,1,opt,name=index,proto3,casttype=DomainIndex" json:"index,omitempty"`
	Shard     uint                     `protobuf:"varint,2,opt,name=shard,proto3,casttype=uint" json:"shard,omitempty"`
	NumShards uint                     `protobuf:"varint,3,opt,name=num_shards,json=numShards,proto3,casttype=uint" json:"num_shards,omitempty"`
	Nodes     map[LocalNodeIndex]*Node `protobuf:"bytes,4,rep,name=nodes,proto3,castkey=LocalNodeIndex" json:"nodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Config    *DomainConfig            `protobuf:"bytes,5,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *DomainBuilder) Reset()         { *m = DomainBuilder{} }
func (m *DomainBuilder) String() string { return proto.CompactTextString(m) }
func (*DomainBuilder) ProtoMessage()    {}
func (*DomainBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{19}
}
func (m *DomainBuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainBuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainBuilder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainBuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainBuilder.Merge(m, src)
}
func (m *DomainBuilder) XXX_Size() int {
	return m.Size()
}
func (m *DomainBuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainBuilder.DiscardUnknown(m)
}

var xxx_messageInfo_DomainBuilder proto.InternalMessageInfo

type MemoryStatsRequest struct {
}

func (m *MemoryStatsRequest) Reset()         { *m = MemoryStatsRequest{} }
func (m *MemoryStatsRequest) String() string { return proto.CompactTextString(m) }
func (*MemoryStatsRequest) ProtoMessage()    {}
func (*MemoryStatsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{20}
}
func (m *MemoryStatsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStatsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStatsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStatsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStatsRequest.Merge(m, src)
}
func (m *MemoryStatsRequest) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStatsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStatsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStatsRequest proto.InternalMessageInfo

type MemoryStatsResponse struct {
	NodeUsage []*MemoryStatsResponse_MemUsage `protobuf:"bytes,1,rep,name=node_usage,json=nodeUsage,proto3" json:"node_usage,omitempty"`
}

func (m *MemoryStatsResponse) Reset()         { *m = MemoryStatsResponse{} }
func (m *MemoryStatsResponse) String() string { return proto.CompactTextString(m) }
func (*MemoryStatsResponse) ProtoMessage()    {}
func (*MemoryStatsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{21}
}
func (m *MemoryStatsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStatsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStatsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStatsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStatsResponse.Merge(m, src)
}
func (m *MemoryStatsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStatsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStatsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStatsResponse proto.InternalMessageInfo

type MemoryStatsResponse_MemUsage struct {
	Domain DomainAddr   `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain"`
	Node   GraphNodeIdx `protobuf:"varint,2,opt,name=node,proto3,casttype=GraphNodeIdx" json:"node,omitempty"`
	Memory int64        `protobuf:"varint,3,opt,name=memory,proto3" json:"memory,omitempty"`
}

func (m *MemoryStatsResponse_MemUsage) Reset()         { *m = MemoryStatsResponse_MemUsage{} }
func (m *MemoryStatsResponse_MemUsage) String() string { return proto.CompactTextString(m) }
func (*MemoryStatsResponse_MemUsage) ProtoMessage()    {}
func (*MemoryStatsResponse_MemUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_a0b84a42fa06f626, []int{21, 0}
}
func (m *MemoryStatsResponse_MemUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemoryStatsResponse_MemUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemoryStatsResponse_MemUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemoryStatsResponse_MemUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemoryStatsResponse_MemUsage.Merge(m, src)
}
func (m *MemoryStatsResponse_MemUsage) XXX_Size() int {
	return m.Size()
}
func (m *MemoryStatsResponse_MemUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_MemoryStatsResponse_MemUsage.DiscardUnknown(m)
}

var xxx_messageInfo_MemoryStatsResponse_MemUsage proto.InternalMessageInfo

func init() {
	proto.RegisterType((*WorkerSource)(nil), "service.WorkerSource")
	proto.RegisterType((*RegisterWorkerRequest)(nil), "service.RegisterWorkerRequest")
	proto.RegisterType((*RegisterWorkerResponse)(nil), "service.RegisterWorkerResponse")
	proto.RegisterType((*AssignDomainRequest)(nil), "service.AssignDomainRequest")
	proto.RegisterType((*AssignDomainResponse)(nil), "service.AssignDomainResponse")
	proto.RegisterType((*DomainDescriptor)(nil), "service.DomainDescriptor")
	proto.RegisterType((*DomainBootedRequest)(nil), "service.DomainBootedRequest")
	proto.RegisterType((*DomainBootedResponse)(nil), "service.DomainBootedResponse")
	proto.RegisterType((*HeartbeatPacket)(nil), "service.HeartbeatPacket")
	proto.RegisterType((*AssignStreamRequest)(nil), "service.AssignStreamRequest")
	proto.RegisterType((*AssignStreamResponse)(nil), "service.AssignStreamResponse")
	proto.RegisterType((*PacketResponse)(nil), "service.PacketResponse")
	proto.RegisterType((*ViewReadRequest)(nil), "service.ViewReadRequest")
	proto.RegisterType((*ViewReadManyRequest)(nil), "service.ViewReadManyRequest")
	proto.RegisterType((*ViewReadResponse)(nil), "service.ViewReadResponse")
	proto.RegisterType((*ViewSizeRequest)(nil), "service.ViewSizeRequest")
	proto.RegisterType((*ViewSizeResponse)(nil), "service.ViewSizeResponse")
	proto.RegisterType((*TableDescriptor)(nil), "service.TableDescriptor")
	proto.RegisterMapType((map[int]Value)(nil), "service.TableDescriptor.DroppedEntry")
	proto.RegisterType((*ExternalTableDescriptor)(nil), "service.ExternalTableDescriptor")
	proto.RegisterType((*DomainBuilder)(nil), "service.DomainBuilder")
	proto.RegisterMapType((map[LocalNodeIndex]*Node)(nil), "service.DomainBuilder.NodesEntry")
	proto.RegisterType((*MemoryStatsRequest)(nil), "service.MemoryStatsRequest")
	proto.RegisterType((*MemoryStatsResponse)(nil), "service.MemoryStatsResponse")
	proto.RegisterType((*MemoryStatsResponse_MemUsage)(nil), "service.MemoryStatsResponse.MemUsage")
}

func init() { proto.RegisterFile("service.proto", fileDescriptor_a0b84a42fa06f626) }

var fileDescriptor_a0b84a42fa06f626 = []byte{
	// 1359 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x57, 0xcf, 0x6f, 0x13, 0xc7,
	0x17, 0xcf, 0x7a, 0x6d, 0xc7, 0x7e, 0x76, 0x12, 0x7f, 0x27, 0x21, 0x2c, 0x0e, 0xd8, 0x66, 0x05,
	0x7c, 0x5d, 0x21, 0x39, 0xc5, 0x3d, 0x14, 0x71, 0x41, 0x98, 0x50, 0x48, 0xf9, 0xd1, 0x74, 0x03,
	0x54, 0xea, 0xc5, 0xda, 0xec, 0x0e, 0xce, 0xca, 0xeb, 0x9d, 0xed, 0xcc, 0x1a, 0x62, 0x8e, 0x1c,
	0x7b, 0xea, 0x3f, 0xd0, 0x4b, 0x4f, 0xfd, 0x2f, 0xda, 0x43, 0x0f, 0x48, 0xbd, 0x20, 0x55, 0x95,
	0x7a, 0x32, 0x2d, 0xfc, 0x17, 0x39, 0x55, 0xf3, 0x63, 0xd7, 0x6b, 0xc7, 0x09, 0x15, 0x55, 0xab,
	0x5e, 0xac, 0x9d, 0x37, 0x6f, 0x3e, 0xef, 0xf3, 0x7e, 0xcc, 0x9b, 0x67, 0x58, 0x62, 0x98, 0x3e,
	0xf5, 0x1c, 0xdc, 0x0a, 0x29, 0x89, 0x08, 0x5a, 0x54, 0xcb, 0x6a, 0x39, 0xb4, 0x9d, 0x3e, 0x8e,
	0xa4, 0xb8, 0x0a, 0x01, 0x71, 0x95, 0x4a, 0xb5, 0xe2, 0x90, 0x20, 0xa2, 0xc4, 0xf7, 0x31, 0x55,
	0x92, 0xb5, 0x1e, 0xe9, 0x11, 0xf1, 0xb9, 0xc9, 0xbf, 0xa4, 0xd4, 0xdc, 0x81, 0xf2, 0x17, 0x84,
	0xf6, 0x31, 0xdd, 0x25, 0x43, 0xea, 0x60, 0x54, 0x87, 0x12, 0x13, 0x5f, 0xdd, 0xe1, 0xd0, 0x73,
	0x0d, 0xad, 0xa1, 0x35, 0x8b, 0x16, 0x48, 0xd1, 0xa3, 0xa1, 0xe7, 0xa2, 0x3a, 0xe4, 0x70, 0x48,
	0x9c, 0x7d, 0x23, 0xd3, 0xd0, 0x9a, 0x7a, 0xa7, 0x78, 0x38, 0xae, 0xe7, 0x6e, 0x71, 0x81, 0x25,
	0xe5, 0xe6, 0xb7, 0x1a, 0x9c, 0xb2, 0x70, 0xcf, 0x63, 0x11, 0xa6, 0x12, 0xda, 0xc2, 0x5f, 0x0d,
	0x31, 0x8b, 0xd0, 0x07, 0x90, 0x7d, 0x42, 0xc9, 0x40, 0x80, 0x96, 0xda, 0xa7, 0x5a, 0xb1, 0x53,
	0x69, 0x02, 0x96, 0x50, 0x41, 0x08, 0xb2, 0xb6, 0xeb, 0x52, 0x61, 0xa4, 0x68, 0x89, 0x6f, 0xd4,
	0x84, 0x0a, 0xc5, 0xb6, 0xdb, 0xf5, 0x39, 0x74, 0xd0, 0x15, 0xfb, 0xba, 0xd8, 0x5f, 0xe6, 0xf2,
	0x7b, 0x42, 0x7c, 0x83, 0x6b, 0x6e, 0x40, 0xd1, 0x27, 0xbd, 0xee, 0x13, 0xcf, 0xc7, 0xcc, 0xc8,
	0x36, 0xf4, 0x66, 0xd1, 0x2a, 0xf8, 0xa4, 0xf7, 0x09, 0x5f, 0x9b, 0x06, 0xac, 0xcf, 0xd2, 0x63,
	0x21, 0x09, 0x18, 0x36, 0x43, 0x58, 0xbd, 0xc1, 0x98, 0xd7, 0x0b, 0xb6, 0xc8, 0xc0, 0xf6, 0x82,
	0xf7, 0xa0, 0xdd, 0x82, 0xbc, 0x2b, 0xce, 0x0a, 0xe2, 0xa5, 0xf6, 0x7a, 0xa2, 0x2c, 0x21, 0x3b,
	0x43, 0xcf, 0x77, 0x31, 0xb5, 0x94, 0x96, 0xf9, 0x29, 0xac, 0x4d, 0x5b, 0x94, 0x4c, 0x50, 0x0d,
	0x72, 0x6c, 0xdf, 0xa6, 0x32, 0xfe, 0xd9, 0x4e, 0xe1, 0x70, 0x5c, 0xcf, 0x0e, 0xbd, 0x20, 0xb2,
	0xa4, 0x78, 0x5e, 0x78, 0xcc, 0x1e, 0x54, 0x24, 0xca, 0x16, 0x66, 0x0e, 0xf5, 0xc2, 0x88, 0x50,
	0x54, 0x87, 0x8c, 0x17, 0x83, 0xac, 0x1c, 0x8e, 0xeb, 0x25, 0xa9, 0xb1, 0x1d, 0xb8, 0xf8, 0xc0,
	0xca, 0x78, 0xee, 0xc4, 0x50, 0xe6, 0x64, 0x43, 0x7a, 0xca, 0x10, 0x83, 0x55, 0xe5, 0x0d, 0x21,
	0x11, 0x76, 0xdf, 0x23, 0x4c, 0x57, 0x66, 0xc2, 0x74, 0x66, 0x26, 0x4c, 0x13, 0x0f, 0x92, 0x48,
	0xad, 0xc3, 0xda, 0xb4, 0x51, 0x95, 0xb3, 0xff, 0xc1, 0xca, 0x1d, 0x6c, 0xd3, 0x68, 0x0f, 0xdb,
	0xd1, 0x8e, 0xb8, 0x0c, 0xe6, 0x67, 0x71, 0x1a, 0x77, 0x23, 0x8a, 0xed, 0x41, 0xcc, 0xef, 0x2a,
	0xe4, 0x23, 0x7b, 0x8f, 0x57, 0x84, 0xd6, 0xd0, 0x9b, 0xa5, 0x76, 0x23, 0x31, 0x7a, 0xeb, 0x20,
	0xc2, 0x34, 0xb0, 0xfd, 0x87, 0x7c, 0x3b, 0x6d, 0x5b, 0xea, 0x73, 0xdb, 0xd3, 0x80, 0xca, 0x76,
	0x05, 0x96, 0xa5, 0xc9, 0x44, 0xf2, 0x9d, 0x06, 0x2b, 0x8f, 0x3d, 0xfc, 0xcc, 0xc2, 0x76, 0x12,
	0x97, 0x2b, 0x50, 0x8a, 0x6c, 0xda, 0xc3, 0x51, 0x97, 0x5f, 0x4f, 0x11, 0x9e, 0xa5, 0x4e, 0xe5,
	0x70, 0x5c, 0x2f, 0xdf, 0xa6, 0x76, 0xb8, 0xff, 0x80, 0xb8, 0x78, 0xdb, 0x3d, 0xb0, 0x40, 0x2a,
	0xf1, 0x25, 0xba, 0x0c, 0x65, 0x75, 0x64, 0x7e, 0x72, 0x14, 0xe0, 0xae, 0x48, 0xd1, 0x19, 0xd0,
	0xfb, 0x78, 0x24, 0x33, 0xd4, 0x59, 0x3c, 0x1c, 0xd7, 0x75, 0x8b, 0x3c, 0xb3, 0xb8, 0x0c, 0xad,
	0x41, 0x6e, 0xcf, 0x27, 0x4e, 0xdf, 0xc8, 0x36, 0xb4, 0x66, 0xc1, 0x92, 0x0b, 0xf3, 0x7b, 0x0d,
	0x56, 0x63, 0x92, 0xf7, 0xed, 0x60, 0xf4, 0x6f, 0x11, 0xdd, 0x80, 0x6c, 0x1f, 0x8f, 0x98, 0xa1,
	0xf3, 0x0b, 0x39, 0x61, 0x2a, 0x84, 0xc7, 0x50, 0xbd, 0x09, 0x95, 0x49, 0x38, 0xd5, 0xdd, 0xd8,
	0x80, 0x2c, 0x25, 0xcf, 0x64, 0x16, 0xd3, 0x30, 0x5c, 0xc8, 0xeb, 0x75, 0xdf, 0x8b, 0x98, 0x20,
	0x92, 0xb3, 0xc4, 0xb7, 0xe9, 0xcb, 0x9c, 0xec, 0x7a, 0xcf, 0xf1, 0xdf, 0x70, 0xf5, 0x12, 0xa8,
	0x55, 0xd7, 0x21, 0xbe, 0x6a, 0x7e, 0xc2, 0x38, 0xf7, 0xb3, 0x28, 0xb7, 0x6e, 0x12, 0xdf, 0xbc,
	0x22, 0x29, 0x4b, 0x6b, 0x8a, 0xf2, 0x39, 0x80, 0x88, 0x44, 0xb6, 0xdf, 0x65, 0xde, 0x73, 0x69,
	0x4d, 0xb7, 0x8a, 0x42, 0xc2, 0xd5, 0xcc, 0x1f, 0x74, 0x58, 0x99, 0xa9, 0x3d, 0x74, 0x19, 0xf4,
	0xe8, 0x20, 0x2e, 0xd5, 0x13, 0xee, 0x07, 0xd7, 0x42, 0x17, 0x20, 0x2b, 0xfc, 0xc8, 0x1c, 0xe3,
	0x87, 0xd8, 0x45, 0x97, 0x52, 0x77, 0x79, 0xa9, 0x83, 0x0e, 0xc7, 0xf5, 0xe5, 0x7b, 0xc4, 0xb1,
	0x7d, 0xa1, 0x25, 0x3a, 0x82, 0xec, 0xb3, 0x17, 0x60, 0xb9, 0x8f, 0x47, 0x5d, 0x8f, 0x75, 0x43,
	0xea, 0x0d, 0x6c, 0x3a, 0x52, 0x39, 0x29, 0xf7, 0xf1, 0x68, 0x9b, 0xed, 0x48, 0x59, 0x5c, 0x76,
	0xb9, 0x86, 0x9e, 0x0e, 0x84, 0x28, 0xbb, 0xcf, 0x61, 0xd1, 0xa5, 0x24, 0x0c, 0xb1, 0x6b, 0xe4,
	0x05, 0xff, 0x8b, 0x09, 0xff, 0x19, 0x37, 0x5b, 0x5b, 0x52, 0xef, 0x56, 0x10, 0xd1, 0x51, 0xa7,
	0xf2, 0xe2, 0xb5, 0x40, 0xf9, 0xfa, 0x75, 0x3d, 0xf7, 0xd8, 0xf6, 0x87, 0xd8, 0x8a, 0x71, 0x44,
	0x04, 0xf9, 0xd1, 0x6e, 0x60, 0x0f, 0xb0, 0xb1, 0x28, 0xba, 0x51, 0x51, 0x48, 0x1e, 0xd8, 0x03,
	0x8c, 0x0c, 0x58, 0x74, 0x88, 0x3f, 0x1c, 0x04, 0xcc, 0x28, 0x88, 0x76, 0x1f, 0x2f, 0x51, 0x13,
	0xf2, 0xcc, 0xd9, 0xc7, 0x03, 0xdb, 0x28, 0x0a, 0x2a, 0xd0, 0x12, 0x8f, 0xe4, 0xc3, 0x51, 0x88,
	0x3b, 0xd9, 0x97, 0xe3, 0xfa, 0x82, 0xa5, 0xf6, 0xab, 0xd7, 0xa0, 0x9c, 0x66, 0x83, 0x2a, 0xd2,
	0x41, 0x99, 0xad, 0xf8, 0x3a, 0x3d, 0xe5, 0xb4, 0x54, 0xdb, 0x95, 0x8b, 0x6b, 0x99, 0xab, 0x9a,
	0xf9, 0x73, 0x06, 0x4e, 0x1f, 0xd3, 0x45, 0x90, 0x99, 0xce, 0x64, 0x45, 0x9a, 0x97, 0x69, 0xe4,
	0x6f, 0xd5, 0x7f, 0x32, 0x81, 0xff, 0x7c, 0xb4, 0x51, 0x15, 0x0a, 0xfc, 0xde, 0x87, 0xb6, 0x83,
	0x0d, 0x10, 0x06, 0x92, 0xb5, 0xf9, 0x53, 0x06, 0x96, 0xa6, 0xde, 0x4b, 0x74, 0x11, 0x72, 0x1e,
	0x77, 0xf0, 0xb8, 0xa7, 0x4c, 0xee, 0xbe, 0xf3, 0x35, 0xfb, 0x3f, 0x40, 0x30, 0x1c, 0xc8, 0x5e,
	0xc5, 0x44, 0x18, 0xd3, 0x4a, 0xc5, 0x60, 0x38, 0x10, 0x9d, 0x8a, 0xa1, 0xbb, 0x90, 0xe3, 0xc4,
	0xe5, 0xf0, 0x50, 0x6a, 0x9f, 0x9f, 0xff, 0x8c, 0xb7, 0x78, 0xe0, 0x99, 0xac, 0x5d, 0xf4, 0xe2,
	0xf5, 0x91, 0x6c, 0x48, 0x0c, 0xf4, 0x21, 0xe4, 0x1d, 0x12, 0x3c, 0xf1, 0x7a, 0x46, 0x4e, 0xbc,
	0x76, 0x46, 0x2b, 0x35, 0x9b, 0x49, 0xc0, 0x9b, 0x62, 0xdf, 0x52, 0x7a, 0xd5, 0x2d, 0x80, 0x09,
	0x74, 0xba, 0x10, 0x97, 0x64, 0x7e, 0x1a, 0xe9, 0x42, 0x4c, 0xa2, 0xcc, 0x8f, 0xa4, 0x8b, 0x72,
	0x0d, 0xd0, 0x7d, 0x3c, 0x20, 0x74, 0xb4, 0x1b, 0xd9, 0x11, 0x53, 0xad, 0xcf, 0xfc, 0x55, 0x83,
	0xd5, 0x29, 0xb1, 0xea, 0x51, 0x5b, 0x20, 0xc6, 0xc7, 0xee, 0x90, 0xd9, 0x3d, 0xac, 0xaa, 0x75,
	0x72, 0x6f, 0xe7, 0x9c, 0xe0, 0xb2, 0x47, 0x5c, 0xd9, 0x2a, 0xf2, 0x83, 0xe2, 0xb3, 0x7a, 0x00,
	0x85, 0x58, 0x9c, 0x1a, 0x86, 0xe4, 0x48, 0x70, 0xa4, 0xf6, 0xe3, 0x92, 0x90, 0x5a, 0x7f, 0xf1,
	0x12, 0xac, 0x43, 0x7e, 0x20, 0xc8, 0x88, 0xfc, 0xe9, 0x96, 0x5a, 0xb5, 0x7f, 0xcc, 0xc0, 0x92,
	0x1a, 0x35, 0x24, 0x67, 0x74, 0x17, 0xca, 0xe9, 0xe1, 0x0a, 0x9d, 0x4d, 0xbc, 0x99, 0x33, 0xe5,
	0x55, 0xcf, 0x1d, 0xb3, 0xab, 0xc2, 0x93, 0x80, 0xc9, 0x19, 0xe0, 0x08, 0xd8, 0xd4, 0xac, 0x71,
	0x04, 0x6c, 0x7a, 0x70, 0xe0, 0x60, 0xe9, 0x61, 0x26, 0x05, 0x36, 0x67, 0xb0, 0x4a, 0x81, 0xcd,
	0x9b, 0x80, 0xd0, 0x1d, 0x28, 0xa5, 0xb2, 0x83, 0x36, 0xe6, 0xe7, 0x4c, 0x42, 0x9d, 0x3d, 0x29,
	0xa1, 0xed, 0x17, 0x1a, 0x94, 0xb6, 0x83, 0x00, 0x53, 0x15, 0xb0, 0x8f, 0xa1, 0xbc, 0x43, 0x89,
	0x83, 0x19, 0xbb, 0xc1, 0x46, 0x81, 0x83, 0x96, 0x5b, 0xea, 0xef, 0x86, 0x9c, 0x7a, 0xaa, 0xa7,
	0x13, 0xb4, 0xe9, 0x31, 0x08, 0x5d, 0x83, 0x92, 0x3a, 0xb8, 0xcb, 0xcf, 0xa1, 0xf8, 0x1c, 0x5f,
	0xbd, 0xe3, 0x6c, 0xfb, 0x17, 0x0d, 0xf2, 0xfc, 0xbd, 0xc7, 0x14, 0x5d, 0x87, 0x42, 0xfc, 0xfa,
	0x23, 0x23, 0xd1, 0x9f, 0x99, 0xaf, 0xaa, 0x67, 0xe6, 0xec, 0x28, 0x1e, 0xb7, 0xa1, 0x9c, 0x1e,
	0x74, 0x52, 0x71, 0x9e, 0x33, 0xff, 0x9c, 0x04, 0xa4, 0x98, 0xf0, 0xd7, 0x7a, 0x86, 0x49, 0x6a,
	0xaa, 0x98, 0x01, 0x48, 0x4f, 0x00, 0x9d, 0xeb, 0x2f, 0xff, 0xa8, 0x2d, 0xbc, 0x7c, 0x53, 0xd3,
	0x5e, 0xbd, 0xa9, 0x69, 0xbf, 0xbf, 0xa9, 0x69, 0xdf, 0xbc, 0xad, 0x2d, 0xbc, 0x7a, 0x5b, 0x5b,
	0xf8, 0xed, 0x6d, 0x6d, 0xe1, 0xcb, 0xf3, 0x4f, 0xbd, 0x08, 0x33, 0xd6, 0xf2, 0xc8, 0xa6, 0xfc,
	0xda, 0xec, 0x91, 0xcd, 0x3d, 0x42, 0x58, 0x24, 0x7f, 0xc3, 0xbd, 0xbd, 0xbc, 0xf8, 0xbb, 0xf6,
	0xd1, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xd5, 0x88, 0x9b, 0xd1, 0x0a, 0x0e, 0x00, 0x00,
}

func (m *WorkerSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Epoch != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SourceUuid) > 0 {
		i -= len(m.SourceUuid)
		copy(dAtA[i:], m.SourceUuid)
		i = encodeVarintService(dAtA, i, uint64(len(m.SourceUuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogFiles) > 0 {
		for iNdEx := len(m.LogFiles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LogFiles[iNdEx])
			copy(dAtA[i:], m.LogFiles[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.LogFiles[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ReadListenAddr) > 0 {
		i -= len(m.ReadListenAddr)
		copy(dAtA[i:], m.ReadListenAddr)
		i = encodeVarintService(dAtA, i, uint64(len(m.ReadListenAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintService(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterWorkerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterWorkerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterWorkerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AssignDomainRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignDomainRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignDomainRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AssignDomainResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignDomainResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignDomainResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintService(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x12
	}
	if m.Shard != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Shard))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintService(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Shard != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Shard))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainBootedRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainBootedRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainBootedRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DomainBootedResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainBootedResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainBootedResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *HeartbeatPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AssignStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for iNdEx := len(m.Tables) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Tables[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AssignStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AssignStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AssignStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *PacketResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PacketResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PacketResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ViewReadRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewReadRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewReadRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintService(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TargetShard != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetShard))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetNode != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetNode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewReadManyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewReadManyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewReadManyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Block {
		i--
		if m.Block {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.TargetShard != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetShard))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetNode != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetNode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewReadResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewReadResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewReadResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Hits != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Hits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Rows[iNdEx])
			copy(dAtA[i:], m.Rows[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.Rows[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ViewSizeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewSizeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewSizeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TargetCol != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetCol))
		i--
		dAtA[i] = 0x10
	}
	if m.TargetNode != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TargetNode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewSizeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewSizeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewSizeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalSize != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.TotalSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintService(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Dropped) > 0 {
		for k := range m.Dropped {
			v := m.Dropped[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintService(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintService(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Key) > 0 {
		dAtA7 := make([]byte, len(m.Key)*10)
		var j6 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintService(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x2a
	}
	if m.KeyIsPrimary {
		i--
		if m.KeyIsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Addr != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x18
	}
	if m.Node != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Txs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExternalTableDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalTableDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalTableDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintService(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintService(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintService(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Key) > 0 {
		dAtA9 := make([]byte, len(m.Key)*10)
		var j8 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintService(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x2a
	}
	if m.KeyIsPrimary {
		i--
		if m.KeyIsPrimary {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Addr != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Addr))
		i--
		dAtA[i] = 0x18
	}
	if m.Node != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Txs) > 0 {
		for iNdEx := len(m.Txs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Txs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DomainBuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainBuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainBuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nodes) > 0 {
		for k := range m.Nodes {
			v := m.Nodes[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintService(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintService(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintService(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumShards != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.NumShards))
		i--
		dAtA[i] = 0x18
	}
	if m.Shard != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Shard))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemoryStatsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStatsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryStatsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MemoryStatsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStatsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryStatsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeUsage) > 0 {
		for iNdEx := len(m.NodeUsage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeUsage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemoryStatsResponse_MemUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemoryStatsResponse_MemUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemoryStatsResponse_MemUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Memory != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Memory))
		i--
		dAtA[i] = 0x18
	}
	if m.Node != 0 {
		i = encodeVarintService(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintService(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintService(dAtA []byte, offset int, v uint64) int {
	offset -= sovService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *WorkerSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SourceUuid)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovService(uint64(m.Epoch))
	}
	return n
}

func (m *RegisterWorkerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	l = len(m.ReadListenAddr)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if len(m.LogFiles) > 0 {
		for _, s := range m.LogFiles {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *RegisterWorkerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AssignDomainRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovService(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *AssignDomainResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != 0 {
		n += 1 + sovService(uint64(m.Shard))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *DomainDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovService(uint64(m.Id))
	}
	if m.Shard != 0 {
		n += 1 + sovService(uint64(m.Shard))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *DomainBootedRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovService(uint64(l))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *DomainBootedResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *HeartbeatPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AssignStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Tables) > 0 {
		for _, e := range m.Tables {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *AssignStreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *PacketResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ViewReadRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetNode != 0 {
		n += 1 + sovService(uint64(m.TargetNode))
	}
	if m.TargetShard != 0 {
		n += 1 + sovService(uint64(m.TargetShard))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if m.Block {
		n += 2
	}
	return n
}

func (m *ViewReadManyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetNode != 0 {
		n += 1 + sovService(uint64(m.TargetNode))
	}
	if m.TargetShard != 0 {
		n += 1 + sovService(uint64(m.TargetShard))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	if m.Block {
		n += 2
	}
	return n
}

func (m *ViewReadResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, s := range m.Rows {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	if m.Hits != 0 {
		n += 1 + sovService(uint64(m.Hits))
	}
	return n
}

func (m *ViewSizeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetNode != 0 {
		n += 1 + sovService(uint64(m.TargetNode))
	}
	if m.TargetCol != 0 {
		n += 1 + sovService(uint64(m.TargetCol))
	}
	return n
}

func (m *ViewSizeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalSize != 0 {
		n += 1 + sovService(uint64(m.TotalSize))
	}
	return n
}

func (m *TableDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if m.Node != 0 {
		n += 1 + sovService(uint64(m.Node))
	}
	if m.Addr != 0 {
		n += 1 + sovService(uint64(m.Addr))
	}
	if m.KeyIsPrimary {
		n += 2
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	if len(m.Dropped) > 0 {
		for k, v := range m.Dropped {
			_ = k
			_ = v
			mapEntrySize := 1 + sovService(uint64(k)) + 1 + len(v) + sovService(uint64(len(v)))
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *ExternalTableDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Txs) > 0 {
		for _, e := range m.Txs {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	if m.Node != 0 {
		n += 1 + sovService(uint64(m.Node))
	}
	if m.Addr != 0 {
		n += 1 + sovService(uint64(m.Addr))
	}
	if m.KeyIsPrimary {
		n += 2
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovService(uint64(e))
		}
		n += 1 + sovService(uint64(l)) + l
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovService(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *DomainBuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovService(uint64(m.Index))
	}
	if m.Shard != 0 {
		n += 1 + sovService(uint64(m.Shard))
	}
	if m.NumShards != 0 {
		n += 1 + sovService(uint64(m.NumShards))
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovService(uint64(l))
			}
			mapEntrySize := 1 + sovService(uint64(k)) + l
			n += mapEntrySize + 1 + sovService(uint64(mapEntrySize))
		}
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovService(uint64(l))
	}
	return n
}

func (m *MemoryStatsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MemoryStatsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeUsage) > 0 {
		for _, e := range m.NodeUsage {
			l = e.Size()
			n += 1 + l + sovService(uint64(l))
		}
	}
	return n
}

func (m *MemoryStatsResponse_MemUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Domain.Size()
	n += 1 + l + sovService(uint64(l))
	if m.Node != 0 {
		n += 1 + sovService(uint64(m.Node))
	}
	if m.Memory != 0 {
		n += 1 + sovService(uint64(m.Memory))
	}
	return n
}

func sovService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozService(x uint64) (n int) {
	return sovService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *WorkerSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceUuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceUuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= Epoch(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &WorkerSource{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadListenAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadListenAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogFiles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogFiles = append(m.LogFiles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterWorkerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterWorkerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterWorkerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignDomainRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignDomainRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignDomainRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &WorkerSource{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainBuilder{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignDomainResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignDomainResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignDomainResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainBootedRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainBootedRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainBootedRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &WorkerSource{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainDescriptor{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainBootedResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainBootedResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainBootedResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tables = append(m.Tables, &ExternalTableDescriptor{})
			if err := m.Tables[len(m.Tables)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AssignStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AssignStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AssignStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PacketResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PacketResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PacketResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewReadRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNode", wireType)
			}
			m.TargetNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNode |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetShard", wireType)
			}
			m.TargetShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = Row(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewReadManyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReadManyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReadManyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNode", wireType)
			}
			m.TargetNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNode |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetShard", wireType)
			}
			m.TargetShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Block = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewReadResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewReadResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewReadResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hits", wireType)
			}
			m.Hits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hits |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewSizeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewSizeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewSizeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNode", wireType)
			}
			m.TargetNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetNode |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCol", wireType)
			}
			m.TargetCol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCol |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewSizeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewSizeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewSizeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSize", wireType)
			}
			m.TotalSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &DomainDescriptor{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyIsPrimary = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropped", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dropped == nil {
				m.Dropped = make(map[int]Value)
			}
			var mapkey int64
			var mapvalue Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthService
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthService
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = Value(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Dropped[int(mapkey)] = ((Value)(mapvalue))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalTableDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalTableDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalTableDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txs = append(m.Txs, &DomainAddr{})
			if err := m.Txs[len(m.Txs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			m.Addr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Addr |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIsPrimary", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeyIsPrimary = bool(v != 0)
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainBuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainBuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainBuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumShards", wireType)
			}
			m.NumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumShards |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Nodes == nil {
				m.Nodes = make(map[LocalNodeIndex]*Node)
			}
			var mapkey uint32
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthService
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthService
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipService(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthService
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Nodes[LocalNodeIndex(mapkey)] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &DomainConfig{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStatsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStatsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStatsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStatsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemoryStatsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemoryStatsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeUsage = append(m.NodeUsage, &MemoryStatsResponse_MemUsage{})
			if err := m.NodeUsage[len(m.NodeUsage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemoryStatsResponse_MemUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			m.Memory = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Memory |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupService = fmt.Errorf("proto: unexpected end of group")
)
