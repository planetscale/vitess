// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: node.proto

package boostpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	vitess_io_vitess_go_mysql_collations "vitess.io/vitess/go/mysql/collations"
	vitess_io_vitess_go_sqltypes "vitess.io/vitess/go/sqltypes"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Sharding_Mode int32

const (
	Sharding_None       Sharding_Mode = 0
	Sharding_ForcedNone Sharding_Mode = 1
	Sharding_Random     Sharding_Mode = 2
	Sharding_ByColumn   Sharding_Mode = 3
)

var Sharding_Mode_name = map[int32]string{
	0: "None",
	1: "ForcedNone",
	2: "Random",
	3: "ByColumn",
}

var Sharding_Mode_value = map[string]int32{
	"None":       0,
	"ForcedNone": 1,
	"Random":     2,
	"ByColumn":   3,
}

func (x Sharding_Mode) String() string {
	return proto.EnumName(Sharding_Mode_name, int32(x))
}

func (Sharding_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{3, 0}
}

type Node_InternalJoin_JoinType int32

const (
	Node_InternalJoin_Left  Node_InternalJoin_JoinType = 0
	Node_InternalJoin_Inner Node_InternalJoin_JoinType = 1
)

var Node_InternalJoin_JoinType_name = map[int32]string{
	0: "Left",
	1: "Inner",
}

var Node_InternalJoin_JoinType_value = map[string]int32{
	"Left":  0,
	"Inner": 1,
}

func (x Node_InternalJoin_JoinType) String() string {
	return proto.EnumName(Node_InternalJoin_JoinType_name, int32(x))
}

func (Node_InternalJoin_JoinType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 6, 0}
}

type Node_InternalGrouped_Aggregation_Kind int32

const (
	Node_InternalGrouped_Aggregation_Count     Node_InternalGrouped_Aggregation_Kind = 0
	Node_InternalGrouped_Aggregation_CountStar Node_InternalGrouped_Aggregation_Kind = 1
	Node_InternalGrouped_Aggregation_Sum       Node_InternalGrouped_Aggregation_Kind = 2
	Node_InternalGrouped_Aggregation_Min       Node_InternalGrouped_Aggregation_Kind = 3
	Node_InternalGrouped_Aggregation_Max       Node_InternalGrouped_Aggregation_Kind = 4
)

var Node_InternalGrouped_Aggregation_Kind_name = map[int32]string{
	0: "Count",
	1: "CountStar",
	2: "Sum",
	3: "Min",
	4: "Max",
}

var Node_InternalGrouped_Aggregation_Kind_value = map[string]int32{
	"Count":     0,
	"CountStar": 1,
	"Sum":       2,
	"Min":       3,
	"Max":       4,
}

func (x Node_InternalGrouped_Aggregation_Kind) String() string {
	return proto.EnumName(Node_InternalGrouped_Aggregation_Kind_name, int32(x))
}

func (Node_InternalGrouped_Aggregation_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 7, 0, 0}
}

type Type struct {
	T         vitess_io_vitess_go_sqltypes.Type       `protobuf:"varint,1,opt,name=t,proto3,casttype=vitess.io/vitess/go/sqltypes.Type" json:"t,omitempty"`
	Collation vitess_io_vitess_go_mysql_collations.ID `protobuf:"varint,2,opt,name=collation,proto3,casttype=vitess.io/vitess/go/mysql/collations.ID" json:"collation,omitempty"`
	Nullable  bool                                    `protobuf:"varint,3,opt,name=nullable,proto3" json:"nullable,omitempty"`
	Default   Value                                   `protobuf:"bytes,4,opt,name=default,proto3,casttype=Value" json:"default,omitempty"`
}

func (m *Type) Reset()         { *m = Type{} }
func (m *Type) String() string { return proto.CompactTextString(m) }
func (*Type) ProtoMessage()    {}
func (*Type) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{0}
}
func (m *Type) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Type) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Type.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Type) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Type.Merge(m, src)
}
func (m *Type) XXX_Size() int {
	return m.Size()
}
func (m *Type) XXX_DiscardUnknown() {
	xxx_messageInfo_Type.DiscardUnknown(m)
}

var xxx_messageInfo_Type proto.InternalMessageInfo

type IndexPair struct {
	Global GraphNodeIdx   `protobuf:"varint,1,opt,name=global,proto3,casttype=GraphNodeIdx" json:"global,omitempty"`
	Local  LocalNodeIndex `protobuf:"varint,2,opt,name=local,proto3,casttype=LocalNodeIndex" json:"local,omitempty"`
}

func (m *IndexPair) Reset()         { *m = IndexPair{} }
func (m *IndexPair) String() string { return proto.CompactTextString(m) }
func (*IndexPair) ProtoMessage()    {}
func (*IndexPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{1}
}
func (m *IndexPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexPair.Merge(m, src)
}
func (m *IndexPair) XXX_Size() int {
	return m.Size()
}
func (m *IndexPair) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexPair.DiscardUnknown(m)
}

var xxx_messageInfo_IndexPair proto.InternalMessageInfo

type DomainAddr struct {
	Domain DomainIndex `protobuf:"varint,1,opt,name=domain,proto3,casttype=DomainIndex" json:"domain,omitempty"`
	Shard  uint        `protobuf:"varint,2,opt,name=shard,proto3,casttype=uint" json:"shard,omitempty"`
}

func (m *DomainAddr) Reset()         { *m = DomainAddr{} }
func (m *DomainAddr) String() string { return proto.CompactTextString(m) }
func (*DomainAddr) ProtoMessage()    {}
func (*DomainAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{2}
}
func (m *DomainAddr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DomainAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DomainAddr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DomainAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DomainAddr.Merge(m, src)
}
func (m *DomainAddr) XXX_Size() int {
	return m.Size()
}
func (m *DomainAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_DomainAddr.DiscardUnknown(m)
}

var xxx_messageInfo_DomainAddr proto.InternalMessageInfo

type Sharding struct {
	Mode   Sharding_Mode `protobuf:"varint,1,opt,name=mode,proto3,enum=node.Sharding_Mode" json:"mode,omitempty"`
	Col    int           `protobuf:"varint,2,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	Shards uint          `protobuf:"varint,3,opt,name=shards,proto3,casttype=uint" json:"shards,omitempty"`
}

func (m *Sharding) Reset()         { *m = Sharding{} }
func (m *Sharding) String() string { return proto.CompactTextString(m) }
func (*Sharding) ProtoMessage()    {}
func (*Sharding) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{3}
}
func (m *Sharding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sharding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sharding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sharding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sharding.Merge(m, src)
}
func (m *Sharding) XXX_Size() int {
	return m.Size()
}
func (m *Sharding) XXX_DiscardUnknown() {
	xxx_messageInfo_Sharding.DiscardUnknown(m)
}

var xxx_messageInfo_Sharding proto.InternalMessageInfo

type ViewParameter struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Multi bool   `protobuf:"varint,2,opt,name=multi,proto3" json:"multi,omitempty"`
}

func (m *ViewParameter) Reset()         { *m = ViewParameter{} }
func (m *ViewParameter) String() string { return proto.CompactTextString(m) }
func (*ViewParameter) ProtoMessage()    {}
func (*ViewParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{4}
}
func (m *ViewParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewParameter.Merge(m, src)
}
func (m *ViewParameter) XXX_Size() int {
	return m.Size()
}
func (m *ViewParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ViewParameter proto.InternalMessageInfo

type OrderedColumn struct {
	Col  int  `protobuf:"varint,1,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	Desc bool `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *OrderedColumn) Reset()         { *m = OrderedColumn{} }
func (m *OrderedColumn) String() string { return proto.CompactTextString(m) }
func (*OrderedColumn) ProtoMessage()    {}
func (*OrderedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{5}
}
func (m *OrderedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderedColumn.Merge(m, src)
}
func (m *OrderedColumn) XXX_Size() int {
	return m.Size()
}
func (m *OrderedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_OrderedColumn proto.InternalMessageInfo

type Node struct {
	Name     string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index    *IndexPair       `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	Domain   DomainIndex      `protobuf:"varint,3,opt,name=domain,proto3,casttype=DomainIndex" json:"domain,omitempty"`
	Fields   []string         `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
	Schema   []Type           `protobuf:"bytes,5,rep,name=schema,proto3" json:"schema"`
	Parents  []LocalNodeIndex `protobuf:"varint,6,rep,packed,name=parents,proto3,casttype=LocalNodeIndex" json:"parents,omitempty"`
	Children []LocalNodeIndex `protobuf:"varint,7,rep,packed,name=children,proto3,casttype=LocalNodeIndex" json:"children,omitempty"`
	Taken    bool             `protobuf:"varint,8,opt,name=taken,proto3" json:"taken,omitempty"`
	Purge    bool             `protobuf:"varint,9,opt,name=purge,proto3" json:"purge,omitempty"`
	Sharding *Sharding        `protobuf:"bytes,10,opt,name=sharding,proto3" json:"sharding,omitempty"`
	// Types that are valid to be assigned to Impl:
	//	*Node_Base_
	//	*Node_Ingress_
	//	*Node_Egress_
	//	*Node_Reader_
	//	*Node_Sharder_
	//	*Node_ExternalBase_
	//	*Node_Union
	//	*Node_Join
	//	*Node_Grouped
	//	*Node_Project
	//	*Node_Filter
	//	*Node_TopK
	//	*Node_Distinct
	Impl isNode_Impl `protobuf_oneof:"impl"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_Impl interface {
	isNode_Impl()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_Base_ struct {
	Base *Node_Base `protobuf:"bytes,20,opt,name=base,proto3,oneof" json:"base,omitempty"`
}
type Node_Ingress_ struct {
	Ingress *Node_Ingress `protobuf:"bytes,21,opt,name=ingress,proto3,oneof" json:"ingress,omitempty"`
}
type Node_Egress_ struct {
	Egress *Node_Egress `protobuf:"bytes,22,opt,name=egress,proto3,oneof" json:"egress,omitempty"`
}
type Node_Reader_ struct {
	Reader *Node_Reader `protobuf:"bytes,23,opt,name=reader,proto3,oneof" json:"reader,omitempty"`
}
type Node_Sharder_ struct {
	Sharder *Node_Sharder `protobuf:"bytes,24,opt,name=sharder,proto3,oneof" json:"sharder,omitempty"`
}
type Node_ExternalBase_ struct {
	ExternalBase *Node_ExternalBase `protobuf:"bytes,25,opt,name=external_base,json=externalBase,proto3,oneof" json:"external_base,omitempty"`
}
type Node_Union struct {
	Union *Node_InternalUnion `protobuf:"bytes,40,opt,name=union,proto3,oneof" json:"union,omitempty"`
}
type Node_Join struct {
	Join *Node_InternalJoin `protobuf:"bytes,41,opt,name=join,proto3,oneof" json:"join,omitempty"`
}
type Node_Grouped struct {
	Grouped *Node_InternalGrouped `protobuf:"bytes,42,opt,name=grouped,proto3,oneof" json:"grouped,omitempty"`
}
type Node_Project struct {
	Project *Node_InternalProject `protobuf:"bytes,43,opt,name=project,proto3,oneof" json:"project,omitempty"`
}
type Node_Filter struct {
	Filter *Node_InternalFilter `protobuf:"bytes,44,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}
type Node_TopK struct {
	TopK *Node_InternalTopK `protobuf:"bytes,45,opt,name=top_k,json=topK,proto3,oneof" json:"top_k,omitempty"`
}
type Node_Distinct struct {
	Distinct *Node_InternalDistinct `protobuf:"bytes,46,opt,name=distinct,proto3,oneof" json:"distinct,omitempty"`
}

func (*Node_Base_) isNode_Impl()         {}
func (*Node_Ingress_) isNode_Impl()      {}
func (*Node_Egress_) isNode_Impl()       {}
func (*Node_Reader_) isNode_Impl()       {}
func (*Node_Sharder_) isNode_Impl()      {}
func (*Node_ExternalBase_) isNode_Impl() {}
func (*Node_Union) isNode_Impl()         {}
func (*Node_Join) isNode_Impl()          {}
func (*Node_Grouped) isNode_Impl()       {}
func (*Node_Project) isNode_Impl()       {}
func (*Node_Filter) isNode_Impl()        {}
func (*Node_TopK) isNode_Impl()          {}
func (*Node_Distinct) isNode_Impl()      {}

func (m *Node) GetImpl() isNode_Impl {
	if m != nil {
		return m.Impl
	}
	return nil
}

func (m *Node) GetBase() *Node_Base {
	if x, ok := m.GetImpl().(*Node_Base_); ok {
		return x.Base
	}
	return nil
}

func (m *Node) GetIngress() *Node_Ingress {
	if x, ok := m.GetImpl().(*Node_Ingress_); ok {
		return x.Ingress
	}
	return nil
}

func (m *Node) GetEgress() *Node_Egress {
	if x, ok := m.GetImpl().(*Node_Egress_); ok {
		return x.Egress
	}
	return nil
}

func (m *Node) GetReader() *Node_Reader {
	if x, ok := m.GetImpl().(*Node_Reader_); ok {
		return x.Reader
	}
	return nil
}

func (m *Node) GetSharder() *Node_Sharder {
	if x, ok := m.GetImpl().(*Node_Sharder_); ok {
		return x.Sharder
	}
	return nil
}

func (m *Node) GetExternalBase() *Node_ExternalBase {
	if x, ok := m.GetImpl().(*Node_ExternalBase_); ok {
		return x.ExternalBase
	}
	return nil
}

func (m *Node) GetUnion() *Node_InternalUnion {
	if x, ok := m.GetImpl().(*Node_Union); ok {
		return x.Union
	}
	return nil
}

func (m *Node) GetJoin() *Node_InternalJoin {
	if x, ok := m.GetImpl().(*Node_Join); ok {
		return x.Join
	}
	return nil
}

func (m *Node) GetGrouped() *Node_InternalGrouped {
	if x, ok := m.GetImpl().(*Node_Grouped); ok {
		return x.Grouped
	}
	return nil
}

func (m *Node) GetProject() *Node_InternalProject {
	if x, ok := m.GetImpl().(*Node_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Node) GetFilter() *Node_InternalFilter {
	if x, ok := m.GetImpl().(*Node_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *Node) GetTopK() *Node_InternalTopK {
	if x, ok := m.GetImpl().(*Node_TopK); ok {
		return x.TopK
	}
	return nil
}

func (m *Node) GetDistinct() *Node_InternalDistinct {
	if x, ok := m.GetImpl().(*Node_Distinct); ok {
		return x.Distinct
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_Base_)(nil),
		(*Node_Ingress_)(nil),
		(*Node_Egress_)(nil),
		(*Node_Reader_)(nil),
		(*Node_Sharder_)(nil),
		(*Node_ExternalBase_)(nil),
		(*Node_Union)(nil),
		(*Node_Join)(nil),
		(*Node_Grouped)(nil),
		(*Node_Project)(nil),
		(*Node_Filter)(nil),
		(*Node_TopK)(nil),
		(*Node_Distinct)(nil),
	}
}

type Node_Base struct {
	PrimaryKey []int  `protobuf:"varint,1,rep,packed,name=primary_key,json=primaryKey,proto3,casttype=int" json:"primary_key,omitempty"`
	Dropped    []int  `protobuf:"varint,2,rep,packed,name=dropped,proto3,casttype=int" json:"dropped,omitempty"`
	Unmodified bool   `protobuf:"varint,4,opt,name=unmodified,proto3" json:"unmodified,omitempty"`
	Schema     []Type `protobuf:"bytes,5,rep,name=schema,proto3" json:"schema"`
}

func (m *Node_Base) Reset()         { *m = Node_Base{} }
func (m *Node_Base) String() string { return proto.CompactTextString(m) }
func (*Node_Base) ProtoMessage()    {}
func (*Node_Base) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 0}
}
func (m *Node_Base) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Base) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Base.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Base) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Base.Merge(m, src)
}
func (m *Node_Base) XXX_Size() int {
	return m.Size()
}
func (m *Node_Base) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Base.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Base proto.InternalMessageInfo

type Node_ExternalBase struct {
	PrimaryKey []int  `protobuf:"varint,1,rep,packed,name=primary_key,json=primaryKey,proto3,casttype=int" json:"primary_key,omitempty"`
	Keyspace   string `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	Schema     []Type `protobuf:"bytes,3,rep,name=schema,proto3" json:"schema"`
}

func (m *Node_ExternalBase) Reset()         { *m = Node_ExternalBase{} }
func (m *Node_ExternalBase) String() string { return proto.CompactTextString(m) }
func (*Node_ExternalBase) ProtoMessage()    {}
func (*Node_ExternalBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 1}
}
func (m *Node_ExternalBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_ExternalBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_ExternalBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_ExternalBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_ExternalBase.Merge(m, src)
}
func (m *Node_ExternalBase) XXX_Size() int {
	return m.Size()
}
func (m *Node_ExternalBase) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_ExternalBase.DiscardUnknown(m)
}

var xxx_messageInfo_Node_ExternalBase proto.InternalMessageInfo

type Node_Ingress struct {
}

func (m *Node_Ingress) Reset()         { *m = Node_Ingress{} }
func (m *Node_Ingress) String() string { return proto.CompactTextString(m) }
func (*Node_Ingress) ProtoMessage()    {}
func (*Node_Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 2}
}
func (m *Node_Ingress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Ingress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Ingress.Merge(m, src)
}
func (m *Node_Ingress) XXX_Size() int {
	return m.Size()
}
func (m *Node_Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Ingress proto.InternalMessageInfo

type Node_Egress struct {
}

func (m *Node_Egress) Reset()         { *m = Node_Egress{} }
func (m *Node_Egress) String() string { return proto.CompactTextString(m) }
func (*Node_Egress) ProtoMessage()    {}
func (*Node_Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 3}
}
func (m *Node_Egress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Egress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Egress.Merge(m, src)
}
func (m *Node_Egress) XXX_Size() int {
	return m.Size()
}
func (m *Node_Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Egress proto.InternalMessageInfo

type Node_Reader struct {
	ForNode        GraphNodeIdx    `protobuf:"varint,1,opt,name=for_node,json=forNode,proto3,casttype=GraphNodeIdx" json:"for_node,omitempty"`
	State          []int           `protobuf:"varint,2,rep,packed,name=state,proto3,casttype=int" json:"state,omitempty"`
	Parameters     []ViewParameter `protobuf:"bytes,3,rep,name=parameters,proto3" json:"parameters"`
	TopkOrder      []OrderedColumn `protobuf:"bytes,5,rep,name=topk_order,json=topkOrder,proto3" json:"topk_order"`
	TopkLimit      int             `protobuf:"varint,6,opt,name=topk_limit,json=topkLimit,proto3,casttype=int" json:"topk_limit,omitempty"`
	ColumnsForView int             `protobuf:"varint,7,opt,name=columns_for_view,json=columnsForView,proto3,casttype=int" json:"columns_for_view,omitempty"`
	ColumnsForUser int             `protobuf:"varint,8,opt,name=columns_for_user,json=columnsForUser,proto3,casttype=int" json:"columns_for_user,omitempty"`
}

func (m *Node_Reader) Reset()         { *m = Node_Reader{} }
func (m *Node_Reader) String() string { return proto.CompactTextString(m) }
func (*Node_Reader) ProtoMessage()    {}
func (*Node_Reader) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 4}
}
func (m *Node_Reader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Reader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Reader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Reader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Reader.Merge(m, src)
}
func (m *Node_Reader) XXX_Size() int {
	return m.Size()
}
func (m *Node_Reader) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Reader.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Reader proto.InternalMessageInfo

type Node_InternalUnion struct {
	// Types that are valid to be assigned to Emit:
	//	*Node_InternalUnion_Project
	//	*Node_InternalUnion_All
	Emit     isNode_InternalUnion_Emit `protobuf_oneof:"emit"`
	Required int                       `protobuf:"varint,3,opt,name=required,proto3,casttype=int" json:"required,omitempty"`
	Me       GraphNodeIdx              `protobuf:"varint,4,opt,name=me,proto3,casttype=GraphNodeIdx" json:"me,omitempty"`
}

func (m *Node_InternalUnion) Reset()         { *m = Node_InternalUnion{} }
func (m *Node_InternalUnion) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion) ProtoMessage()    {}
func (*Node_InternalUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5}
}
func (m *Node_InternalUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion.Merge(m, src)
}
func (m *Node_InternalUnion) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion proto.InternalMessageInfo

type isNode_InternalUnion_Emit interface {
	isNode_InternalUnion_Emit()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_InternalUnion_Project struct {
	Project *Node_InternalUnion_EmitProject `protobuf:"bytes,1,opt,name=project,proto3,oneof" json:"project,omitempty"`
}
type Node_InternalUnion_All struct {
	All *Node_InternalUnion_EmitAll `protobuf:"bytes,2,opt,name=all,proto3,oneof" json:"all,omitempty"`
}

func (*Node_InternalUnion_Project) isNode_InternalUnion_Emit() {}
func (*Node_InternalUnion_All) isNode_InternalUnion_Emit()     {}

func (m *Node_InternalUnion) GetEmit() isNode_InternalUnion_Emit {
	if m != nil {
		return m.Emit
	}
	return nil
}

func (m *Node_InternalUnion) GetProject() *Node_InternalUnion_EmitProject {
	if x, ok := m.GetEmit().(*Node_InternalUnion_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Node_InternalUnion) GetAll() *Node_InternalUnion_EmitAll {
	if x, ok := m.GetEmit().(*Node_InternalUnion_All); ok {
		return x.All
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node_InternalUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_InternalUnion_Project)(nil),
		(*Node_InternalUnion_All)(nil),
	}
}

type Node_InternalUnion_EmitProject struct {
	Emit     []*Node_InternalUnion_EmitProject_EmitTuple        `protobuf:"bytes,1,rep,name=emit,proto3" json:"emit,omitempty"`
	EmitLeft []*Node_InternalUnion_EmitProject_EmitLeftTuple    `protobuf:"bytes,2,rep,name=emit_left,json=emitLeft,proto3" json:"emit_left,omitempty"`
	Cols     []*Node_InternalUnion_EmitProject_ColumnsTuple     `protobuf:"bytes,3,rep,name=cols,proto3" json:"cols,omitempty"`
	ColsLeft []*Node_InternalUnion_EmitProject_ColumnsLeftTuple `protobuf:"bytes,4,rep,name=cols_left,json=colsLeft,proto3" json:"cols_left,omitempty"`
}

func (m *Node_InternalUnion_EmitProject) Reset()         { *m = Node_InternalUnion_EmitProject{} }
func (m *Node_InternalUnion_EmitProject) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitProject) ProtoMessage()    {}
func (*Node_InternalUnion_EmitProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 0}
}
func (m *Node_InternalUnion_EmitProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject proto.InternalMessageInfo

type Node_InternalUnion_EmitProject_EmitTuple struct {
	Ip      *IndexPair `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Columns []int      `protobuf:"varint,2,rep,packed,name=columns,proto3,casttype=int" json:"columns,omitempty"`
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Reset() {
	*m = Node_InternalUnion_EmitProject_EmitTuple{}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitProject_EmitTuple) ProtoMessage()    {}
func (*Node_InternalUnion_EmitProject_EmitTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 0, 0}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple proto.InternalMessageInfo

type Node_InternalUnion_EmitProject_EmitLeftTuple struct {
	Index   LocalNodeIndex `protobuf:"varint,1,opt,name=index,proto3,casttype=LocalNodeIndex" json:"index,omitempty"`
	Columns []int          `protobuf:"varint,2,rep,packed,name=columns,proto3,casttype=int" json:"columns,omitempty"`
}

func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) Reset() {
	*m = Node_InternalUnion_EmitProject_EmitLeftTuple{}
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) String() string {
	return proto.CompactTextString(m)
}
func (*Node_InternalUnion_EmitProject_EmitLeftTuple) ProtoMessage() {}
func (*Node_InternalUnion_EmitProject_EmitLeftTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 0, 1}
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject_EmitLeftTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitLeftTuple.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitLeftTuple.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject_EmitLeftTuple proto.InternalMessageInfo

type Node_InternalUnion_EmitProject_ColumnsTuple struct {
	Ip     *IndexPair `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip,omitempty"`
	Column int        `protobuf:"varint,2,opt,name=column,proto3,casttype=int" json:"column,omitempty"`
}

func (m *Node_InternalUnion_EmitProject_ColumnsTuple) Reset() {
	*m = Node_InternalUnion_EmitProject_ColumnsTuple{}
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) String() string {
	return proto.CompactTextString(m)
}
func (*Node_InternalUnion_EmitProject_ColumnsTuple) ProtoMessage() {}
func (*Node_InternalUnion_EmitProject_ColumnsTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 0, 2}
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsTuple.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsTuple.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsTuple proto.InternalMessageInfo

type Node_InternalUnion_EmitProject_ColumnsLeftTuple struct {
	Index  LocalNodeIndex `protobuf:"varint,1,opt,name=index,proto3,casttype=LocalNodeIndex" json:"index,omitempty"`
	Column int            `protobuf:"varint,2,opt,name=column,proto3,casttype=int" json:"column,omitempty"`
}

func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) Reset() {
	*m = Node_InternalUnion_EmitProject_ColumnsLeftTuple{}
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) String() string {
	return proto.CompactTextString(m)
}
func (*Node_InternalUnion_EmitProject_ColumnsLeftTuple) ProtoMessage() {}
func (*Node_InternalUnion_EmitProject_ColumnsLeftTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 0, 3}
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsLeftTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsLeftTuple.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsLeftTuple.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject_ColumnsLeftTuple proto.InternalMessageInfo

type Node_InternalUnion_EmitAll struct {
	From     *IndexPair `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Sharding *Sharding  `protobuf:"bytes,2,opt,name=sharding,proto3" json:"sharding,omitempty"`
}

func (m *Node_InternalUnion_EmitAll) Reset()         { *m = Node_InternalUnion_EmitAll{} }
func (m *Node_InternalUnion_EmitAll) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitAll) ProtoMessage()    {}
func (*Node_InternalUnion_EmitAll) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 5, 1}
}
func (m *Node_InternalUnion_EmitAll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitAll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitAll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitAll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitAll.Merge(m, src)
}
func (m *Node_InternalUnion_EmitAll) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitAll) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitAll.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitAll proto.InternalMessageInfo

type Node_InternalJoin struct {
	Left             *IndexPair                   `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right            *IndexPair                   `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	On0              int                          `protobuf:"varint,3,opt,name=on0,proto3,casttype=int" json:"on0,omitempty"`
	On1              int                          `protobuf:"varint,4,opt,name=on1,proto3,casttype=int" json:"on1,omitempty"`
	Emit             []Node_InternalJoin_Emission `protobuf:"bytes,5,rep,name=emit,proto3" json:"emit"`
	InPlaceLeftEmit  []Node_InternalJoin_Emission `protobuf:"bytes,6,rep,name=in_place_left_emit,json=inPlaceLeftEmit,proto3" json:"in_place_left_emit"`
	InPlaceRightEmit []Node_InternalJoin_Emission `protobuf:"bytes,7,rep,name=in_place_right_emit,json=inPlaceRightEmit,proto3" json:"in_place_right_emit"`
	Kind             Node_InternalJoin_JoinType   `protobuf:"varint,8,opt,name=kind,proto3,enum=node.Node_InternalJoin_JoinType" json:"kind,omitempty"`
}

func (m *Node_InternalJoin) Reset()         { *m = Node_InternalJoin{} }
func (m *Node_InternalJoin) String() string { return proto.CompactTextString(m) }
func (*Node_InternalJoin) ProtoMessage()    {}
func (*Node_InternalJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 6}
}
func (m *Node_InternalJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalJoin.Merge(m, src)
}
func (m *Node_InternalJoin) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalJoin.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalJoin proto.InternalMessageInfo

type Node_InternalJoin_Emission struct {
	Left bool `protobuf:"varint,1,opt,name=left,proto3" json:"left,omitempty"`
	Col  int  `protobuf:"varint,2,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
}

func (m *Node_InternalJoin_Emission) Reset()         { *m = Node_InternalJoin_Emission{} }
func (m *Node_InternalJoin_Emission) String() string { return proto.CompactTextString(m) }
func (*Node_InternalJoin_Emission) ProtoMessage()    {}
func (*Node_InternalJoin_Emission) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 6, 0}
}
func (m *Node_InternalJoin_Emission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalJoin_Emission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalJoin_Emission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalJoin_Emission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalJoin_Emission.Merge(m, src)
}
func (m *Node_InternalJoin_Emission) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalJoin_Emission) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalJoin_Emission.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalJoin_Emission proto.InternalMessageInfo

type Node_InternalGrouped struct {
	Src     *IndexPair                          `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Inner   []*Node_InternalGrouped_Aggregation `protobuf:"bytes,2,rep,name=inner,proto3" json:"inner,omitempty"`
	Cols    int                                 `protobuf:"varint,3,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	GroupBy []int                               `protobuf:"varint,4,rep,packed,name=group_by,json=groupBy,proto3,casttype=int" json:"group_by,omitempty"`
	OutKey  []int                               `protobuf:"varint,5,rep,packed,name=out_key,json=outKey,proto3,casttype=int" json:"out_key,omitempty"`
	Colfix  []int                               `protobuf:"varint,6,rep,packed,name=colfix,proto3,casttype=int" json:"colfix,omitempty"`
}

func (m *Node_InternalGrouped) Reset()         { *m = Node_InternalGrouped{} }
func (m *Node_InternalGrouped) String() string { return proto.CompactTextString(m) }
func (*Node_InternalGrouped) ProtoMessage()    {}
func (*Node_InternalGrouped) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 7}
}
func (m *Node_InternalGrouped) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalGrouped) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalGrouped.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalGrouped) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalGrouped.Merge(m, src)
}
func (m *Node_InternalGrouped) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalGrouped) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalGrouped.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalGrouped proto.InternalMessageInfo

type Node_InternalGrouped_Aggregation struct {
	Kind Node_InternalGrouped_Aggregation_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=node.Node_InternalGrouped_Aggregation_Kind" json:"kind,omitempty"`
	Over int                                   `protobuf:"varint,2,opt,name=over,proto3,casttype=int" json:"over,omitempty"`
}

func (m *Node_InternalGrouped_Aggregation) Reset()         { *m = Node_InternalGrouped_Aggregation{} }
func (m *Node_InternalGrouped_Aggregation) String() string { return proto.CompactTextString(m) }
func (*Node_InternalGrouped_Aggregation) ProtoMessage()    {}
func (*Node_InternalGrouped_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 7, 0}
}
func (m *Node_InternalGrouped_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalGrouped_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalGrouped_Aggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalGrouped_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalGrouped_Aggregation.Merge(m, src)
}
func (m *Node_InternalGrouped_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalGrouped_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalGrouped_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalGrouped_Aggregation proto.InternalMessageInfo

type Node_InternalProject struct {
	Src         *IndexPair `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Cols        int        `protobuf:"varint,3,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Projections []string   `protobuf:"bytes,4,rep,name=projections,proto3" json:"projections,omitempty"`
}

func (m *Node_InternalProject) Reset()         { *m = Node_InternalProject{} }
func (m *Node_InternalProject) String() string { return proto.CompactTextString(m) }
func (*Node_InternalProject) ProtoMessage()    {}
func (*Node_InternalProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 8}
}
func (m *Node_InternalProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalProject.Merge(m, src)
}
func (m *Node_InternalProject) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalProject) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalProject.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalProject proto.InternalMessageInfo

type Node_InternalFilter struct {
	Src    *IndexPair                        `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Filter []*Node_InternalFilter_FilterExpr `protobuf:"bytes,2,rep,name=filter,proto3" json:"filter,omitempty"`
}

func (m *Node_InternalFilter) Reset()         { *m = Node_InternalFilter{} }
func (m *Node_InternalFilter) String() string { return proto.CompactTextString(m) }
func (*Node_InternalFilter) ProtoMessage()    {}
func (*Node_InternalFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 9}
}
func (m *Node_InternalFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalFilter.Merge(m, src)
}
func (m *Node_InternalFilter) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalFilter.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalFilter proto.InternalMessageInfo

type Node_InternalFilter_FilterExpr struct {
	Expr string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Col  int    `protobuf:"varint,2,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
}

func (m *Node_InternalFilter_FilterExpr) Reset()         { *m = Node_InternalFilter_FilterExpr{} }
func (m *Node_InternalFilter_FilterExpr) String() string { return proto.CompactTextString(m) }
func (*Node_InternalFilter_FilterExpr) ProtoMessage()    {}
func (*Node_InternalFilter_FilterExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 9, 0}
}
func (m *Node_InternalFilter_FilterExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalFilter_FilterExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalFilter_FilterExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalFilter_FilterExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalFilter_FilterExpr.Merge(m, src)
}
func (m *Node_InternalFilter_FilterExpr) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalFilter_FilterExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalFilter_FilterExpr.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalFilter_FilterExpr proto.InternalMessageInfo

type Node_InternalTopK struct {
	Src    *IndexPair      `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Order  []OrderedColumn `protobuf:"bytes,2,rep,name=order,proto3" json:"order"`
	K      uint            `protobuf:"varint,3,opt,name=K,proto3,casttype=uint" json:"K,omitempty"`
	Params []int           `protobuf:"varint,4,rep,packed,name=params,proto3,casttype=int" json:"params,omitempty"`
}

func (m *Node_InternalTopK) Reset()         { *m = Node_InternalTopK{} }
func (m *Node_InternalTopK) String() string { return proto.CompactTextString(m) }
func (*Node_InternalTopK) ProtoMessage()    {}
func (*Node_InternalTopK) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 10}
}
func (m *Node_InternalTopK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalTopK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalTopK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalTopK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalTopK.Merge(m, src)
}
func (m *Node_InternalTopK) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalTopK) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalTopK.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalTopK proto.InternalMessageInfo

type Node_InternalDistinct struct {
	Src    *IndexPair `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Params []int      `protobuf:"varint,2,rep,packed,name=params,proto3,casttype=int" json:"params,omitempty"`
}

func (m *Node_InternalDistinct) Reset()         { *m = Node_InternalDistinct{} }
func (m *Node_InternalDistinct) String() string { return proto.CompactTextString(m) }
func (*Node_InternalDistinct) ProtoMessage()    {}
func (*Node_InternalDistinct) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 11}
}
func (m *Node_InternalDistinct) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalDistinct) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalDistinct.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalDistinct) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalDistinct.Merge(m, src)
}
func (m *Node_InternalDistinct) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalDistinct) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalDistinct.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalDistinct proto.InternalMessageInfo

type Node_Sharder struct {
	ShardBy int `protobuf:"varint,1,opt,name=shard_by,json=shardBy,proto3,casttype=int" json:"shard_by,omitempty"`
}

func (m *Node_Sharder) Reset()         { *m = Node_Sharder{} }
func (m *Node_Sharder) String() string { return proto.CompactTextString(m) }
func (*Node_Sharder) ProtoMessage()    {}
func (*Node_Sharder) Descriptor() ([]byte, []int) {
	return fileDescriptor_0c843d59d2d938e7, []int{6, 12}
}
func (m *Node_Sharder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Sharder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Sharder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Sharder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Sharder.Merge(m, src)
}
func (m *Node_Sharder) XXX_Size() int {
	return m.Size()
}
func (m *Node_Sharder) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Sharder.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Sharder proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("node.Sharding_Mode", Sharding_Mode_name, Sharding_Mode_value)
	proto.RegisterEnum("node.Node_InternalJoin_JoinType", Node_InternalJoin_JoinType_name, Node_InternalJoin_JoinType_value)
	proto.RegisterEnum("node.Node_InternalGrouped_Aggregation_Kind", Node_InternalGrouped_Aggregation_Kind_name, Node_InternalGrouped_Aggregation_Kind_value)
	proto.RegisterType((*Type)(nil), "node.Type")
	proto.RegisterType((*IndexPair)(nil), "node.IndexPair")
	proto.RegisterType((*DomainAddr)(nil), "node.DomainAddr")
	proto.RegisterType((*Sharding)(nil), "node.Sharding")
	proto.RegisterType((*ViewParameter)(nil), "node.ViewParameter")
	proto.RegisterType((*OrderedColumn)(nil), "node.OrderedColumn")
	proto.RegisterType((*Node)(nil), "node.Node")
	proto.RegisterType((*Node_Base)(nil), "node.Node.Base")
	proto.RegisterType((*Node_ExternalBase)(nil), "node.Node.ExternalBase")
	proto.RegisterType((*Node_Ingress)(nil), "node.Node.Ingress")
	proto.RegisterType((*Node_Egress)(nil), "node.Node.Egress")
	proto.RegisterType((*Node_Reader)(nil), "node.Node.Reader")
	proto.RegisterType((*Node_InternalUnion)(nil), "node.Node.InternalUnion")
	proto.RegisterType((*Node_InternalUnion_EmitProject)(nil), "node.Node.InternalUnion.EmitProject")
	proto.RegisterType((*Node_InternalUnion_EmitProject_EmitTuple)(nil), "node.Node.InternalUnion.EmitProject.EmitTuple")
	proto.RegisterType((*Node_InternalUnion_EmitProject_EmitLeftTuple)(nil), "node.Node.InternalUnion.EmitProject.EmitLeftTuple")
	proto.RegisterType((*Node_InternalUnion_EmitProject_ColumnsTuple)(nil), "node.Node.InternalUnion.EmitProject.ColumnsTuple")
	proto.RegisterType((*Node_InternalUnion_EmitProject_ColumnsLeftTuple)(nil), "node.Node.InternalUnion.EmitProject.ColumnsLeftTuple")
	proto.RegisterType((*Node_InternalUnion_EmitAll)(nil), "node.Node.InternalUnion.EmitAll")
	proto.RegisterType((*Node_InternalJoin)(nil), "node.Node.InternalJoin")
	proto.RegisterType((*Node_InternalJoin_Emission)(nil), "node.Node.InternalJoin.Emission")
	proto.RegisterType((*Node_InternalGrouped)(nil), "node.Node.InternalGrouped")
	proto.RegisterType((*Node_InternalGrouped_Aggregation)(nil), "node.Node.InternalGrouped.Aggregation")
	proto.RegisterType((*Node_InternalProject)(nil), "node.Node.InternalProject")
	proto.RegisterType((*Node_InternalFilter)(nil), "node.Node.InternalFilter")
	proto.RegisterType((*Node_InternalFilter_FilterExpr)(nil), "node.Node.InternalFilter.FilterExpr")
	proto.RegisterType((*Node_InternalTopK)(nil), "node.Node.InternalTopK")
	proto.RegisterType((*Node_InternalDistinct)(nil), "node.Node.InternalDistinct")
	proto.RegisterType((*Node_Sharder)(nil), "node.Node.Sharder")
}

func init() { proto.RegisterFile("node.proto", fileDescriptor_0c843d59d2d938e7) }

var fileDescriptor_0c843d59d2d938e7 = []byte{
	// 1900 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcd, 0x72, 0x1b, 0xc7,
	0x11, 0xc6, 0x02, 0x0b, 0x60, 0xd1, 0xfc, 0x11, 0x32, 0x56, 0xe4, 0xd5, 0xba, 0x42, 0x40, 0x90,
	0x65, 0x21, 0x96, 0x05, 0x5a, 0x94, 0x93, 0x8a, 0xec, 0x94, 0x1d, 0xc1, 0x92, 0x4c, 0x86, 0xb2,
	0xc5, 0x5a, 0x4a, 0x3a, 0xb8, 0x92, 0x42, 0x2d, 0xb1, 0x03, 0x70, 0xcc, 0xc5, 0xce, 0x6a, 0x76,
	0x21, 0x13, 0x97, 0x3c, 0x40, 0x4e, 0xb9, 0xa7, 0x7c, 0xc8, 0x2d, 0x87, 0x54, 0x5e, 0x23, 0x3a,
	0xba, 0x72, 0x49, 0x0e, 0x29, 0x54, 0x22, 0xbd, 0x05, 0x4f, 0xa9, 0xe9, 0x99, 0x05, 0x17, 0x20,
	0x40, 0x81, 0x17, 0x60, 0x66, 0xfa, 0xeb, 0x9e, 0xee, 0x9e, 0xee, 0x9e, 0x9e, 0x05, 0x08, 0xb9,
	0x4f, 0x5b, 0x91, 0xe0, 0x09, 0x27, 0xa6, 0x1c, 0x3b, 0x97, 0xfb, 0xbc, 0xcf, 0x71, 0x61, 0x53,
	0x8e, 0x14, 0xad, 0xf1, 0x0f, 0x03, 0xcc, 0xa7, 0xa3, 0x88, 0x92, 0xbb, 0x60, 0x24, 0xb6, 0x51,
	0x37, 0x9a, 0xc5, 0xf6, 0x8d, 0x93, 0x71, 0xed, 0xda, 0x4b, 0x96, 0xd0, 0x38, 0x6e, 0x31, 0xbe,
	0xa9, 0x46, 0x9b, 0x7d, 0xbe, 0x19, 0xbf, 0x08, 0x92, 0x51, 0x44, 0xe3, 0x96, 0xe4, 0x70, 0x8d,
	0x84, 0xec, 0x40, 0xa5, 0xcb, 0x83, 0xc0, 0x4b, 0x18, 0x0f, 0xed, 0x7c, 0xdd, 0x68, 0xae, 0xb5,
	0x6f, 0x9d, 0x8c, 0x6b, 0x37, 0xe7, 0x31, 0x0f, 0x46, 0xf1, 0x8b, 0x60, 0x73, 0x02, 0x8f, 0x5b,
	0x3b, 0x0f, 0xdc, 0x53, 0x6e, 0xe2, 0x80, 0x15, 0x0e, 0x83, 0xc0, 0x3b, 0x08, 0xa8, 0x5d, 0xa8,
	0x1b, 0x4d, 0xcb, 0x9d, 0xcc, 0xc9, 0x75, 0x28, 0xfb, 0xb4, 0xe7, 0x0d, 0x83, 0xc4, 0x36, 0xeb,
	0x46, 0xb3, 0xd2, 0xae, 0x9c, 0x8c, 0x6b, 0xc5, 0xe7, 0x5e, 0x30, 0xa4, 0x6e, 0x4a, 0x69, 0x74,
	0xa0, 0xb2, 0x13, 0xfa, 0xf4, 0x78, 0xcf, 0x63, 0x82, 0x34, 0xa1, 0xd4, 0x0f, 0xf8, 0x81, 0x17,
	0xa0, 0x49, 0x6b, 0xed, 0xea, 0xc9, 0xb8, 0xb6, 0xfa, 0x95, 0xf0, 0xa2, 0xc3, 0x6f, 0xb8, 0x4f,
	0x77, 0xfc, 0x63, 0x57, 0xd3, 0x49, 0x13, 0x8a, 0x01, 0xef, 0x7a, 0x81, 0x56, 0x9f, 0x9c, 0x8c,
	0x6b, 0xeb, 0x8f, 0xe5, 0x02, 0x02, 0xa5, 0x40, 0x57, 0x01, 0x1a, 0xcf, 0x00, 0x1e, 0xf0, 0x81,
	0xc7, 0xc2, 0xfb, 0xbe, 0x2f, 0xc8, 0x4d, 0x28, 0xf9, 0x38, 0xc3, 0x1d, 0xcc, 0xf6, 0xa5, 0x93,
	0x71, 0x6d, 0x45, 0xd1, 0x15, 0x97, 0x26, 0x93, 0x0d, 0x28, 0xc6, 0x87, 0x9e, 0xf0, 0x71, 0x03,
	0xb3, 0x6d, 0x9d, 0x8c, 0x6b, 0xe6, 0x90, 0x85, 0x89, 0xab, 0x96, 0x1b, 0x7f, 0x33, 0xc0, 0xda,
	0x97, 0x23, 0x16, 0xf6, 0xc9, 0x4d, 0x30, 0x07, 0xdc, 0xa7, 0x28, 0x73, 0x7d, 0xeb, 0x9d, 0x16,
	0x9e, 0x62, 0x4a, 0x6d, 0x7d, 0xcd, 0x7d, 0xea, 0x22, 0x80, 0x5c, 0x85, 0x42, 0x97, 0x2b, 0xa5,
	0x0b, 0xed, 0xf2, 0xc9, 0xb8, 0x56, 0x90, 0x22, 0xe5, 0x1a, 0xa9, 0x43, 0x09, 0x25, 0xc7, 0xe8,
	0xc7, 0xec, 0x8e, 0x7a, 0xbd, 0xf1, 0x29, 0x98, 0x52, 0x14, 0xb1, 0xc0, 0xfc, 0x86, 0x87, 0xb4,
	0x9a, 0x23, 0xeb, 0x00, 0x8f, 0xb8, 0xe8, 0x52, 0x1f, 0xe7, 0x06, 0x01, 0x28, 0xb9, 0x5e, 0xe8,
	0xf3, 0x41, 0x35, 0x4f, 0x56, 0xc1, 0x6a, 0x8f, 0xbe, 0xe4, 0xc1, 0x70, 0x10, 0x56, 0x0b, 0x8d,
	0x7b, 0xb0, 0xf6, 0x9c, 0xd1, 0xef, 0xf7, 0x3c, 0xe1, 0x0d, 0x68, 0x42, 0x05, 0x21, 0x60, 0x86,
	0xde, 0x40, 0xa9, 0x5c, 0x71, 0x71, 0x4c, 0x2e, 0x43, 0x71, 0x30, 0x0c, 0x12, 0x86, 0xfa, 0x59,
	0xae, 0x9a, 0x34, 0x3e, 0x87, 0xb5, 0x27, 0xc2, 0xa7, 0x82, 0xfa, 0x4a, 0x5a, 0x6a, 0x84, 0x31,
	0xc7, 0x08, 0x02, 0xa6, 0x4f, 0xe3, 0xae, 0x16, 0x80, 0xe3, 0xc6, 0x7f, 0xea, 0x52, 0x5f, 0x9f,
	0xce, 0xdd, 0xf2, 0x06, 0x14, 0x99, 0xf4, 0x3b, 0x72, 0xac, 0x6c, 0x5d, 0x52, 0xae, 0x9b, 0x44,
	0x84, 0xab, 0xa8, 0x99, 0x63, 0x2b, 0x9c, 0x7f, 0x6c, 0x57, 0xa0, 0xd4, 0x63, 0x34, 0xf0, 0x63,
	0xdb, 0xac, 0x17, 0x9a, 0x15, 0x57, 0xcf, 0x64, 0x64, 0xc5, 0xdd, 0x43, 0x3a, 0xf0, 0xec, 0x62,
	0xbd, 0xd0, 0x5c, 0xd9, 0x02, 0xb5, 0x91, 0xcc, 0x88, 0xb6, 0xf9, 0x6a, 0x5c, 0xcb, 0xb9, 0x9a,
	0x4e, 0x3e, 0x82, 0x72, 0xe4, 0x09, 0x1a, 0x26, 0xb1, 0x5d, 0xaa, 0x17, 0x16, 0xc4, 0x56, 0x0a,
	0x21, 0x2d, 0xb0, 0xba, 0x87, 0x2c, 0xf0, 0x05, 0x0d, 0xed, 0xf2, 0x42, 0xf8, 0x04, 0x23, 0x5d,
	0x9c, 0x78, 0x47, 0x34, 0xb4, 0x2d, 0xe5, 0x62, 0x9c, 0xc8, 0xd5, 0x68, 0x28, 0xfa, 0xd4, 0xae,
	0xa8, 0x55, 0x9c, 0x90, 0x0f, 0xc1, 0x8a, 0x75, 0x0c, 0xd9, 0x80, 0xee, 0x59, 0x9f, 0x8e, 0x2c,
	0x77, 0x42, 0x27, 0x37, 0xc0, 0x3c, 0xf0, 0x62, 0x6a, 0x5f, 0xce, 0xba, 0x51, 0x2a, 0xd0, 0x6a,
	0x7b, 0x31, 0xdd, 0xce, 0xb9, 0x48, 0x26, 0x2d, 0x28, 0xb3, 0xb0, 0x2f, 0x68, 0x1c, 0xdb, 0x3f,
	0x45, 0x24, 0xc9, 0x20, 0x77, 0x14, 0x65, 0x3b, 0xe7, 0xa6, 0x20, 0x72, 0x0b, 0x4a, 0x54, 0xc1,
	0xaf, 0x20, 0xfc, 0x27, 0x19, 0xf8, 0xc3, 0x14, 0xad, 0x21, 0x12, 0x2c, 0xa8, 0xe7, 0x53, 0x61,
	0xbf, 0x7b, 0x06, 0xec, 0x22, 0x41, 0x82, 0x15, 0x44, 0x6a, 0x82, 0xca, 0x53, 0x61, 0xdb, 0x67,
	0x34, 0xd9, 0x57, 0x14, 0xa9, 0x89, 0x06, 0x91, 0xcf, 0x61, 0x8d, 0x1e, 0x27, 0x54, 0x84, 0x5e,
	0xd0, 0x41, 0x4b, 0xaf, 0x22, 0xd7, 0xbb, 0x59, 0x85, 0x34, 0x5d, 0x5b, 0xbc, 0x4a, 0x33, 0x73,
	0xf2, 0x31, 0x14, 0x87, 0xa1, 0xac, 0x77, 0x4d, 0xe4, 0xb3, 0xa7, 0xec, 0x56, 0xb8, 0x67, 0x92,
	0xbe, 0x9d, 0x73, 0x15, 0x90, 0xdc, 0x06, 0xf3, 0x3b, 0xce, 0x42, 0xfb, 0xe7, 0x67, 0x36, 0x4a,
	0x19, 0x7e, 0xcb, 0x99, 0xc4, 0x23, 0x8c, 0xfc, 0x12, 0xca, 0x7d, 0xc1, 0x87, 0x11, 0xf5, 0xed,
	0x0f, 0x91, 0xc3, 0x99, 0xc3, 0xf1, 0x95, 0x42, 0x48, 0xc3, 0x34, 0x58, 0xf2, 0x45, 0x82, 0x7f,
	0x47, 0xbb, 0x89, 0x7d, 0x6b, 0x21, 0xdf, 0x9e, 0x42, 0x48, 0x3e, 0x0d, 0x26, 0x77, 0x65, 0xa4,
	0x07, 0x09, 0x15, 0xf6, 0x47, 0xc8, 0x76, 0x75, 0x0e, 0xdb, 0x23, 0x04, 0x48, 0xaf, 0x2b, 0x28,
	0x69, 0x41, 0x31, 0xe1, 0x51, 0xe7, 0xc8, 0xbe, 0xbd, 0xd0, 0xa8, 0xa7, 0x3c, 0xda, 0x95, 0x46,
	0x25, 0x3c, 0xda, 0x25, 0xf7, 0xc0, 0xf2, 0x59, 0x9c, 0xb0, 0xb0, 0x9b, 0xd8, 0x2d, 0x64, 0x79,
	0x6f, 0x0e, 0xcb, 0x03, 0x0d, 0xd9, 0xce, 0xb9, 0x13, 0xb8, 0xf3, 0x83, 0x01, 0x26, 0x7a, 0xbe,
	0x09, 0x2b, 0x91, 0x60, 0x03, 0x4f, 0x8c, 0x3a, 0x47, 0x74, 0x64, 0x1b, 0xf5, 0x42, 0xb6, 0x6c,
	0x80, 0xa6, 0xed, 0xd2, 0x11, 0xb9, 0x06, 0x65, 0x5f, 0xf0, 0x48, 0xba, 0x30, 0x3f, 0x8d, 0x4a,
	0xd7, 0xc9, 0x06, 0xc0, 0x30, 0x1c, 0x70, 0x9f, 0xf5, 0x18, 0xf5, 0xf1, 0x5a, 0xb1, 0xdc, 0xcc,
	0xca, 0xf2, 0x79, 0xee, 0xfc, 0x01, 0x56, 0xb3, 0x01, 0x73, 0x01, 0x35, 0x1d, 0xb0, 0x8e, 0xe8,
	0x28, 0x8e, 0xbc, 0x2e, 0xc5, 0xb2, 0x55, 0x71, 0x27, 0xf3, 0xcc, 0xfe, 0x85, 0xb7, 0xec, 0x5f,
	0x81, 0xb2, 0x4e, 0x38, 0xc7, 0x82, 0x92, 0x4a, 0x26, 0xe7, 0x5f, 0x79, 0x28, 0xa9, 0x54, 0x21,
	0xb7, 0xc0, 0xea, 0x71, 0xd1, 0x09, 0xd3, 0x7b, 0x65, 0xde, 0x6d, 0x58, 0xee, 0x71, 0x81, 0xa5,
	0xf5, 0x67, 0x50, 0x8c, 0x13, 0x2f, 0xa1, 0xb3, 0x7e, 0x53, 0xab, 0xe4, 0x1e, 0x40, 0x94, 0x56,
	0xfe, 0x58, 0x6b, 0xa6, 0x6f, 0xa9, 0xa9, 0x5b, 0x41, 0xab, 0x98, 0x01, 0x93, 0x5f, 0x01, 0x24,
	0x3c, 0x3a, 0xea, 0x70, 0x4c, 0xd5, 0x62, 0x96, 0x75, 0xea, 0x56, 0xd0, 0xac, 0x15, 0x09, 0x46,
	0x02, 0xf9, 0x40, 0x73, 0x06, 0x6c, 0xc0, 0x12, 0xbb, 0x34, 0x7d, 0x5b, 0x20, 0xee, 0xb1, 0xa4,
	0x90, 0x3b, 0x50, 0xed, 0xa2, 0x88, 0xb8, 0x23, 0x0d, 0x7e, 0xc9, 0xe8, 0xf7, 0x76, 0x79, 0x1a,
	0xbd, 0xae, 0x01, 0x8f, 0xb8, 0x90, 0xfa, 0xce, 0xb2, 0x0c, 0x63, 0x2a, 0xb0, 0xa0, 0xce, 0x67,
	0x79, 0x16, 0x53, 0xe1, 0xfc, 0xb3, 0x0c, 0x6b, 0x53, 0x89, 0x4e, 0x7e, 0x73, 0x9a, 0x78, 0x06,
	0x86, 0xf6, 0xfb, 0x8b, 0x6a, 0x42, 0xeb, 0xe1, 0x80, 0x25, 0x73, 0x52, 0xf0, 0x13, 0x28, 0x78,
	0x41, 0xa0, 0xaf, 0xae, 0xfa, 0xb9, 0xdc, 0xf7, 0x83, 0x60, 0x3b, 0xe7, 0x4a, 0x38, 0xb9, 0x0e,
	0x96, 0xa0, 0x2f, 0x86, 0x4c, 0x50, 0x1f, 0x6f, 0xb3, 0x8c, 0xd2, 0x13, 0x02, 0xa9, 0x43, 0x7e,
	0x40, 0x31, 0xbe, 0xe7, 0x9d, 0x7b, 0x7e, 0x40, 0x9d, 0x1f, 0x8a, 0xb0, 0x92, 0xd1, 0x8b, 0xb4,
	0xc1, 0xa4, 0xd2, 0xd1, 0x06, 0x1e, 0x51, 0x6b, 0x19, 0x5b, 0x70, 0xfc, 0x74, 0x18, 0x05, 0xd4,
	0x45, 0x5e, 0xf2, 0x04, 0x2a, 0xf2, 0xbf, 0x13, 0xd0, 0x5e, 0x82, 0xa1, 0xb4, 0xb2, 0xb5, 0xb5,
	0xb4, 0xa0, 0xc7, 0xb4, 0xa7, 0x85, 0x59, 0x54, 0x4f, 0xc9, 0x43, 0x30, 0xbb, 0x3c, 0x48, 0x43,
	0xee, 0xce, 0x52, 0xb2, 0x54, 0x3c, 0xc5, 0x5a, 0x2f, 0xc9, 0x4e, 0x5c, 0x6c, 0x58, 0x63, 0xa5,
	0x97, 0x89, 0xb2, 0x7e, 0x71, 0x11, 0x59, 0x19, 0xd5, 0xa4, 0x1c, 0x39, 0x75, 0x9e, 0x40, 0x65,
	0x62, 0x3e, 0xa9, 0x41, 0x9e, 0x45, 0x3a, 0x0c, 0xce, 0xf4, 0x20, 0x79, 0x16, 0xc9, 0xd2, 0xa4,
	0x03, 0xea, 0x4c, 0x69, 0xd2, 0xeb, 0xce, 0xef, 0x60, 0x6d, 0xca, 0x0d, 0xb2, 0x47, 0x55, 0xbd,
	0x8d, 0xb1, 0xb8, 0x47, 0x55, 0xed, 0xcd, 0x12, 0xd2, 0xf7, 0x60, 0x35, 0xeb, 0x98, 0xb7, 0x6b,
	0x5c, 0x83, 0x92, 0xe2, 0x9d, 0xed, 0x36, 0xf5, 0xb2, 0xf3, 0x7b, 0xa8, 0xce, 0xba, 0xe7, 0x02,
	0x2a, 0xbf, 0x55, 0xfc, 0xb7, 0x50, 0xd6, 0x81, 0x4f, 0xae, 0x83, 0xd9, 0x13, 0x7c, 0xb0, 0x48,
	0x5b, 0x24, 0x4e, 0x75, 0x3b, 0xf9, 0xf3, 0xbb, 0x9d, 0x76, 0x49, 0xc5, 0xba, 0xf3, 0x47, 0x13,
	0x56, 0xb3, 0x97, 0xb1, 0xdc, 0x09, 0x63, 0x64, 0xd1, 0x4e, 0x92, 0x28, 0x7b, 0x4e, 0xc1, 0xfa,
	0x87, 0xc9, 0xc2, 0x9e, 0x13, 0xa9, 0xb2, 0xcd, 0xe5, 0xe1, 0xc7, 0xb3, 0x29, 0x2a, 0xd7, 0x14,
	0xe9, 0x0e, 0xa6, 0xe7, 0x34, 0xe9, 0x0e, 0xf9, 0x54, 0xa7, 0xa1, 0xaa, 0x94, 0xf5, 0x05, 0x5d,
	0x83, 0x0c, 0xd2, 0x38, 0x66, 0x3c, 0x2d, 0x9b, 0x2a, 0xfd, 0xf6, 0x81, 0xb0, 0xb0, 0x13, 0x05,
	0x5e, 0x97, 0x62, 0xa8, 0x77, 0xa8, 0xaa, 0x9c, 0x17, 0x91, 0x74, 0x89, 0x85, 0x7b, 0x52, 0x80,
	0x3c, 0x53, 0xe9, 0x7f, 0xf2, 0x0c, 0xde, 0x99, 0x08, 0x45, 0xc3, 0x94, 0xd4, 0xf2, 0x85, 0xa4,
	0x56, 0xb5, 0x54, 0x57, 0x0a, 0x40, 0xb1, 0x9f, 0x80, 0x79, 0xc4, 0x42, 0x1f, 0xcb, 0xee, 0xfa,
	0x62, 0x39, 0xf2, 0x07, 0x9f, 0x9d, 0x88, 0x76, 0xee, 0x81, 0x95, 0x4a, 0x96, 0xcf, 0x81, 0xc9,
	0x59, 0x59, 0xfa, 0x68, 0x16, 0xbf, 0x8f, 0x1a, 0x35, 0xb0, 0x52, 0x61, 0xf2, 0x05, 0x24, 0xed,
	0xab, 0xe6, 0x48, 0x05, 0x8a, 0x3b, 0x61, 0x48, 0x45, 0xd5, 0x70, 0xfe, 0x52, 0x80, 0x4b, 0x33,
	0x7d, 0x16, 0xb9, 0x06, 0x85, 0x58, 0x74, 0x17, 0x85, 0x83, 0xa4, 0x91, 0x5f, 0xcb, 0x90, 0x0f,
	0xa9, 0xd0, 0xf5, 0xee, 0x83, 0xc5, 0x5d, 0x5b, 0xeb, 0x7e, 0xbf, 0x2f, 0x68, 0x1f, 0x1f, 0xbe,
	0xae, 0x62, 0x22, 0xef, 0x4d, 0x0a, 0xdc, 0x94, 0xc6, 0xaa, 0x6c, 0x35, 0xc0, 0xc2, 0x2e, 0xaf,
	0x73, 0x30, 0xc2, 0xaa, 0x95, 0xcd, 0x6b, 0x24, 0xb4, 0x47, 0xa4, 0x0e, 0x65, 0x3e, 0x4c, 0xb0,
	0xe5, 0x28, 0x4e, 0x43, 0x4a, 0x7c, 0x98, 0xc8, 0x76, 0x43, 0x65, 0x5a, 0x8f, 0x1d, 0x63, 0x24,
	0xcc, 0x64, 0x5a, 0x8f, 0x1d, 0x3b, 0x7f, 0x35, 0x60, 0x25, 0xa3, 0x1a, 0xf9, 0x42, 0x1f, 0x8d,
	0x7a, 0x8d, 0xde, 0x5a, 0xce, 0xa0, 0xd6, 0x2e, 0x0b, 0x7d, 0x75, 0x4a, 0xd2, 0x28, 0xfe, 0x12,
	0x3d, 0x32, 0x6d, 0x94, 0x5c, 0x6c, 0x7c, 0x06, 0xa6, 0x84, 0x4a, 0xcf, 0x7f, 0xc9, 0x87, 0xa1,
	0x3c, 0x84, 0x35, 0xa8, 0xe0, 0x70, 0x3f, 0xf1, 0x44, 0xd5, 0x20, 0x65, 0x28, 0xec, 0x0f, 0xe5,
	0x13, 0xb4, 0x0c, 0x85, 0xaf, 0x59, 0x58, 0x2d, 0xe0, 0xc0, 0x3b, 0xae, 0x9a, 0x4e, 0x7c, 0x7a,
	0x44, 0xe9, 0xbd, 0xb5, 0xc4, 0x11, 0x9d, 0xeb, 0xe4, 0xba, 0xec, 0xdb, 0x50, 0x14, 0xe3, 0x61,
	0xfa, 0xec, 0xcb, 0x2e, 0x39, 0x7f, 0x37, 0x60, 0x7d, 0xba, 0x23, 0x5e, 0x2e, 0x2e, 0xd2, 0xfe,
	0x5a, 0x05, 0xc6, 0xfb, 0x0b, 0xfb, 0xeb, 0x96, 0xfa, 0x7b, 0x78, 0x1c, 0x89, 0xb4, 0xd1, 0x76,
	0x3e, 0x03, 0x38, 0x5d, 0x95, 0xa1, 0x4e, 0x8f, 0x23, 0x91, 0xbe, 0x7c, 0xe5, 0xf8, 0x9c, 0x50,
	0x77, 0xfe, 0x6c, 0x9c, 0x96, 0x35, 0xd9, 0x8e, 0x2f, 0xa3, 0xee, 0x26, 0x14, 0x55, 0x8b, 0x96,
	0x7f, 0x5b, 0x8b, 0xa6, 0x70, 0xe4, 0x0a, 0x18, 0xbb, 0x67, 0x3e, 0x35, 0x18, 0xbb, 0x32, 0xdc,
	0xb0, 0xfd, 0x8b, 0x67, 0x43, 0x56, 0x2f, 0x3b, 0xcf, 0xa1, 0x3a, 0xdb, 0xf8, 0x2f, 0xa3, 0xe0,
	0xa9, 0xdc, 0xfc, 0x7c, 0xb9, 0xb7, 0xa1, 0xac, 0xdf, 0x7d, 0x32, 0x71, 0xb0, 0xd6, 0xcb, 0xc4,
	0x99, 0xf9, 0xcc, 0xa0, 0x1e, 0x84, 0xed, 0x91, 0xbc, 0x03, 0xd8, 0x20, 0x0a, 0xda, 0x5f, 0xbc,
	0xfa, 0xdf, 0x46, 0xee, 0xd5, 0xeb, 0x0d, 0xe3, 0xc7, 0xd7, 0x1b, 0xc6, 0x7f, 0x5f, 0x6f, 0x18,
	0x7f, 0x7a, 0xb3, 0x91, 0xfb, 0xf1, 0xcd, 0x46, 0xee, 0xdf, 0x6f, 0x36, 0x72, 0xdf, 0xce, 0xfd,
	0x20, 0x76, 0xc0, 0x79, 0x9c, 0xa8, 0xdf, 0xe8, 0xe0, 0xa0, 0x84, 0x9f, 0xd4, 0xee, 0xfe, 0x3f,
	0x00, 0x00, 0xff, 0xff, 0x81, 0xf9, 0x16, 0xe8, 0x7c, 0x13, 0x00, 0x00,
}

func (m *Type) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Type) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Type) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nullable {
		i--
		if m.Nullable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Collation != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Collation))
		i--
		dAtA[i] = 0x10
	}
	if m.T != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.T))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IndexPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Local != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Local))
		i--
		dAtA[i] = 0x10
	}
	if m.Global != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Global))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DomainAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DomainAddr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DomainAddr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shard != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Shard))
		i--
		dAtA[i] = 0x10
	}
	if m.Domain != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sharding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sharding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sharding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shards != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Shards))
		i--
		dAtA[i] = 0x18
	}
	if m.Col != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x10
	}
	if m.Mode != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Mode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ViewParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Multi {
		i--
		if m.Multi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc {
		i--
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Col != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Impl != nil {
		{
			size := m.Impl.Size()
			i -= size
			if _, err := m.Impl.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Purge {
		i--
		if m.Purge {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Taken {
		i--
		if m.Taken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Children) > 0 {
		dAtA3 := make([]byte, len(m.Children)*10)
		var j2 int
		for _, num := range m.Children {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintNode(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Parents) > 0 {
		dAtA5 := make([]byte, len(m.Parents)*10)
		var j4 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintNode(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintNode(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Domain != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Base_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Base_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Base != nil {
		{
			size, err := m.Base.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Ingress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Ingress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ingress != nil {
		{
			size, err := m.Ingress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Node_Egress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Egress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Egress != nil {
		{
			size, err := m.Egress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Reader_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Reader_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Reader != nil {
		{
			size, err := m.Reader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Node_Sharder_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Sharder_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sharder != nil {
		{
			size, err := m.Sharder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Node_ExternalBase_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_ExternalBase_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ExternalBase != nil {
		{
			size, err := m.ExternalBase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Node_Union) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Union) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Union != nil {
		{
			size, err := m.Union.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Node_Grouped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Grouped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Grouped != nil {
		{
			size, err := m.Grouped.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *Node_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *Node_TopK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_TopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TopK != nil {
		{
			size, err := m.TopK.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *Node_Distinct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Distinct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Distinct != nil {
		{
			size, err := m.Distinct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Base) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Base) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Base) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Unmodified {
		i--
		if m.Unmodified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Dropped) > 0 {
		dAtA21 := make([]byte, len(m.Dropped)*10)
		var j20 int
		for _, num1 := range m.Dropped {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintNode(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrimaryKey) > 0 {
		dAtA23 := make([]byte, len(m.PrimaryKey)*10)
		var j22 int
		for _, num1 := range m.PrimaryKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintNode(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_ExternalBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_ExternalBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_ExternalBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrimaryKey) > 0 {
		dAtA25 := make([]byte, len(m.PrimaryKey)*10)
		var j24 int
		for _, num1 := range m.PrimaryKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintNode(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Ingress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Ingress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Ingress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Node_Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Egress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Egress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Node_Reader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Reader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Reader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnsForUser != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.ColumnsForUser))
		i--
		dAtA[i] = 0x40
	}
	if m.ColumnsForView != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.ColumnsForView))
		i--
		dAtA[i] = 0x38
	}
	if m.TopkLimit != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.TopkLimit))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TopkOrder) > 0 {
		for iNdEx := len(m.TopkOrder) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopkOrder[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.State) > 0 {
		dAtA27 := make([]byte, len(m.State)*10)
		var j26 int
		for _, num1 := range m.State {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA27[j26] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j26++
			}
			dAtA27[j26] = uint8(num)
			j26++
		}
		i -= j26
		copy(dAtA[i:], dAtA27[:j26])
		i = encodeVarintNode(dAtA, i, uint64(j26))
		i--
		dAtA[i] = 0x12
	}
	if m.ForNode != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.ForNode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Me != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Me))
		i--
		dAtA[i] = 0x20
	}
	if m.Required != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Required))
		i--
		dAtA[i] = 0x18
	}
	if m.Emit != nil {
		{
			size := m.Emit.Size()
			i -= size
			if _, err := m.Emit.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Node_InternalUnion_All) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_All) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.All != nil {
		{
			size, err := m.All.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Node_InternalUnion_EmitProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ColsLeft) > 0 {
		for iNdEx := len(m.ColsLeft) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ColsLeft[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Cols) > 0 {
		for iNdEx := len(m.Cols) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cols[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EmitLeft) > 0 {
		for iNdEx := len(m.EmitLeft) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EmitLeft[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Emit) > 0 {
		for iNdEx := len(m.Emit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		dAtA31 := make([]byte, len(m.Columns)*10)
		var j30 int
		for _, num1 := range m.Columns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		i -= j30
		copy(dAtA[i:], dAtA31[:j30])
		i = encodeVarintNode(dAtA, i, uint64(j30))
		i--
		dAtA[i] = 0x12
	}
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		dAtA34 := make([]byte, len(m.Columns)*10)
		var j33 int
		for _, num1 := range m.Columns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintNode(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitProject_ColumnsTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject_ColumnsTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject_ColumnsTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != nil {
		{
			size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Column != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Column))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitAll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if len(m.InPlaceRightEmit) > 0 {
		for iNdEx := len(m.InPlaceRightEmit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InPlaceRightEmit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InPlaceLeftEmit) > 0 {
		for iNdEx := len(m.InPlaceLeftEmit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InPlaceLeftEmit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Emit) > 0 {
		for iNdEx := len(m.Emit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.On1 != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.On1))
		i--
		dAtA[i] = 0x20
	}
	if m.On0 != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.On0))
		i--
		dAtA[i] = 0x18
	}
	if m.Right != nil {
		{
			size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Left != nil {
		{
			size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalJoin_Emission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalJoin_Emission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalJoin_Emission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Col != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x10
	}
	if m.Left {
		i--
		if m.Left {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalGrouped) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalGrouped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalGrouped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Colfix) > 0 {
		dAtA41 := make([]byte, len(m.Colfix)*10)
		var j40 int
		for _, num1 := range m.Colfix {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintNode(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OutKey) > 0 {
		dAtA43 := make([]byte, len(m.OutKey)*10)
		var j42 int
		for _, num1 := range m.OutKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA43[j42] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j42++
			}
			dAtA43[j42] = uint8(num)
			j42++
		}
		i -= j42
		copy(dAtA[i:], dAtA43[:j42])
		i = encodeVarintNode(dAtA, i, uint64(j42))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GroupBy) > 0 {
		dAtA45 := make([]byte, len(m.GroupBy)*10)
		var j44 int
		for _, num1 := range m.GroupBy {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintNode(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x22
	}
	if m.Cols != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Inner) > 0 {
		for iNdEx := len(m.Inner) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inner[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalGrouped_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalGrouped_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalGrouped_Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Over != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Over))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Projections[iNdEx])
			copy(dAtA[i:], m.Projections[iNdEx])
			i = encodeVarintNode(dAtA, i, uint64(len(m.Projections[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Cols != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x18
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		for iNdEx := len(m.Filter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalFilter_FilterExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalFilter_FilterExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalFilter_FilterExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Col != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintNode(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalTopK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalTopK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalTopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		dAtA50 := make([]byte, len(m.Params)*10)
		var j49 int
		for _, num1 := range m.Params {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintNode(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x22
	}
	if m.K != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Order) > 0 {
		for iNdEx := len(m.Order) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Order[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalDistinct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalDistinct) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalDistinct) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		dAtA53 := make([]byte, len(m.Params)*10)
		var j52 int
		for _, num1 := range m.Params {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintNode(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x12
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Sharder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Sharder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Sharder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardBy != 0 {
		i = encodeVarintNode(dAtA, i, uint64(m.ShardBy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintNode(dAtA []byte, offset int, v uint64) int {
	offset -= sovNode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Type) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.T != 0 {
		n += 1 + sovNode(uint64(m.T))
	}
	if m.Collation != 0 {
		n += 1 + sovNode(uint64(m.Collation))
	}
	if m.Nullable {
		n += 2
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *IndexPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != 0 {
		n += 1 + sovNode(uint64(m.Global))
	}
	if m.Local != 0 {
		n += 1 + sovNode(uint64(m.Local))
	}
	return n
}

func (m *DomainAddr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovNode(uint64(m.Domain))
	}
	if m.Shard != 0 {
		n += 1 + sovNode(uint64(m.Shard))
	}
	return n
}

func (m *Sharding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Mode != 0 {
		n += 1 + sovNode(uint64(m.Mode))
	}
	if m.Col != 0 {
		n += 1 + sovNode(uint64(m.Col))
	}
	if m.Shards != 0 {
		n += 1 + sovNode(uint64(m.Shards))
	}
	return n
}

func (m *ViewParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Multi {
		n += 2
	}
	return n
}

func (m *OrderedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != 0 {
		n += 1 + sovNode(uint64(m.Col))
	}
	if m.Desc {
		n += 2
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Domain != 0 {
		n += 1 + sovNode(uint64(m.Domain))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if m.Taken {
		n += 2
	}
	if m.Purge {
		n += 2
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Impl != nil {
		n += m.Impl.Size()
	}
	return n
}

func (m *Node_Base_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Base != nil {
		l = m.Base.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Ingress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Egress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Reader_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reader != nil {
		l = m.Reader.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Sharder_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sharder != nil {
		l = m.Sharder.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_ExternalBase_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExternalBase != nil {
		l = m.ExternalBase.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Union) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		l = m.Union.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Join != nil {
		l = m.Join.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Grouped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Grouped != nil {
		l = m.Grouped.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_TopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopK != nil {
		l = m.TopK.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Distinct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Distinct != nil {
		l = m.Distinct.Size()
		n += 2 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_Base) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrimaryKey) > 0 {
		l = 0
		for _, e := range m.PrimaryKey {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.Dropped) > 0 {
		l = 0
		for _, e := range m.Dropped {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if m.Unmodified {
		n += 2
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Node_ExternalBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrimaryKey) > 0 {
		l = 0
		for _, e := range m.PrimaryKey {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Node_Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Node_Egress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Node_Reader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ForNode != 0 {
		n += 1 + sovNode(uint64(m.ForNode))
	}
	if len(m.State) > 0 {
		l = 0
		for _, e := range m.State {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.TopkOrder) > 0 {
		for _, e := range m.TopkOrder {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.TopkLimit != 0 {
		n += 1 + sovNode(uint64(m.TopkLimit))
	}
	if m.ColumnsForView != 0 {
		n += 1 + sovNode(uint64(m.ColumnsForView))
	}
	if m.ColumnsForUser != 0 {
		n += 1 + sovNode(uint64(m.ColumnsForUser))
	}
	return n
}

func (m *Node_InternalUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Emit != nil {
		n += m.Emit.Size()
	}
	if m.Required != 0 {
		n += 1 + sovNode(uint64(m.Required))
	}
	if m.Me != 0 {
		n += 1 + sovNode(uint64(m.Me))
	}
	return n
}

func (m *Node_InternalUnion_Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_InternalUnion_All) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}
func (m *Node_InternalUnion_EmitProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Emit) > 0 {
		for _, e := range m.Emit {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.EmitLeft) > 0 {
		for _, e := range m.EmitLeft {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.Cols) > 0 {
		for _, e := range m.Cols {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.ColsLeft) > 0 {
		for _, e := range m.ColsLeft {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Columns) > 0 {
		l = 0
		for _, e := range m.Columns {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovNode(uint64(m.Index))
	}
	if len(m.Columns) > 0 {
		l = 0
		for _, e := range m.Columns {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalUnion_EmitProject_ColumnsTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != nil {
		l = m.Ip.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Column != 0 {
		n += 1 + sovNode(uint64(m.Column))
	}
	return n
}

func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovNode(uint64(m.Index))
	}
	if m.Column != 0 {
		n += 1 + sovNode(uint64(m.Column))
	}
	return n
}

func (m *Node_InternalUnion_EmitAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	return n
}

func (m *Node_InternalJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.On0 != 0 {
		n += 1 + sovNode(uint64(m.On0))
	}
	if m.On1 != 0 {
		n += 1 + sovNode(uint64(m.On1))
	}
	if len(m.Emit) > 0 {
		for _, e := range m.Emit {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.InPlaceLeftEmit) > 0 {
		for _, e := range m.InPlaceLeftEmit {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if len(m.InPlaceRightEmit) > 0 {
		for _, e := range m.InPlaceRightEmit {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.Kind != 0 {
		n += 1 + sovNode(uint64(m.Kind))
	}
	return n
}

func (m *Node_InternalJoin_Emission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Left {
		n += 2
	}
	if m.Col != 0 {
		n += 1 + sovNode(uint64(m.Col))
	}
	return n
}

func (m *Node_InternalGrouped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Inner) > 0 {
		for _, e := range m.Inner {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.Cols != 0 {
		n += 1 + sovNode(uint64(m.Cols))
	}
	if len(m.GroupBy) > 0 {
		l = 0
		for _, e := range m.GroupBy {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.OutKey) > 0 {
		l = 0
		for _, e := range m.OutKey {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	if len(m.Colfix) > 0 {
		l = 0
		for _, e := range m.Colfix {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalGrouped_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovNode(uint64(m.Kind))
	}
	if m.Over != 0 {
		n += 1 + sovNode(uint64(m.Over))
	}
	return n
}

func (m *Node_InternalProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Cols != 0 {
		n += 1 + sovNode(uint64(m.Cols))
	}
	if len(m.Projections) > 0 {
		for _, s := range m.Projections {
			l = len(s)
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Filter) > 0 {
		for _, e := range m.Filter {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalFilter_FilterExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovNode(uint64(l))
	}
	if m.Col != 0 {
		n += 1 + sovNode(uint64(m.Col))
	}
	return n
}

func (m *Node_InternalTopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovNode(uint64(l))
		}
	}
	if m.K != 0 {
		n += 1 + sovNode(uint64(m.K))
	}
	if len(m.Params) > 0 {
		l = 0
		for _, e := range m.Params {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalDistinct) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovNode(uint64(l))
	}
	if len(m.Params) > 0 {
		l = 0
		for _, e := range m.Params {
			l += sovNode(uint64(e))
		}
		n += 1 + sovNode(uint64(l)) + l
	}
	return n
}

func (m *Node_Sharder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardBy != 0 {
		n += 1 + sovNode(uint64(m.ShardBy))
	}
	return n
}

func sovNode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNode(x uint64) (n int) {
	return sovNode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Type) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Type: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Type: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field T", wireType)
			}
			m.T = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.T |= vitess_io_vitess_go_sqltypes.Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Collation", wireType)
			}
			m.Collation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Collation |= vitess_io_vitess_go_mysql_collations.ID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nullable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Nullable = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = Value(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			m.Global = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Global |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			m.Local = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Local |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DomainAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DomainAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DomainAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			m.Shard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sharding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sharding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sharding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mode", wireType)
			}
			m.Mode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mode |= Sharding_Mode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multi = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &IndexPair{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v LocalNodeIndex
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LocalNodeIndex(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parents) == 0 {
					m.Parents = make([]LocalNodeIndex, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LocalNodeIndex
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LocalNodeIndex(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		case 7:
			if wireType == 0 {
				var v LocalNodeIndex
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LocalNodeIndex(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]LocalNodeIndex, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LocalNodeIndex
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LocalNodeIndex(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Taken = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purge", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Purge = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &Sharding{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Base", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Base{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Base_{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Ingress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Ingress_{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Egress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Egress_{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Reader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Reader_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Sharder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Sharder_{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalBase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_ExternalBase{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_ExternalBase_{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Union{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Join{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grouped", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalGrouped{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Grouped{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalProject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Project{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Filter{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalTopK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_TopK{v}
			iNdEx = postIndex
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distinct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalDistinct{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Distinct{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Base) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Base: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Base: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryKey = append(m.PrimaryKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryKey) == 0 {
					m.PrimaryKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryKey = append(m.PrimaryKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Dropped = append(m.Dropped, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Dropped) == 0 {
					m.Dropped = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Dropped = append(m.Dropped, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Dropped", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unmodified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unmodified = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_ExternalBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryKey = append(m.PrimaryKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryKey) == 0 {
					m.PrimaryKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryKey = append(m.PrimaryKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Ingress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Reader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForNode", wireType)
			}
			m.ForNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForNode |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.State = append(m.State, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.State) == 0 {
					m.State = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.State = append(m.State, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, ViewParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopkOrder = append(m.TopkOrder, OrderedColumn{})
			if err := m.TopkOrder[len(m.TopkOrder)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkLimit", wireType)
			}
			m.TopkLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopkLimit |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsForView", wireType)
			}
			m.ColumnsForView = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnsForView |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsForUser", wireType)
			}
			m.ColumnsForUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnsForUser |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion_EmitProject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Emit = &Node_InternalUnion_Project{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion_EmitAll{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Emit = &Node_InternalUnion_All{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			m.Required = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Required |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Me", wireType)
			}
			m.Me = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Me |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emit = append(m.Emit, &Node_InternalUnion_EmitProject_EmitTuple{})
			if err := m.Emit[len(m.Emit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmitLeft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EmitLeft = append(m.EmitLeft, &Node_InternalUnion_EmitProject_EmitLeftTuple{})
			if err := m.EmitLeft[len(m.EmitLeft)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cols = append(m.Cols, &Node_InternalUnion_EmitProject_ColumnsTuple{})
			if err := m.Cols[len(m.Cols)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColsLeft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ColsLeft = append(m.ColsLeft, &Node_InternalUnion_EmitProject_ColumnsLeftTuple{})
			if err := m.ColsLeft[len(m.ColsLeft)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &IndexPair{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject_EmitLeftTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitLeftTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitLeftTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject_ColumnsTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnsTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnsTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ip == nil {
				m.Ip = &IndexPair{}
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject_ColumnsLeftTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ColumnsLeftTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ColumnsLeftTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			m.Column = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Column |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitAll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitAll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitAll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &IndexPair{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &Sharding{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &IndexPair{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &IndexPair{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On0", wireType)
			}
			m.On0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.On0 |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On1", wireType)
			}
			m.On1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.On1 |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emit = append(m.Emit, Node_InternalJoin_Emission{})
			if err := m.Emit[len(m.Emit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPlaceLeftEmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InPlaceLeftEmit = append(m.InPlaceLeftEmit, Node_InternalJoin_Emission{})
			if err := m.InPlaceLeftEmit[len(m.InPlaceLeftEmit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPlaceRightEmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InPlaceRightEmit = append(m.InPlaceRightEmit, Node_InternalJoin_Emission{})
			if err := m.InPlaceRightEmit[len(m.InPlaceRightEmit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Node_InternalJoin_JoinType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalJoin_Emission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Emission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Emission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Left = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalGrouped) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalGrouped: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalGrouped: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner, &Node_InternalGrouped_Aggregation{})
			if err := m.Inner[len(m.Inner)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupBy = append(m.GroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupBy) == 0 {
					m.GroupBy = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupBy = append(m.GroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutKey = append(m.OutKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutKey) == 0 {
					m.OutKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutKey = append(m.OutKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutKey", wireType)
			}
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Colfix = append(m.Colfix, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Colfix) == 0 {
					m.Colfix = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Colfix = append(m.Colfix, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Colfix", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalGrouped_Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Node_InternalGrouped_Aggregation_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over", wireType)
			}
			m.Over = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, &Node_InternalFilter_FilterExpr{})
			if err := m.Filter[len(m.Filter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalFilter_FilterExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalTopK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalTopK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalTopK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, OrderedColumn{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Params = append(m.Params, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Params) == 0 {
					m.Params = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Params = append(m.Params, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalDistinct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalDistinct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalDistinct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Params = append(m.Params, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthNode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Params) == 0 {
					m.Params = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowNode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Params = append(m.Params, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Sharder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sharder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sharder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardBy", wireType)
			}
			m.ShardBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardBy |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthNode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNode = fmt.Errorf("proto: unexpected end of group")
)
