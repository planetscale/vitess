// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: packet.proto

package boostpb

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TableOperation_Tag int32

const (
	TableOperation_Insert         TableOperation_Tag = 0
	TableOperation_Delete         TableOperation_Tag = 1
	TableOperation_InsertOrUpdate TableOperation_Tag = 2
	TableOperation_Update         TableOperation_Tag = 3
)

var TableOperation_Tag_name = map[int32]string{
	0: "Insert",
	1: "Delete",
	2: "InsertOrUpdate",
	3: "Update",
}

var TableOperation_Tag_value = map[string]int32{
	"Insert":         0,
	"Delete":         1,
	"InsertOrUpdate": 2,
	"Update":         3,
}

func (x TableOperation_Tag) String() string {
	return proto.EnumName(TableOperation_Tag_name, int32(x))
}

func (TableOperation_Tag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{1, 0}
}

type SourceChannelIdentifier struct {
	Token uint64 `protobuf:"varint,1,opt,name=token,proto3" json:"token,omitempty"`
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Tag   Tag    `protobuf:"varint,3,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
}

func (m *SourceChannelIdentifier) Reset()         { *m = SourceChannelIdentifier{} }
func (m *SourceChannelIdentifier) String() string { return proto.CompactTextString(m) }
func (*SourceChannelIdentifier) ProtoMessage()    {}
func (*SourceChannelIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{0}
}
func (m *SourceChannelIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceChannelIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceChannelIdentifier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceChannelIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceChannelIdentifier.Merge(m, src)
}
func (m *SourceChannelIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *SourceChannelIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceChannelIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_SourceChannelIdentifier proto.InternalMessageInfo

type TableOperation struct {
	Tag TableOperation_Tag `protobuf:"varint,1,opt,name=tag,proto3,enum=packet.TableOperation_Tag" json:"tag,omitempty"`
	Key Row                `protobuf:"bytes,2,opt,name=key,proto3,casttype=Row" json:"key,omitempty"`
}

func (m *TableOperation) Reset()         { *m = TableOperation{} }
func (m *TableOperation) String() string { return proto.CompactTextString(m) }
func (*TableOperation) ProtoMessage()    {}
func (*TableOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{1}
}
func (m *TableOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TableOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TableOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TableOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TableOperation.Merge(m, src)
}
func (m *TableOperation) XXX_Size() int {
	return m.Size()
}
func (m *TableOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_TableOperation.DiscardUnknown(m)
}

var xxx_messageInfo_TableOperation proto.InternalMessageInfo

type FlowInput struct {
	Dst  LocalNodeIndex    `protobuf:"varint,1,opt,name=dst,proto3,casttype=LocalNodeIndex" json:"dst,omitempty"`
	Data []*TableOperation `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *FlowInput) Reset()         { *m = FlowInput{} }
func (m *FlowInput) String() string { return proto.CompactTextString(m) }
func (*FlowInput) ProtoMessage()    {}
func (*FlowInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{2}
}
func (m *FlowInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowInput.Merge(m, src)
}
func (m *FlowInput) XXX_Size() int {
	return m.Size()
}
func (m *FlowInput) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowInput.DiscardUnknown(m)
}

var xxx_messageInfo_FlowInput proto.InternalMessageInfo

type Link struct {
	Src LocalNodeIndex `protobuf:"varint,1,opt,name=src,proto3,casttype=LocalNodeIndex" json:"src,omitempty"`
	Dst LocalNodeIndex `protobuf:"varint,2,opt,name=dst,proto3,casttype=LocalNodeIndex" json:"dst,omitempty"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{3}
}
func (m *Link) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Link.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return m.Size()
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

type ReplayPathSegment struct {
	Node       LocalNodeIndex `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	ForceTagTo Tag            `protobuf:"varint,2,opt,name=force_tag_to,json=forceTagTo,proto3,casttype=Tag" json:"force_tag_to,omitempty"`
	PartialKey []int          `protobuf:"varint,3,rep,packed,name=partial_key,json=partialKey,proto3,casttype=int" json:"partial_key,omitempty"`
}

func (m *ReplayPathSegment) Reset()         { *m = ReplayPathSegment{} }
func (m *ReplayPathSegment) String() string { return proto.CompactTextString(m) }
func (*ReplayPathSegment) ProtoMessage()    {}
func (*ReplayPathSegment) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{4}
}
func (m *ReplayPathSegment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplayPathSegment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplayPathSegment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplayPathSegment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplayPathSegment.Merge(m, src)
}
func (m *ReplayPathSegment) XXX_Size() int {
	return m.Size()
}
func (m *ReplayPathSegment) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplayPathSegment.DiscardUnknown(m)
}

var xxx_messageInfo_ReplayPathSegment proto.InternalMessageInfo

type SourceSelection struct {
	// Types that are valid to be assigned to Selection:
	//	*SourceSelection_KeyShard_
	//	*SourceSelection_SameShard
	//	*SourceSelection_AllShards
	Selection isSourceSelection_Selection `protobuf_oneof:"selection"`
}

func (m *SourceSelection) Reset()         { *m = SourceSelection{} }
func (m *SourceSelection) String() string { return proto.CompactTextString(m) }
func (*SourceSelection) ProtoMessage()    {}
func (*SourceSelection) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{5}
}
func (m *SourceSelection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceSelection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceSelection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceSelection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceSelection.Merge(m, src)
}
func (m *SourceSelection) XXX_Size() int {
	return m.Size()
}
func (m *SourceSelection) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceSelection.DiscardUnknown(m)
}

var xxx_messageInfo_SourceSelection proto.InternalMessageInfo

type isSourceSelection_Selection interface {
	isSourceSelection_Selection()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SourceSelection_KeyShard_ struct {
	KeyShard *SourceSelection_KeyShard `protobuf:"bytes,1,opt,name=key_shard,json=keyShard,proto3,oneof" json:"key_shard,omitempty"`
}
type SourceSelection_SameShard struct {
	SameShard bool `protobuf:"varint,2,opt,name=same_shard,json=sameShard,proto3,oneof" json:"same_shard,omitempty"`
}
type SourceSelection_AllShards struct {
	AllShards uint64 `protobuf:"varint,3,opt,name=all_shards,json=allShards,proto3,oneof" json:"all_shards,omitempty"`
}

func (*SourceSelection_KeyShard_) isSourceSelection_Selection() {}
func (*SourceSelection_SameShard) isSourceSelection_Selection() {}
func (*SourceSelection_AllShards) isSourceSelection_Selection() {}

func (m *SourceSelection) GetSelection() isSourceSelection_Selection {
	if m != nil {
		return m.Selection
	}
	return nil
}

func (m *SourceSelection) GetKeyShard() *SourceSelection_KeyShard {
	if x, ok := m.GetSelection().(*SourceSelection_KeyShard_); ok {
		return x.KeyShard
	}
	return nil
}

func (m *SourceSelection) GetSameShard() bool {
	if x, ok := m.GetSelection().(*SourceSelection_SameShard); ok {
		return x.SameShard
	}
	return false
}

func (m *SourceSelection) GetAllShards() uint64 {
	if x, ok := m.GetSelection().(*SourceSelection_AllShards); ok {
		return x.AllShards
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SourceSelection) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SourceSelection_KeyShard_)(nil),
		(*SourceSelection_SameShard)(nil),
		(*SourceSelection_AllShards)(nil),
	}
}

type SourceSelection_KeyShard struct {
	KeyIToShard int64  `protobuf:"varint,1,opt,name=key_i_to_shard,json=keyIToShard,proto3" json:"key_i_to_shard,omitempty"`
	Nshards     uint64 `protobuf:"varint,2,opt,name=nshards,proto3" json:"nshards,omitempty"`
}

func (m *SourceSelection_KeyShard) Reset()         { *m = SourceSelection_KeyShard{} }
func (m *SourceSelection_KeyShard) String() string { return proto.CompactTextString(m) }
func (*SourceSelection_KeyShard) ProtoMessage()    {}
func (*SourceSelection_KeyShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{5, 0}
}
func (m *SourceSelection_KeyShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceSelection_KeyShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceSelection_KeyShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceSelection_KeyShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceSelection_KeyShard.Merge(m, src)
}
func (m *SourceSelection_KeyShard) XXX_Size() int {
	return m.Size()
}
func (m *SourceSelection_KeyShard) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceSelection_KeyShard.DiscardUnknown(m)
}

var xxx_messageInfo_SourceSelection_KeyShard proto.InternalMessageInfo

type TriggerEndpoint struct {
	// Types that are valid to be assigned to Trigger:
	//	*TriggerEndpoint_Start_
	//	*TriggerEndpoint_End_
	//	*TriggerEndpoint_Local_
	Trigger isTriggerEndpoint_Trigger `protobuf_oneof:"trigger"`
}

func (m *TriggerEndpoint) Reset()         { *m = TriggerEndpoint{} }
func (m *TriggerEndpoint) String() string { return proto.CompactTextString(m) }
func (*TriggerEndpoint) ProtoMessage()    {}
func (*TriggerEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6}
}
func (m *TriggerEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEndpoint.Merge(m, src)
}
func (m *TriggerEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEndpoint proto.InternalMessageInfo

type isTriggerEndpoint_Trigger interface {
	isTriggerEndpoint_Trigger()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TriggerEndpoint_Start_ struct {
	Start *TriggerEndpoint_Start `protobuf:"bytes,2,opt,name=start,proto3,oneof" json:"start,omitempty"`
}
type TriggerEndpoint_End_ struct {
	End *TriggerEndpoint_End `protobuf:"bytes,3,opt,name=end,proto3,oneof" json:"end,omitempty"`
}
type TriggerEndpoint_Local_ struct {
	Local *TriggerEndpoint_Local `protobuf:"bytes,4,opt,name=local,proto3,oneof" json:"local,omitempty"`
}

func (*TriggerEndpoint_Start_) isTriggerEndpoint_Trigger() {}
func (*TriggerEndpoint_End_) isTriggerEndpoint_Trigger()   {}
func (*TriggerEndpoint_Local_) isTriggerEndpoint_Trigger() {}

func (m *TriggerEndpoint) GetTrigger() isTriggerEndpoint_Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *TriggerEndpoint) GetStart() *TriggerEndpoint_Start {
	if x, ok := m.GetTrigger().(*TriggerEndpoint_Start_); ok {
		return x.Start
	}
	return nil
}

func (m *TriggerEndpoint) GetEnd() *TriggerEndpoint_End {
	if x, ok := m.GetTrigger().(*TriggerEndpoint_End_); ok {
		return x.End
	}
	return nil
}

func (m *TriggerEndpoint) GetLocal() *TriggerEndpoint_Local {
	if x, ok := m.GetTrigger().(*TriggerEndpoint_Local_); ok {
		return x.Local
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TriggerEndpoint) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TriggerEndpoint_Start_)(nil),
		(*TriggerEndpoint_End_)(nil),
		(*TriggerEndpoint_Local_)(nil),
	}
}

type TriggerEndpoint_Start struct {
	Cols []int `protobuf:"varint,1,rep,packed,name=cols,proto3,casttype=int" json:"cols,omitempty"`
}

func (m *TriggerEndpoint_Start) Reset()         { *m = TriggerEndpoint_Start{} }
func (m *TriggerEndpoint_Start) String() string { return proto.CompactTextString(m) }
func (*TriggerEndpoint_Start) ProtoMessage()    {}
func (*TriggerEndpoint_Start) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6, 0}
}
func (m *TriggerEndpoint_Start) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEndpoint_Start) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerEndpoint_Start.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerEndpoint_Start) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEndpoint_Start.Merge(m, src)
}
func (m *TriggerEndpoint_Start) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEndpoint_Start) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEndpoint_Start.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEndpoint_Start proto.InternalMessageInfo

type TriggerEndpoint_End struct {
	Selection *SourceSelection `protobuf:"bytes,1,opt,name=selection,proto3" json:"selection,omitempty"`
	Domain    DomainIndex      `protobuf:"varint,2,opt,name=domain,proto3,casttype=DomainIndex" json:"domain,omitempty"`
}

func (m *TriggerEndpoint_End) Reset()         { *m = TriggerEndpoint_End{} }
func (m *TriggerEndpoint_End) String() string { return proto.CompactTextString(m) }
func (*TriggerEndpoint_End) ProtoMessage()    {}
func (*TriggerEndpoint_End) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6, 1}
}
func (m *TriggerEndpoint_End) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEndpoint_End) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerEndpoint_End.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerEndpoint_End) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEndpoint_End.Merge(m, src)
}
func (m *TriggerEndpoint_End) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEndpoint_End) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEndpoint_End.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEndpoint_End proto.InternalMessageInfo

type TriggerEndpoint_Local struct {
	Cols []int `protobuf:"varint,1,rep,packed,name=cols,proto3,casttype=int" json:"cols,omitempty"`
}

func (m *TriggerEndpoint_Local) Reset()         { *m = TriggerEndpoint_Local{} }
func (m *TriggerEndpoint_Local) String() string { return proto.CompactTextString(m) }
func (*TriggerEndpoint_Local) ProtoMessage()    {}
func (*TriggerEndpoint_Local) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{6, 2}
}
func (m *TriggerEndpoint_Local) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TriggerEndpoint_Local) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TriggerEndpoint_Local.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TriggerEndpoint_Local) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TriggerEndpoint_Local.Merge(m, src)
}
func (m *TriggerEndpoint_Local) XXX_Size() int {
	return m.Size()
}
func (m *TriggerEndpoint_Local) XXX_DiscardUnknown() {
	xxx_messageInfo_TriggerEndpoint_Local.DiscardUnknown(m)
}

var xxx_messageInfo_TriggerEndpoint_Local proto.InternalMessageInfo

type Record struct {
	Row      Row  `protobuf:"bytes,1,opt,name=row,proto3,casttype=Row" json:"row,omitempty"`
	Positive bool `protobuf:"varint,2,opt,name=positive,proto3" json:"positive,omitempty"`
}

func (m *Record) Reset()         { *m = Record{} }
func (m *Record) String() string { return proto.CompactTextString(m) }
func (*Record) ProtoMessage()    {}
func (*Record) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{7}
}
func (m *Record) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Record) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Record.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Record) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Record.Merge(m, src)
}
func (m *Record) XXX_Size() int {
	return m.Size()
}
func (m *Record) XXX_DiscardUnknown() {
	xxx_messageInfo_Record.DiscardUnknown(m)
}

var xxx_messageInfo_Record proto.InternalMessageInfo

type SyncPacket struct {
	// Types that are valid to be assigned to Inner:
	//	*SyncPacket_SetupReplayPath_
	//	*SyncPacket_Ready_
	//	*SyncPacket_WaitForReplay
	//	*SyncPacket_AddBaseColumn_
	//	*SyncPacket_DropBaseColumn_
	Inner isSyncPacket_Inner `protobuf_oneof:"inner"`
}

func (m *SyncPacket) Reset()         { *m = SyncPacket{} }
func (m *SyncPacket) String() string { return proto.CompactTextString(m) }
func (*SyncPacket) ProtoMessage()    {}
func (*SyncPacket) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8}
}
func (m *SyncPacket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket.Merge(m, src)
}
func (m *SyncPacket) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket proto.InternalMessageInfo

type isSyncPacket_Inner interface {
	isSyncPacket_Inner()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SyncPacket_SetupReplayPath_ struct {
	SetupReplayPath *SyncPacket_SetupReplayPath `protobuf:"bytes,1,opt,name=setup_replay_path,json=setupReplayPath,proto3,oneof" json:"setup_replay_path,omitempty"`
}
type SyncPacket_Ready_ struct {
	Ready *SyncPacket_Ready `protobuf:"bytes,2,opt,name=ready,proto3,oneof" json:"ready,omitempty"`
}
type SyncPacket_WaitForReplay struct {
	WaitForReplay bool `protobuf:"varint,3,opt,name=wait_for_replay,json=waitForReplay,proto3,oneof" json:"wait_for_replay,omitempty"`
}
type SyncPacket_AddBaseColumn_ struct {
	AddBaseColumn *SyncPacket_AddBaseColumn `protobuf:"bytes,10,opt,name=add_base_column,json=addBaseColumn,proto3,oneof" json:"add_base_column,omitempty"`
}
type SyncPacket_DropBaseColumn_ struct {
	DropBaseColumn *SyncPacket_DropBaseColumn `protobuf:"bytes,11,opt,name=drop_base_column,json=dropBaseColumn,proto3,oneof" json:"drop_base_column,omitempty"`
}

func (*SyncPacket_SetupReplayPath_) isSyncPacket_Inner() {}
func (*SyncPacket_Ready_) isSyncPacket_Inner()           {}
func (*SyncPacket_WaitForReplay) isSyncPacket_Inner()    {}
func (*SyncPacket_AddBaseColumn_) isSyncPacket_Inner()   {}
func (*SyncPacket_DropBaseColumn_) isSyncPacket_Inner()  {}

func (m *SyncPacket) GetInner() isSyncPacket_Inner {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *SyncPacket) GetSetupReplayPath() *SyncPacket_SetupReplayPath {
	if x, ok := m.GetInner().(*SyncPacket_SetupReplayPath_); ok {
		return x.SetupReplayPath
	}
	return nil
}

func (m *SyncPacket) GetReady() *SyncPacket_Ready {
	if x, ok := m.GetInner().(*SyncPacket_Ready_); ok {
		return x.Ready
	}
	return nil
}

func (m *SyncPacket) GetWaitForReplay() bool {
	if x, ok := m.GetInner().(*SyncPacket_WaitForReplay); ok {
		return x.WaitForReplay
	}
	return false
}

func (m *SyncPacket) GetAddBaseColumn() *SyncPacket_AddBaseColumn {
	if x, ok := m.GetInner().(*SyncPacket_AddBaseColumn_); ok {
		return x.AddBaseColumn
	}
	return nil
}

func (m *SyncPacket) GetDropBaseColumn() *SyncPacket_DropBaseColumn {
	if x, ok := m.GetInner().(*SyncPacket_DropBaseColumn_); ok {
		return x.DropBaseColumn
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SyncPacket) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SyncPacket_SetupReplayPath_)(nil),
		(*SyncPacket_Ready_)(nil),
		(*SyncPacket_WaitForReplay)(nil),
		(*SyncPacket_AddBaseColumn_)(nil),
		(*SyncPacket_DropBaseColumn_)(nil),
	}
}

type SyncPacket_SetupReplayPath struct {
	Tag                   Tag                  `protobuf:"varint,1,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Source                LocalNodeIndex       `protobuf:"varint,2,opt,name=source,proto3,casttype=LocalNodeIndex" json:"source,omitempty"`
	Path                  []*ReplayPathSegment `protobuf:"bytes,3,rep,name=path,proto3" json:"path,omitempty"`
	PartialUnicastSharder GraphNodeIdx         `protobuf:"varint,4,opt,name=partial_unicast_sharder,json=partialUnicastSharder,proto3,casttype=GraphNodeIdx" json:"partial_unicast_sharder,omitempty"`
	NotifyDone            bool                 `protobuf:"varint,5,opt,name=notify_done,json=notifyDone,proto3" json:"notify_done,omitempty"`
	Trigger               *TriggerEndpoint     `protobuf:"bytes,6,opt,name=trigger,proto3" json:"trigger,omitempty"`
}

func (m *SyncPacket_SetupReplayPath) Reset()         { *m = SyncPacket_SetupReplayPath{} }
func (m *SyncPacket_SetupReplayPath) String() string { return proto.CompactTextString(m) }
func (*SyncPacket_SetupReplayPath) ProtoMessage()    {}
func (*SyncPacket_SetupReplayPath) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8, 0}
}
func (m *SyncPacket_SetupReplayPath) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket_SetupReplayPath) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket_SetupReplayPath.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket_SetupReplayPath) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket_SetupReplayPath.Merge(m, src)
}
func (m *SyncPacket_SetupReplayPath) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket_SetupReplayPath) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket_SetupReplayPath.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket_SetupReplayPath proto.InternalMessageInfo

type SyncPacket_Ready struct {
	Node  LocalNodeIndex            `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	Index []*SyncPacket_Ready_Index `protobuf:"bytes,3,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *SyncPacket_Ready) Reset()         { *m = SyncPacket_Ready{} }
func (m *SyncPacket_Ready) String() string { return proto.CompactTextString(m) }
func (*SyncPacket_Ready) ProtoMessage()    {}
func (*SyncPacket_Ready) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8, 1}
}
func (m *SyncPacket_Ready) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket_Ready) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket_Ready.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket_Ready) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket_Ready.Merge(m, src)
}
func (m *SyncPacket_Ready) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket_Ready) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket_Ready.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket_Ready proto.InternalMessageInfo

type SyncPacket_Ready_Index struct {
	Key []int `protobuf:"varint,1,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
}

func (m *SyncPacket_Ready_Index) Reset()         { *m = SyncPacket_Ready_Index{} }
func (m *SyncPacket_Ready_Index) String() string { return proto.CompactTextString(m) }
func (*SyncPacket_Ready_Index) ProtoMessage()    {}
func (*SyncPacket_Ready_Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8, 1, 0}
}
func (m *SyncPacket_Ready_Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket_Ready_Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket_Ready_Index.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket_Ready_Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket_Ready_Index.Merge(m, src)
}
func (m *SyncPacket_Ready_Index) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket_Ready_Index) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket_Ready_Index.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket_Ready_Index proto.InternalMessageInfo

type SyncPacket_AddBaseColumn struct {
}

func (m *SyncPacket_AddBaseColumn) Reset()         { *m = SyncPacket_AddBaseColumn{} }
func (m *SyncPacket_AddBaseColumn) String() string { return proto.CompactTextString(m) }
func (*SyncPacket_AddBaseColumn) ProtoMessage()    {}
func (*SyncPacket_AddBaseColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8, 2}
}
func (m *SyncPacket_AddBaseColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket_AddBaseColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket_AddBaseColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket_AddBaseColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket_AddBaseColumn.Merge(m, src)
}
func (m *SyncPacket_AddBaseColumn) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket_AddBaseColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket_AddBaseColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket_AddBaseColumn proto.InternalMessageInfo

type SyncPacket_DropBaseColumn struct {
}

func (m *SyncPacket_DropBaseColumn) Reset()         { *m = SyncPacket_DropBaseColumn{} }
func (m *SyncPacket_DropBaseColumn) String() string { return proto.CompactTextString(m) }
func (*SyncPacket_DropBaseColumn) ProtoMessage()    {}
func (*SyncPacket_DropBaseColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{8, 3}
}
func (m *SyncPacket_DropBaseColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncPacket_DropBaseColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncPacket_DropBaseColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncPacket_DropBaseColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncPacket_DropBaseColumn.Merge(m, src)
}
func (m *SyncPacket_DropBaseColumn) XXX_Size() int {
	return m.Size()
}
func (m *SyncPacket_DropBaseColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncPacket_DropBaseColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SyncPacket_DropBaseColumn proto.InternalMessageInfo

type Packet struct {
	// Types that are valid to be assigned to Inner:
	//	*Packet_Input_
	//	*Packet_Message_
	//	*Packet_Vstream_
	//	*Packet_ReplayPiece_
	//	*Packet_Evict_
	//	*Packet_EvictKeys_
	//	*Packet_RequestPartialReplay_
	//	*Packet_RequestReaderReplay_
	//	*Packet_StartReplay_
	//	*Packet_AddNode_
	//	*Packet_Finish_
	//	*Packet_RemoveNodes_
	//	*Packet_UpdateEgress_
	//	*Packet_UpdateSharder_
	//	*Packet_PrepareState_
	Inner isPacket_Inner `protobuf_oneof:"inner"`
	// Packet ID for tracing.
	Id int32 `protobuf:"varint,33,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Packet) Reset()         { *m = Packet{} }
func (m *Packet) String() string { return proto.CompactTextString(m) }
func (*Packet) ProtoMessage()    {}
func (*Packet) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9}
}
func (m *Packet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet.Merge(m, src)
}
func (m *Packet) XXX_Size() int {
	return m.Size()
}
func (m *Packet) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet.DiscardUnknown(m)
}

var xxx_messageInfo_Packet proto.InternalMessageInfo

type isPacket_Inner interface {
	isPacket_Inner()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Packet_Input_ struct {
	Input *Packet_Input `protobuf:"bytes,1,opt,name=input,proto3,oneof" json:"input,omitempty"`
}
type Packet_Message_ struct {
	Message *Packet_Message `protobuf:"bytes,2,opt,name=message,proto3,oneof" json:"message,omitempty"`
}
type Packet_Vstream_ struct {
	Vstream *Packet_Vstream `protobuf:"bytes,3,opt,name=vstream,proto3,oneof" json:"vstream,omitempty"`
}
type Packet_ReplayPiece_ struct {
	ReplayPiece *Packet_ReplayPiece `protobuf:"bytes,4,opt,name=replay_piece,json=replayPiece,proto3,oneof" json:"replay_piece,omitempty"`
}
type Packet_Evict_ struct {
	Evict *Packet_Evict `protobuf:"bytes,5,opt,name=evict,proto3,oneof" json:"evict,omitempty"`
}
type Packet_EvictKeys_ struct {
	EvictKeys *Packet_EvictKeys `protobuf:"bytes,6,opt,name=evict_keys,json=evictKeys,proto3,oneof" json:"evict_keys,omitempty"`
}
type Packet_RequestPartialReplay_ struct {
	RequestPartialReplay *Packet_RequestPartialReplay `protobuf:"bytes,10,opt,name=request_partial_replay,json=requestPartialReplay,proto3,oneof" json:"request_partial_replay,omitempty"`
}
type Packet_RequestReaderReplay_ struct {
	RequestReaderReplay *Packet_RequestReaderReplay `protobuf:"bytes,11,opt,name=request_reader_replay,json=requestReaderReplay,proto3,oneof" json:"request_reader_replay,omitempty"`
}
type Packet_StartReplay_ struct {
	StartReplay *Packet_StartReplay `protobuf:"bytes,12,opt,name=start_replay,json=startReplay,proto3,oneof" json:"start_replay,omitempty"`
}
type Packet_AddNode_ struct {
	AddNode *Packet_AddNode `protobuf:"bytes,20,opt,name=add_node,json=addNode,proto3,oneof" json:"add_node,omitempty"`
}
type Packet_Finish_ struct {
	Finish *Packet_Finish `protobuf:"bytes,21,opt,name=finish,proto3,oneof" json:"finish,omitempty"`
}
type Packet_RemoveNodes_ struct {
	RemoveNodes *Packet_RemoveNodes `protobuf:"bytes,22,opt,name=remove_nodes,json=removeNodes,proto3,oneof" json:"remove_nodes,omitempty"`
}
type Packet_UpdateEgress_ struct {
	UpdateEgress *Packet_UpdateEgress `protobuf:"bytes,23,opt,name=update_egress,json=updateEgress,proto3,oneof" json:"update_egress,omitempty"`
}
type Packet_UpdateSharder_ struct {
	UpdateSharder *Packet_UpdateSharder `protobuf:"bytes,24,opt,name=update_sharder,json=updateSharder,proto3,oneof" json:"update_sharder,omitempty"`
}
type Packet_PrepareState_ struct {
	PrepareState *Packet_PrepareState `protobuf:"bytes,25,opt,name=prepare_state,json=prepareState,proto3,oneof" json:"prepare_state,omitempty"`
}

func (*Packet_Input_) isPacket_Inner()                {}
func (*Packet_Message_) isPacket_Inner()              {}
func (*Packet_Vstream_) isPacket_Inner()              {}
func (*Packet_ReplayPiece_) isPacket_Inner()          {}
func (*Packet_Evict_) isPacket_Inner()                {}
func (*Packet_EvictKeys_) isPacket_Inner()            {}
func (*Packet_RequestPartialReplay_) isPacket_Inner() {}
func (*Packet_RequestReaderReplay_) isPacket_Inner()  {}
func (*Packet_StartReplay_) isPacket_Inner()          {}
func (*Packet_AddNode_) isPacket_Inner()              {}
func (*Packet_Finish_) isPacket_Inner()               {}
func (*Packet_RemoveNodes_) isPacket_Inner()          {}
func (*Packet_UpdateEgress_) isPacket_Inner()         {}
func (*Packet_UpdateSharder_) isPacket_Inner()        {}
func (*Packet_PrepareState_) isPacket_Inner()         {}

func (m *Packet) GetInner() isPacket_Inner {
	if m != nil {
		return m.Inner
	}
	return nil
}

func (m *Packet) GetInput() *Packet_Input {
	if x, ok := m.GetInner().(*Packet_Input_); ok {
		return x.Input
	}
	return nil
}

func (m *Packet) GetMessage() *Packet_Message {
	if x, ok := m.GetInner().(*Packet_Message_); ok {
		return x.Message
	}
	return nil
}

func (m *Packet) GetVstream() *Packet_Vstream {
	if x, ok := m.GetInner().(*Packet_Vstream_); ok {
		return x.Vstream
	}
	return nil
}

func (m *Packet) GetReplayPiece() *Packet_ReplayPiece {
	if x, ok := m.GetInner().(*Packet_ReplayPiece_); ok {
		return x.ReplayPiece
	}
	return nil
}

func (m *Packet) GetEvict() *Packet_Evict {
	if x, ok := m.GetInner().(*Packet_Evict_); ok {
		return x.Evict
	}
	return nil
}

func (m *Packet) GetEvictKeys() *Packet_EvictKeys {
	if x, ok := m.GetInner().(*Packet_EvictKeys_); ok {
		return x.EvictKeys
	}
	return nil
}

func (m *Packet) GetRequestPartialReplay() *Packet_RequestPartialReplay {
	if x, ok := m.GetInner().(*Packet_RequestPartialReplay_); ok {
		return x.RequestPartialReplay
	}
	return nil
}

func (m *Packet) GetRequestReaderReplay() *Packet_RequestReaderReplay {
	if x, ok := m.GetInner().(*Packet_RequestReaderReplay_); ok {
		return x.RequestReaderReplay
	}
	return nil
}

func (m *Packet) GetStartReplay() *Packet_StartReplay {
	if x, ok := m.GetInner().(*Packet_StartReplay_); ok {
		return x.StartReplay
	}
	return nil
}

func (m *Packet) GetAddNode() *Packet_AddNode {
	if x, ok := m.GetInner().(*Packet_AddNode_); ok {
		return x.AddNode
	}
	return nil
}

func (m *Packet) GetFinish() *Packet_Finish {
	if x, ok := m.GetInner().(*Packet_Finish_); ok {
		return x.Finish
	}
	return nil
}

func (m *Packet) GetRemoveNodes() *Packet_RemoveNodes {
	if x, ok := m.GetInner().(*Packet_RemoveNodes_); ok {
		return x.RemoveNodes
	}
	return nil
}

func (m *Packet) GetUpdateEgress() *Packet_UpdateEgress {
	if x, ok := m.GetInner().(*Packet_UpdateEgress_); ok {
		return x.UpdateEgress
	}
	return nil
}

func (m *Packet) GetUpdateSharder() *Packet_UpdateSharder {
	if x, ok := m.GetInner().(*Packet_UpdateSharder_); ok {
		return x.UpdateSharder
	}
	return nil
}

func (m *Packet) GetPrepareState() *Packet_PrepareState {
	if x, ok := m.GetInner().(*Packet_PrepareState_); ok {
		return x.PrepareState
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Packet) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Packet_Input_)(nil),
		(*Packet_Message_)(nil),
		(*Packet_Vstream_)(nil),
		(*Packet_ReplayPiece_)(nil),
		(*Packet_Evict_)(nil),
		(*Packet_EvictKeys_)(nil),
		(*Packet_RequestPartialReplay_)(nil),
		(*Packet_RequestReaderReplay_)(nil),
		(*Packet_StartReplay_)(nil),
		(*Packet_AddNode_)(nil),
		(*Packet_Finish_)(nil),
		(*Packet_RemoveNodes_)(nil),
		(*Packet_UpdateEgress_)(nil),
		(*Packet_UpdateSharder_)(nil),
		(*Packet_PrepareState_)(nil),
	}
}

type Packet_Input struct {
	Inner   *FlowInput                 `protobuf:"bytes,1,opt,name=inner,proto3" json:"inner,omitempty"`
	Src     *SourceChannelIdentifier   `protobuf:"bytes,2,opt,name=src,proto3" json:"src,omitempty"`
	Senders []*SourceChannelIdentifier `protobuf:"bytes,3,rep,name=senders,proto3" json:"senders,omitempty"`
}

func (m *Packet_Input) Reset()         { *m = Packet_Input{} }
func (m *Packet_Input) String() string { return proto.CompactTextString(m) }
func (*Packet_Input) ProtoMessage()    {}
func (*Packet_Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 0}
}
func (m *Packet_Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_Input.Merge(m, src)
}
func (m *Packet_Input) XXX_Size() int {
	return m.Size()
}
func (m *Packet_Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_Input proto.InternalMessageInfo

type Packet_Message struct {
	Link    *Link    `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Records []Record `protobuf:"bytes,2,rep,name=records,proto3" json:"records"`
	Ignored bool     `protobuf:"varint,3,opt,name=ignored,proto3" json:"ignored,omitempty"`
}

func (m *Packet_Message) Reset()         { *m = Packet_Message{} }
func (m *Packet_Message) String() string { return proto.CompactTextString(m) }
func (*Packet_Message) ProtoMessage()    {}
func (*Packet_Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 1}
}
func (m *Packet_Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_Message.Merge(m, src)
}
func (m *Packet_Message) XXX_Size() int {
	return m.Size()
}
func (m *Packet_Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_Message proto.InternalMessageInfo

type Packet_Vstream struct {
	Link   *Link   `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Before *Record `protobuf:"bytes,2,opt,name=before,proto3" json:"before,omitempty"`
	After  *Record `protobuf:"bytes,3,opt,name=after,proto3" json:"after,omitempty"`
	Gtid   string  `protobuf:"bytes,4,opt,name=gtid,proto3" json:"gtid,omitempty"`
}

func (m *Packet_Vstream) Reset()         { *m = Packet_Vstream{} }
func (m *Packet_Vstream) String() string { return proto.CompactTextString(m) }
func (*Packet_Vstream) ProtoMessage()    {}
func (*Packet_Vstream) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 2}
}
func (m *Packet_Vstream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_Vstream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_Vstream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_Vstream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_Vstream.Merge(m, src)
}
func (m *Packet_Vstream) XXX_Size() int {
	return m.Size()
}
func (m *Packet_Vstream) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_Vstream.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_Vstream proto.InternalMessageInfo

type Packet_ReplayPiece struct {
	Link    *Link    `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Tag     Tag      `protobuf:"varint,2,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Records []Record `protobuf:"bytes,3,rep,name=records,proto3" json:"records"`
	// Types that are valid to be assigned to Context:
	//	*Packet_ReplayPiece_Partial
	//	*Packet_ReplayPiece_Regular
	//	*Packet_ReplayPiece_Failed
	Context     isPacket_ReplayPiece_Context `protobuf_oneof:"context"`
	Gtid        string                       `protobuf:"bytes,10,opt,name=gtid,proto3" json:"gtid,omitempty"`
	UpquerySlot uint32                       `protobuf:"varint,11,opt,name=upquery_slot,json=upquerySlot,proto3" json:"upquery_slot,omitempty"`
}

func (m *Packet_ReplayPiece) Reset()         { *m = Packet_ReplayPiece{} }
func (m *Packet_ReplayPiece) String() string { return proto.CompactTextString(m) }
func (*Packet_ReplayPiece) ProtoMessage()    {}
func (*Packet_ReplayPiece) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 3}
}
func (m *Packet_ReplayPiece) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_ReplayPiece) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_ReplayPiece.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_ReplayPiece) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_ReplayPiece.Merge(m, src)
}
func (m *Packet_ReplayPiece) XXX_Size() int {
	return m.Size()
}
func (m *Packet_ReplayPiece) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_ReplayPiece.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_ReplayPiece proto.InternalMessageInfo

type isPacket_ReplayPiece_Context interface {
	isPacket_ReplayPiece_Context()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Packet_ReplayPiece_Partial struct {
	Partial *Packet_ReplayPiece_ContextPartial `protobuf:"bytes,4,opt,name=partial,proto3,oneof" json:"partial,omitempty"`
}
type Packet_ReplayPiece_Regular struct {
	Regular *Packet_ReplayPiece_ContextRegular `protobuf:"bytes,5,opt,name=regular,proto3,oneof" json:"regular,omitempty"`
}
type Packet_ReplayPiece_Failed struct {
	Failed string `protobuf:"bytes,7,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}

func (*Packet_ReplayPiece_Partial) isPacket_ReplayPiece_Context() {}
func (*Packet_ReplayPiece_Regular) isPacket_ReplayPiece_Context() {}
func (*Packet_ReplayPiece_Failed) isPacket_ReplayPiece_Context()  {}

func (m *Packet_ReplayPiece) GetContext() isPacket_ReplayPiece_Context {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Packet_ReplayPiece) GetPartial() *Packet_ReplayPiece_ContextPartial {
	if x, ok := m.GetContext().(*Packet_ReplayPiece_Partial); ok {
		return x.Partial
	}
	return nil
}

func (m *Packet_ReplayPiece) GetRegular() *Packet_ReplayPiece_ContextRegular {
	if x, ok := m.GetContext().(*Packet_ReplayPiece_Regular); ok {
		return x.Regular
	}
	return nil
}

func (m *Packet_ReplayPiece) GetFailed() string {
	if x, ok := m.GetContext().(*Packet_ReplayPiece_Failed); ok {
		return x.Failed
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Packet_ReplayPiece) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Packet_ReplayPiece_Partial)(nil),
		(*Packet_ReplayPiece_Regular)(nil),
		(*Packet_ReplayPiece_Failed)(nil),
	}
}

type Packet_ReplayPiece_ContextPartial struct {
	ForKeys         map[Row]bool `protobuf:"bytes,1,rep,name=for_keys,json=forKeys,proto3,castkey=Row" json:"for_keys,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RequestingShard uint         `protobuf:"varint,2,opt,name=requesting_shard,json=requestingShard,proto3,casttype=uint" json:"requesting_shard,omitempty"`
	Unishard        bool         `protobuf:"varint,3,opt,name=unishard,proto3" json:"unishard,omitempty"`
	Ignore          bool         `protobuf:"varint,4,opt,name=ignore,proto3" json:"ignore,omitempty"`
}

func (m *Packet_ReplayPiece_ContextPartial) Reset()         { *m = Packet_ReplayPiece_ContextPartial{} }
func (m *Packet_ReplayPiece_ContextPartial) String() string { return proto.CompactTextString(m) }
func (*Packet_ReplayPiece_ContextPartial) ProtoMessage()    {}
func (*Packet_ReplayPiece_ContextPartial) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 3, 0}
}
func (m *Packet_ReplayPiece_ContextPartial) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_ReplayPiece_ContextPartial) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_ReplayPiece_ContextPartial.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_ReplayPiece_ContextPartial) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_ReplayPiece_ContextPartial.Merge(m, src)
}
func (m *Packet_ReplayPiece_ContextPartial) XXX_Size() int {
	return m.Size()
}
func (m *Packet_ReplayPiece_ContextPartial) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_ReplayPiece_ContextPartial.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_ReplayPiece_ContextPartial proto.InternalMessageInfo

type Packet_ReplayPiece_ContextRegular struct {
	Last bool `protobuf:"varint,1,opt,name=last,proto3" json:"last,omitempty"`
}

func (m *Packet_ReplayPiece_ContextRegular) Reset()         { *m = Packet_ReplayPiece_ContextRegular{} }
func (m *Packet_ReplayPiece_ContextRegular) String() string { return proto.CompactTextString(m) }
func (*Packet_ReplayPiece_ContextRegular) ProtoMessage()    {}
func (*Packet_ReplayPiece_ContextRegular) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 3, 1}
}
func (m *Packet_ReplayPiece_ContextRegular) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_ReplayPiece_ContextRegular) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_ReplayPiece_ContextRegular.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_ReplayPiece_ContextRegular) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_ReplayPiece_ContextRegular.Merge(m, src)
}
func (m *Packet_ReplayPiece_ContextRegular) XXX_Size() int {
	return m.Size()
}
func (m *Packet_ReplayPiece_ContextRegular) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_ReplayPiece_ContextRegular.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_ReplayPiece_ContextRegular proto.InternalMessageInfo

type Packet_Evict struct {
	Node     LocalNodeIndex `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	NumBytes int64          `protobuf:"varint,2,opt,name=num_bytes,json=numBytes,proto3" json:"num_bytes,omitempty"`
}

func (m *Packet_Evict) Reset()         { *m = Packet_Evict{} }
func (m *Packet_Evict) String() string { return proto.CompactTextString(m) }
func (*Packet_Evict) ProtoMessage()    {}
func (*Packet_Evict) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 4}
}
func (m *Packet_Evict) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_Evict) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_Evict.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_Evict) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_Evict.Merge(m, src)
}
func (m *Packet_Evict) XXX_Size() int {
	return m.Size()
}
func (m *Packet_Evict) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_Evict.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_Evict proto.InternalMessageInfo

type Packet_EvictKeys struct {
	Link *Link `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	Tag  Tag   `protobuf:"varint,2,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Keys []Row `protobuf:"bytes,3,rep,name=keys,proto3,casttype=Row" json:"keys,omitempty"`
}

func (m *Packet_EvictKeys) Reset()         { *m = Packet_EvictKeys{} }
func (m *Packet_EvictKeys) String() string { return proto.CompactTextString(m) }
func (*Packet_EvictKeys) ProtoMessage()    {}
func (*Packet_EvictKeys) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 5}
}
func (m *Packet_EvictKeys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_EvictKeys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_EvictKeys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_EvictKeys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_EvictKeys.Merge(m, src)
}
func (m *Packet_EvictKeys) XXX_Size() int {
	return m.Size()
}
func (m *Packet_EvictKeys) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_EvictKeys.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_EvictKeys proto.InternalMessageInfo

type Packet_Finish struct {
	Tag  Tag            `protobuf:"varint,1,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Node LocalNodeIndex `protobuf:"varint,2,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
}

func (m *Packet_Finish) Reset()         { *m = Packet_Finish{} }
func (m *Packet_Finish) String() string { return proto.CompactTextString(m) }
func (*Packet_Finish) ProtoMessage()    {}
func (*Packet_Finish) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 6}
}
func (m *Packet_Finish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_Finish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_Finish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_Finish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_Finish.Merge(m, src)
}
func (m *Packet_Finish) XXX_Size() int {
	return m.Size()
}
func (m *Packet_Finish) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_Finish.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_Finish proto.InternalMessageInfo

type Packet_AddNode struct {
	Node    *Node            `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	Parents []LocalNodeIndex `protobuf:"varint,2,rep,packed,name=parents,proto3,casttype=LocalNodeIndex" json:"parents,omitempty"`
}

func (m *Packet_AddNode) Reset()         { *m = Packet_AddNode{} }
func (m *Packet_AddNode) String() string { return proto.CompactTextString(m) }
func (*Packet_AddNode) ProtoMessage()    {}
func (*Packet_AddNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 7}
}
func (m *Packet_AddNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_AddNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_AddNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_AddNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_AddNode.Merge(m, src)
}
func (m *Packet_AddNode) XXX_Size() int {
	return m.Size()
}
func (m *Packet_AddNode) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_AddNode.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_AddNode proto.InternalMessageInfo

type Packet_RemoveNodes struct {
	Nodes []LocalNodeIndex `protobuf:"varint,1,rep,packed,name=nodes,proto3,casttype=LocalNodeIndex" json:"nodes,omitempty"`
}

func (m *Packet_RemoveNodes) Reset()         { *m = Packet_RemoveNodes{} }
func (m *Packet_RemoveNodes) String() string { return proto.CompactTextString(m) }
func (*Packet_RemoveNodes) ProtoMessage()    {}
func (*Packet_RemoveNodes) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 8}
}
func (m *Packet_RemoveNodes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_RemoveNodes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_RemoveNodes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_RemoveNodes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_RemoveNodes.Merge(m, src)
}
func (m *Packet_RemoveNodes) XXX_Size() int {
	return m.Size()
}
func (m *Packet_RemoveNodes) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_RemoveNodes.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_RemoveNodes proto.InternalMessageInfo

type Packet_UpdateEgress struct {
	Node   LocalNodeIndex           `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	NewTx  *Packet_UpdateEgress_Tx  `protobuf:"bytes,2,opt,name=new_tx,json=newTx,proto3" json:"new_tx,omitempty"`
	NewTag *Packet_UpdateEgress_Tag `protobuf:"bytes,3,opt,name=new_tag,json=newTag,proto3" json:"new_tag,omitempty"`
}

func (m *Packet_UpdateEgress) Reset()         { *m = Packet_UpdateEgress{} }
func (m *Packet_UpdateEgress) String() string { return proto.CompactTextString(m) }
func (*Packet_UpdateEgress) ProtoMessage()    {}
func (*Packet_UpdateEgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 9}
}
func (m *Packet_UpdateEgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_UpdateEgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_UpdateEgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_UpdateEgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_UpdateEgress.Merge(m, src)
}
func (m *Packet_UpdateEgress) XXX_Size() int {
	return m.Size()
}
func (m *Packet_UpdateEgress) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_UpdateEgress.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_UpdateEgress proto.InternalMessageInfo

type Packet_UpdateEgress_Tx struct {
	Node   uint32      `protobuf:"varint,1,opt,name=node,proto3" json:"node,omitempty"`
	Local  uint32      `protobuf:"varint,2,opt,name=local,proto3" json:"local,omitempty"`
	Domain *DomainAddr `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *Packet_UpdateEgress_Tx) Reset()         { *m = Packet_UpdateEgress_Tx{} }
func (m *Packet_UpdateEgress_Tx) String() string { return proto.CompactTextString(m) }
func (*Packet_UpdateEgress_Tx) ProtoMessage()    {}
func (*Packet_UpdateEgress_Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 9, 0}
}
func (m *Packet_UpdateEgress_Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_UpdateEgress_Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_UpdateEgress_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_UpdateEgress_Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_UpdateEgress_Tx.Merge(m, src)
}
func (m *Packet_UpdateEgress_Tx) XXX_Size() int {
	return m.Size()
}
func (m *Packet_UpdateEgress_Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_UpdateEgress_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_UpdateEgress_Tx proto.InternalMessageInfo

type Packet_UpdateEgress_Tag struct {
	Tag  Tag          `protobuf:"varint,1,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Node GraphNodeIdx `protobuf:"varint,2,opt,name=node,proto3,casttype=GraphNodeIdx" json:"node,omitempty"`
}

func (m *Packet_UpdateEgress_Tag) Reset()         { *m = Packet_UpdateEgress_Tag{} }
func (m *Packet_UpdateEgress_Tag) String() string { return proto.CompactTextString(m) }
func (*Packet_UpdateEgress_Tag) ProtoMessage()    {}
func (*Packet_UpdateEgress_Tag) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 9, 1}
}
func (m *Packet_UpdateEgress_Tag) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_UpdateEgress_Tag) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_UpdateEgress_Tag.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_UpdateEgress_Tag) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_UpdateEgress_Tag.Merge(m, src)
}
func (m *Packet_UpdateEgress_Tag) XXX_Size() int {
	return m.Size()
}
func (m *Packet_UpdateEgress_Tag) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_UpdateEgress_Tag.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_UpdateEgress_Tag proto.InternalMessageInfo

type Packet_UpdateSharder struct {
	Node   LocalNodeIndex             `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	NewTxs []*Packet_UpdateSharder_Tx `protobuf:"bytes,2,rep,name=new_txs,json=newTxs,proto3" json:"new_txs,omitempty"`
}

func (m *Packet_UpdateSharder) Reset()         { *m = Packet_UpdateSharder{} }
func (m *Packet_UpdateSharder) String() string { return proto.CompactTextString(m) }
func (*Packet_UpdateSharder) ProtoMessage()    {}
func (*Packet_UpdateSharder) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 10}
}
func (m *Packet_UpdateSharder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_UpdateSharder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_UpdateSharder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_UpdateSharder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_UpdateSharder.Merge(m, src)
}
func (m *Packet_UpdateSharder) XXX_Size() int {
	return m.Size()
}
func (m *Packet_UpdateSharder) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_UpdateSharder.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_UpdateSharder proto.InternalMessageInfo

type Packet_UpdateSharder_Tx struct {
	Local  LocalNodeIndex `protobuf:"varint,1,opt,name=local,proto3,casttype=LocalNodeIndex" json:"local,omitempty"`
	Domain *DomainAddr    `protobuf:"bytes,2,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *Packet_UpdateSharder_Tx) Reset()         { *m = Packet_UpdateSharder_Tx{} }
func (m *Packet_UpdateSharder_Tx) String() string { return proto.CompactTextString(m) }
func (*Packet_UpdateSharder_Tx) ProtoMessage()    {}
func (*Packet_UpdateSharder_Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 10, 0}
}
func (m *Packet_UpdateSharder_Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_UpdateSharder_Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_UpdateSharder_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_UpdateSharder_Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_UpdateSharder_Tx.Merge(m, src)
}
func (m *Packet_UpdateSharder_Tx) XXX_Size() int {
	return m.Size()
}
func (m *Packet_UpdateSharder_Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_UpdateSharder_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_UpdateSharder_Tx proto.InternalMessageInfo

type Packet_PrepareState struct {
	Node LocalNodeIndex `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	// Types that are valid to be assigned to State:
	//	*Packet_PrepareState_PartialLocal_
	//	*Packet_PrepareState_IndexedLocal_
	//	*Packet_PrepareState_PartialGlobal_
	//	*Packet_PrepareState_Global_
	State isPacket_PrepareState_State `protobuf_oneof:"state"`
}

func (m *Packet_PrepareState) Reset()         { *m = Packet_PrepareState{} }
func (m *Packet_PrepareState) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState) ProtoMessage()    {}
func (*Packet_PrepareState) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11}
}
func (m *Packet_PrepareState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState.Merge(m, src)
}
func (m *Packet_PrepareState) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState proto.InternalMessageInfo

type isPacket_PrepareState_State interface {
	isPacket_PrepareState_State()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Packet_PrepareState_PartialLocal_ struct {
	PartialLocal *Packet_PrepareState_PartialLocal `protobuf:"bytes,2,opt,name=partial_local,json=partialLocal,proto3,oneof" json:"partial_local,omitempty"`
}
type Packet_PrepareState_IndexedLocal_ struct {
	IndexedLocal *Packet_PrepareState_IndexedLocal `protobuf:"bytes,3,opt,name=indexed_local,json=indexedLocal,proto3,oneof" json:"indexed_local,omitempty"`
}
type Packet_PrepareState_PartialGlobal_ struct {
	PartialGlobal *Packet_PrepareState_PartialGlobal `protobuf:"bytes,4,opt,name=partial_global,json=partialGlobal,proto3,oneof" json:"partial_global,omitempty"`
}
type Packet_PrepareState_Global_ struct {
	Global *Packet_PrepareState_Global `protobuf:"bytes,5,opt,name=global,proto3,oneof" json:"global,omitempty"`
}

func (*Packet_PrepareState_PartialLocal_) isPacket_PrepareState_State()  {}
func (*Packet_PrepareState_IndexedLocal_) isPacket_PrepareState_State()  {}
func (*Packet_PrepareState_PartialGlobal_) isPacket_PrepareState_State() {}
func (*Packet_PrepareState_Global_) isPacket_PrepareState_State()        {}

func (m *Packet_PrepareState) GetState() isPacket_PrepareState_State {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *Packet_PrepareState) GetPartialLocal() *Packet_PrepareState_PartialLocal {
	if x, ok := m.GetState().(*Packet_PrepareState_PartialLocal_); ok {
		return x.PartialLocal
	}
	return nil
}

func (m *Packet_PrepareState) GetIndexedLocal() *Packet_PrepareState_IndexedLocal {
	if x, ok := m.GetState().(*Packet_PrepareState_IndexedLocal_); ok {
		return x.IndexedLocal
	}
	return nil
}

func (m *Packet_PrepareState) GetPartialGlobal() *Packet_PrepareState_PartialGlobal {
	if x, ok := m.GetState().(*Packet_PrepareState_PartialGlobal_); ok {
		return x.PartialGlobal
	}
	return nil
}

func (m *Packet_PrepareState) GetGlobal() *Packet_PrepareState_Global {
	if x, ok := m.GetState().(*Packet_PrepareState_Global_); ok {
		return x.Global
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Packet_PrepareState) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Packet_PrepareState_PartialLocal_)(nil),
		(*Packet_PrepareState_IndexedLocal_)(nil),
		(*Packet_PrepareState_PartialGlobal_)(nil),
		(*Packet_PrepareState_Global_)(nil),
	}
}

type Packet_PrepareState_PartialLocal struct {
	Index []*Packet_PrepareState_PartialLocal_Index `protobuf:"bytes,1,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *Packet_PrepareState_PartialLocal) Reset()         { *m = Packet_PrepareState_PartialLocal{} }
func (m *Packet_PrepareState_PartialLocal) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_PartialLocal) ProtoMessage()    {}
func (*Packet_PrepareState_PartialLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 0}
}
func (m *Packet_PrepareState_PartialLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_PartialLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_PartialLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_PartialLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_PartialLocal.Merge(m, src)
}
func (m *Packet_PrepareState_PartialLocal) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_PartialLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_PartialLocal.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_PartialLocal proto.InternalMessageInfo

type Packet_PrepareState_PartialLocal_Index struct {
	Key  []int `protobuf:"varint,1,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	Tags []Tag `protobuf:"varint,2,rep,packed,name=tags,proto3,casttype=Tag" json:"tags,omitempty"`
}

func (m *Packet_PrepareState_PartialLocal_Index) Reset() {
	*m = Packet_PrepareState_PartialLocal_Index{}
}
func (m *Packet_PrepareState_PartialLocal_Index) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_PartialLocal_Index) ProtoMessage()    {}
func (*Packet_PrepareState_PartialLocal_Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 0, 0}
}
func (m *Packet_PrepareState_PartialLocal_Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_PartialLocal_Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_PartialLocal_Index.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_PartialLocal_Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_PartialLocal_Index.Merge(m, src)
}
func (m *Packet_PrepareState_PartialLocal_Index) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_PartialLocal_Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_PartialLocal_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_PartialLocal_Index proto.InternalMessageInfo

type Packet_PrepareState_IndexedLocal struct {
	Index []*Packet_PrepareState_IndexedLocal_Index `protobuf:"bytes,1,rep,name=index,proto3" json:"index,omitempty"`
}

func (m *Packet_PrepareState_IndexedLocal) Reset()         { *m = Packet_PrepareState_IndexedLocal{} }
func (m *Packet_PrepareState_IndexedLocal) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_IndexedLocal) ProtoMessage()    {}
func (*Packet_PrepareState_IndexedLocal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 1}
}
func (m *Packet_PrepareState_IndexedLocal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_IndexedLocal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_IndexedLocal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_IndexedLocal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_IndexedLocal.Merge(m, src)
}
func (m *Packet_PrepareState_IndexedLocal) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_IndexedLocal) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_IndexedLocal.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_IndexedLocal proto.InternalMessageInfo

type Packet_PrepareState_IndexedLocal_Index struct {
	Key []int `protobuf:"varint,1,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
}

func (m *Packet_PrepareState_IndexedLocal_Index) Reset() {
	*m = Packet_PrepareState_IndexedLocal_Index{}
}
func (m *Packet_PrepareState_IndexedLocal_Index) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_IndexedLocal_Index) ProtoMessage()    {}
func (*Packet_PrepareState_IndexedLocal_Index) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 1, 0}
}
func (m *Packet_PrepareState_IndexedLocal_Index) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_IndexedLocal_Index) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_IndexedLocal_Index.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_IndexedLocal_Index) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_IndexedLocal_Index.Merge(m, src)
}
func (m *Packet_PrepareState_IndexedLocal_Index) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_IndexedLocal_Index) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_IndexedLocal_Index.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_IndexedLocal_Index proto.InternalMessageInfo

type Packet_PrepareState_PartialGlobal struct {
	Gid           GraphNodeIdx                                     `protobuf:"varint,1,opt,name=gid,proto3,casttype=GraphNodeIdx" json:"gid,omitempty"`
	Cols          int                                              `protobuf:"varint,2,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Key           []int                                            `protobuf:"varint,3,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
	TriggerDomain *Packet_PrepareState_PartialGlobal_TriggerDomain `protobuf:"bytes,4,opt,name=trigger_domain,json=triggerDomain,proto3" json:"trigger_domain,omitempty"`
}

func (m *Packet_PrepareState_PartialGlobal) Reset()         { *m = Packet_PrepareState_PartialGlobal{} }
func (m *Packet_PrepareState_PartialGlobal) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_PartialGlobal) ProtoMessage()    {}
func (*Packet_PrepareState_PartialGlobal) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 2}
}
func (m *Packet_PrepareState_PartialGlobal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_PartialGlobal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_PartialGlobal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_PartialGlobal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_PartialGlobal.Merge(m, src)
}
func (m *Packet_PrepareState_PartialGlobal) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_PartialGlobal) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_PartialGlobal.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_PartialGlobal proto.InternalMessageInfo

type Packet_PrepareState_PartialGlobal_TriggerDomain struct {
	Domain DomainIndex `protobuf:"varint,1,opt,name=domain,proto3,casttype=DomainIndex" json:"domain,omitempty"`
	Shards uint        `protobuf:"varint,2,opt,name=shards,proto3,casttype=uint" json:"shards,omitempty"`
}

func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) Reset() {
	*m = Packet_PrepareState_PartialGlobal_TriggerDomain{}
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) String() string {
	return proto.CompactTextString(m)
}
func (*Packet_PrepareState_PartialGlobal_TriggerDomain) ProtoMessage() {}
func (*Packet_PrepareState_PartialGlobal_TriggerDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 2, 0}
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_PartialGlobal_TriggerDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_PartialGlobal_TriggerDomain.Merge(m, src)
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_PartialGlobal_TriggerDomain.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_PartialGlobal_TriggerDomain proto.InternalMessageInfo

type Packet_PrepareState_Global struct {
	Gid  GraphNodeIdx `protobuf:"varint,1,opt,name=gid,proto3,casttype=GraphNodeIdx" json:"gid,omitempty"`
	Cols int          `protobuf:"varint,2,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Key  []int        `protobuf:"varint,3,rep,packed,name=key,proto3,casttype=int" json:"key,omitempty"`
}

func (m *Packet_PrepareState_Global) Reset()         { *m = Packet_PrepareState_Global{} }
func (m *Packet_PrepareState_Global) String() string { return proto.CompactTextString(m) }
func (*Packet_PrepareState_Global) ProtoMessage()    {}
func (*Packet_PrepareState_Global) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 11, 3}
}
func (m *Packet_PrepareState_Global) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_PrepareState_Global) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_PrepareState_Global.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_PrepareState_Global) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_PrepareState_Global.Merge(m, src)
}
func (m *Packet_PrepareState_Global) XXX_Size() int {
	return m.Size()
}
func (m *Packet_PrepareState_Global) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_PrepareState_Global.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_PrepareState_Global proto.InternalMessageInfo

type Packet_RequestPartialReplay struct {
	Tag             Tag   `protobuf:"varint,1,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	Keys            []Row `protobuf:"bytes,2,rep,name=keys,proto3,casttype=Row" json:"keys,omitempty"`
	Unishard        bool  `protobuf:"varint,3,opt,name=unishard,proto3" json:"unishard,omitempty"`
	RequestingShard uint  `protobuf:"varint,4,opt,name=requesting_shard,json=requestingShard,proto3,casttype=uint" json:"requesting_shard,omitempty"`
}

func (m *Packet_RequestPartialReplay) Reset()         { *m = Packet_RequestPartialReplay{} }
func (m *Packet_RequestPartialReplay) String() string { return proto.CompactTextString(m) }
func (*Packet_RequestPartialReplay) ProtoMessage()    {}
func (*Packet_RequestPartialReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 12}
}
func (m *Packet_RequestPartialReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_RequestPartialReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_RequestPartialReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_RequestPartialReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_RequestPartialReplay.Merge(m, src)
}
func (m *Packet_RequestPartialReplay) XXX_Size() int {
	return m.Size()
}
func (m *Packet_RequestPartialReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_RequestPartialReplay.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_RequestPartialReplay proto.InternalMessageInfo

type Packet_RequestReaderReplay struct {
	Node LocalNodeIndex `protobuf:"varint,1,opt,name=node,proto3,casttype=LocalNodeIndex" json:"node,omitempty"`
	Cols []int          `protobuf:"varint,2,rep,packed,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Keys []Row          `protobuf:"bytes,3,rep,name=keys,proto3,casttype=Row" json:"keys,omitempty"`
}

func (m *Packet_RequestReaderReplay) Reset()         { *m = Packet_RequestReaderReplay{} }
func (m *Packet_RequestReaderReplay) String() string { return proto.CompactTextString(m) }
func (*Packet_RequestReaderReplay) ProtoMessage()    {}
func (*Packet_RequestReaderReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 13}
}
func (m *Packet_RequestReaderReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_RequestReaderReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_RequestReaderReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_RequestReaderReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_RequestReaderReplay.Merge(m, src)
}
func (m *Packet_RequestReaderReplay) XXX_Size() int {
	return m.Size()
}
func (m *Packet_RequestReaderReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_RequestReaderReplay.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_RequestReaderReplay proto.InternalMessageInfo

type Packet_StartReplay struct {
	Tag  Tag            `protobuf:"varint,1,opt,name=tag,proto3,casttype=Tag" json:"tag,omitempty"`
	From LocalNodeIndex `protobuf:"varint,2,opt,name=from,proto3,casttype=LocalNodeIndex" json:"from,omitempty"`
}

func (m *Packet_StartReplay) Reset()         { *m = Packet_StartReplay{} }
func (m *Packet_StartReplay) String() string { return proto.CompactTextString(m) }
func (*Packet_StartReplay) ProtoMessage()    {}
func (*Packet_StartReplay) Descriptor() ([]byte, []int) {
	return fileDescriptor_e9ef1a6541f9f9e7, []int{9, 14}
}
func (m *Packet_StartReplay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Packet_StartReplay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Packet_StartReplay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Packet_StartReplay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Packet_StartReplay.Merge(m, src)
}
func (m *Packet_StartReplay) XXX_Size() int {
	return m.Size()
}
func (m *Packet_StartReplay) XXX_DiscardUnknown() {
	xxx_messageInfo_Packet_StartReplay.DiscardUnknown(m)
}

var xxx_messageInfo_Packet_StartReplay proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("packet.TableOperation_Tag", TableOperation_Tag_name, TableOperation_Tag_value)
	proto.RegisterType((*SourceChannelIdentifier)(nil), "packet.SourceChannelIdentifier")
	proto.RegisterType((*TableOperation)(nil), "packet.TableOperation")
	proto.RegisterType((*FlowInput)(nil), "packet.FlowInput")
	proto.RegisterType((*Link)(nil), "packet.Link")
	proto.RegisterType((*ReplayPathSegment)(nil), "packet.ReplayPathSegment")
	proto.RegisterType((*SourceSelection)(nil), "packet.SourceSelection")
	proto.RegisterType((*SourceSelection_KeyShard)(nil), "packet.SourceSelection.KeyShard")
	proto.RegisterType((*TriggerEndpoint)(nil), "packet.TriggerEndpoint")
	proto.RegisterType((*TriggerEndpoint_Start)(nil), "packet.TriggerEndpoint.Start")
	proto.RegisterType((*TriggerEndpoint_End)(nil), "packet.TriggerEndpoint.End")
	proto.RegisterType((*TriggerEndpoint_Local)(nil), "packet.TriggerEndpoint.Local")
	proto.RegisterType((*Record)(nil), "packet.Record")
	proto.RegisterType((*SyncPacket)(nil), "packet.SyncPacket")
	proto.RegisterType((*SyncPacket_SetupReplayPath)(nil), "packet.SyncPacket.SetupReplayPath")
	proto.RegisterType((*SyncPacket_Ready)(nil), "packet.SyncPacket.Ready")
	proto.RegisterType((*SyncPacket_Ready_Index)(nil), "packet.SyncPacket.Ready.Index")
	proto.RegisterType((*SyncPacket_AddBaseColumn)(nil), "packet.SyncPacket.AddBaseColumn")
	proto.RegisterType((*SyncPacket_DropBaseColumn)(nil), "packet.SyncPacket.DropBaseColumn")
	proto.RegisterType((*Packet)(nil), "packet.Packet")
	proto.RegisterType((*Packet_Input)(nil), "packet.Packet.Input")
	proto.RegisterType((*Packet_Message)(nil), "packet.Packet.Message")
	proto.RegisterType((*Packet_Vstream)(nil), "packet.Packet.Vstream")
	proto.RegisterType((*Packet_ReplayPiece)(nil), "packet.Packet.ReplayPiece")
	proto.RegisterType((*Packet_ReplayPiece_ContextPartial)(nil), "packet.Packet.ReplayPiece.ContextPartial")
	proto.RegisterMapType((map[Row]bool)(nil), "packet.Packet.ReplayPiece.ContextPartial.ForKeysEntry")
	proto.RegisterType((*Packet_ReplayPiece_ContextRegular)(nil), "packet.Packet.ReplayPiece.ContextRegular")
	proto.RegisterType((*Packet_Evict)(nil), "packet.Packet.Evict")
	proto.RegisterType((*Packet_EvictKeys)(nil), "packet.Packet.EvictKeys")
	proto.RegisterType((*Packet_Finish)(nil), "packet.Packet.Finish")
	proto.RegisterType((*Packet_AddNode)(nil), "packet.Packet.AddNode")
	proto.RegisterType((*Packet_RemoveNodes)(nil), "packet.Packet.RemoveNodes")
	proto.RegisterType((*Packet_UpdateEgress)(nil), "packet.Packet.UpdateEgress")
	proto.RegisterType((*Packet_UpdateEgress_Tx)(nil), "packet.Packet.UpdateEgress.Tx")
	proto.RegisterType((*Packet_UpdateEgress_Tag)(nil), "packet.Packet.UpdateEgress.Tag")
	proto.RegisterType((*Packet_UpdateSharder)(nil), "packet.Packet.UpdateSharder")
	proto.RegisterType((*Packet_UpdateSharder_Tx)(nil), "packet.Packet.UpdateSharder.Tx")
	proto.RegisterType((*Packet_PrepareState)(nil), "packet.Packet.PrepareState")
	proto.RegisterType((*Packet_PrepareState_PartialLocal)(nil), "packet.Packet.PrepareState.PartialLocal")
	proto.RegisterType((*Packet_PrepareState_PartialLocal_Index)(nil), "packet.Packet.PrepareState.PartialLocal.Index")
	proto.RegisterType((*Packet_PrepareState_IndexedLocal)(nil), "packet.Packet.PrepareState.IndexedLocal")
	proto.RegisterType((*Packet_PrepareState_IndexedLocal_Index)(nil), "packet.Packet.PrepareState.IndexedLocal.Index")
	proto.RegisterType((*Packet_PrepareState_PartialGlobal)(nil), "packet.Packet.PrepareState.PartialGlobal")
	proto.RegisterType((*Packet_PrepareState_PartialGlobal_TriggerDomain)(nil), "packet.Packet.PrepareState.PartialGlobal.TriggerDomain")
	proto.RegisterType((*Packet_PrepareState_Global)(nil), "packet.Packet.PrepareState.Global")
	proto.RegisterType((*Packet_RequestPartialReplay)(nil), "packet.Packet.RequestPartialReplay")
	proto.RegisterType((*Packet_RequestReaderReplay)(nil), "packet.Packet.RequestReaderReplay")
	proto.RegisterType((*Packet_StartReplay)(nil), "packet.Packet.StartReplay")
}

func init() { proto.RegisterFile("packet.proto", fileDescriptor_e9ef1a6541f9f9e7) }

var fileDescriptor_e9ef1a6541f9f9e7 = []byte{
	// 2347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x19, 0x4d, 0x6f, 0x1b, 0xc7,
	0x95, 0xcb, 0x6f, 0x3d, 0x7e, 0x48, 0x9e, 0xc8, 0x36, 0xbd, 0x6e, 0x25, 0x99, 0x31, 0x12, 0x25,
	0x70, 0xa9, 0x46, 0x6e, 0x9a, 0x0f, 0xb4, 0x30, 0x4c, 0x5b, 0x8e, 0x54, 0x3b, 0xb5, 0xb0, 0x52,
	0xda, 0xc0, 0x45, 0xcb, 0x8e, 0xb8, 0x23, 0x6a, 0xa1, 0xd5, 0xce, 0x66, 0x76, 0x28, 0x89, 0xd7,
	0xde, 0x7a, 0x28, 0x90, 0x1e, 0x02, 0xf4, 0x94, 0x9e, 0x8a, 0xfe, 0x82, 0xfe, 0x07, 0x17, 0xb9,
	0xe4, 0xd8, 0x93, 0xda, 0xda, 0xd7, 0xa2, 0x3f, 0xc0, 0xa7, 0xe2, 0xcd, 0xcc, 0x2e, 0x97, 0x14,
	0x45, 0xd1, 0x28, 0x72, 0x21, 0x66, 0xde, 0xbc, 0x79, 0xef, 0xcd, 0xfb, 0x7e, 0x4b, 0xa8, 0x86,
	0xb4, 0x7b, 0xc8, 0x64, 0x2b, 0x14, 0x5c, 0x72, 0x52, 0xd4, 0x3b, 0x1b, 0x02, 0xee, 0x32, 0x0d,
	0xb3, 0x17, 0x7b, 0xbc, 0xc7, 0xd5, 0x72, 0x0d, 0x57, 0x1a, 0xda, 0xfc, 0x2d, 0x5c, 0xdf, 0xe1,
	0x7d, 0xd1, 0x65, 0x0f, 0x0e, 0x68, 0x10, 0x30, 0x7f, 0xcb, 0x65, 0x81, 0xf4, 0xf6, 0x3d, 0x26,
	0xc8, 0x22, 0x14, 0x24, 0x3f, 0x64, 0x41, 0xc3, 0x5a, 0xb1, 0x56, 0xf3, 0x8e, 0xde, 0x20, 0x94,
	0x85, 0xbc, 0x7b, 0xd0, 0xc8, 0x6a, 0xa8, 0xda, 0x90, 0x1b, 0x90, 0x93, 0xb4, 0xd7, 0xc8, 0xad,
	0x58, 0xab, 0xb5, 0x76, 0xe9, 0xd5, 0xd9, 0x72, 0x6e, 0x97, 0xf6, 0x1c, 0x84, 0x35, 0xff, 0x64,
	0x41, 0x7d, 0x97, 0xee, 0xf9, 0xec, 0x69, 0xc8, 0x04, 0x95, 0x1e, 0x0f, 0xc8, 0x1d, 0x8d, 0x8d,
	0x74, 0xeb, 0xeb, 0x76, 0xcb, 0x88, 0x3e, 0x8a, 0xd4, 0x8a, 0x09, 0x20, 0xed, 0x43, 0x36, 0x50,
	0xfc, 0xe6, 0x34, 0x6d, 0x87, 0x9f, 0x38, 0x08, 0x6b, 0xfe, 0x14, 0x90, 0x0f, 0x01, 0x28, 0x6e,
	0x05, 0x11, 0x13, 0x72, 0x21, 0x83, 0xeb, 0x87, 0xcc, 0x67, 0x92, 0x2d, 0x58, 0x84, 0x40, 0x5d,
	0xc3, 0x9f, 0x8a, 0xcf, 0x42, 0x97, 0x4a, 0xb6, 0x90, 0xc5, 0x73, 0xb3, 0xce, 0x35, 0x7f, 0x0d,
	0x73, 0x8f, 0x7c, 0x7e, 0xb2, 0x15, 0x84, 0x7d, 0x49, 0x6e, 0x43, 0xce, 0x8d, 0xa4, 0x12, 0xaa,
	0xd6, 0x26, 0xaf, 0xce, 0x96, 0xeb, 0x4f, 0x78, 0x97, 0xfa, 0x3f, 0xe7, 0x2e, 0xdb, 0x0a, 0x5c,
	0x76, 0xea, 0xe0, 0x31, 0x79, 0x17, 0xf2, 0x2e, 0x95, 0xb4, 0x91, 0x5d, 0xc9, 0xad, 0x56, 0xd6,
	0xaf, 0x4d, 0x96, 0xdd, 0x51, 0x38, 0x4d, 0x07, 0xf2, 0x4f, 0xbc, 0xe0, 0x10, 0x29, 0x47, 0xa2,
	0x3b, 0x8d, 0x72, 0x24, 0xba, 0x31, 0xff, 0xec, 0x54, 0xfe, 0xcd, 0x2f, 0x2d, 0xb8, 0xe2, 0xb0,
	0xd0, 0xa7, 0x83, 0x6d, 0x2a, 0x0f, 0x76, 0x58, 0xef, 0x88, 0x05, 0x92, 0xbc, 0x05, 0x79, 0xb4,
	0xf4, 0x14, 0x16, 0xea, 0x9c, 0xbc, 0x03, 0xd5, 0x7d, 0x2e, 0xba, 0xac, 0x23, 0x69, 0xaf, 0x23,
	0xb9, 0x61, 0x96, 0xd8, 0x0b, 0xd4, 0xe1, 0x2e, 0xed, 0xed, 0x72, 0xb2, 0x0a, 0x95, 0x90, 0x0a,
	0xe9, 0x51, 0xbf, 0x83, 0xda, 0xcf, 0xad, 0xe4, 0x56, 0x73, 0x1a, 0xd3, 0x0b, 0xa4, 0x03, 0xe6,
	0xec, 0x31, 0x1b, 0x34, 0xff, 0x63, 0xc1, 0xbc, 0xf6, 0xa1, 0x1d, 0xe6, 0xb3, 0xae, 0xb2, 0xf0,
	0x3d, 0x98, 0x3b, 0x64, 0x83, 0x4e, 0x74, 0x40, 0x85, 0xab, 0xa4, 0xaa, 0xac, 0xaf, 0xc4, 0xba,
	0x1a, 0xc3, 0x6d, 0x3d, 0x66, 0x83, 0x1d, 0xc4, 0xdb, 0xcc, 0x38, 0xe5, 0x43, 0xb3, 0x26, 0xcb,
	0x00, 0x11, 0x3d, 0x62, 0x86, 0x02, 0xca, 0x59, 0xde, 0xcc, 0x38, 0x73, 0x08, 0x4b, 0x10, 0xa8,
	0xef, 0xeb, 0xf3, 0x48, 0x39, 0x5e, 0x1e, 0x11, 0xa8, 0xef, 0xab, 0xf3, 0xc8, 0xde, 0x82, 0x72,
	0x4c, 0x99, 0xbc, 0x09, 0x75, 0x14, 0xc7, 0xeb, 0x48, 0x9e, 0x92, 0x29, 0xe7, 0x54, 0x0e, 0xd9,
	0x60, 0x6b, 0x97, 0x6b, 0xa4, 0x06, 0x94, 0x02, 0x43, 0x4e, 0xfb, 0x76, 0xbc, 0x6d, 0x57, 0x60,
	0x2e, 0x8a, 0xc5, 0x6d, 0xfe, 0x37, 0x0b, 0xf3, 0xbb, 0xc2, 0xeb, 0xf5, 0x98, 0xd8, 0x08, 0xdc,
	0x90, 0x7b, 0x81, 0x24, 0xef, 0x43, 0x21, 0x92, 0x54, 0x68, 0xeb, 0x55, 0xd6, 0xbf, 0x9f, 0xb8,
	0xc5, 0x28, 0x5e, 0x6b, 0x07, 0x91, 0x36, 0x33, 0x8e, 0xc6, 0x26, 0x6b, 0x90, 0x63, 0x81, 0xab,
	0x84, 0xaf, 0xac, 0xdf, 0xbc, 0xe8, 0xd2, 0x46, 0x80, 0xaa, 0x41, 0x4c, 0xe4, 0xe3, 0xa3, 0x5d,
	0x1b, 0xf9, 0xe9, 0x7c, 0x94, 0xf1, 0x91, 0x8f, 0xc2, 0xb6, 0x6f, 0x43, 0x41, 0x71, 0x26, 0x37,
	0x21, 0xdf, 0xe5, 0x7e, 0xd4, 0xb0, 0x46, 0xad, 0xa9, 0x80, 0x36, 0x83, 0xdc, 0x86, 0xe2, 0x31,
	0x7c, 0xac, 0x31, 0xdd, 0xf5, 0x0b, 0x4c, 0xe7, 0x0c, 0x31, 0xc9, 0xdb, 0x50, 0x74, 0xf9, 0x11,
	0xf5, 0x02, 0xad, 0xbc, 0xf6, 0xfc, 0xab, 0xb3, 0xe5, 0xca, 0x43, 0x05, 0xd1, 0x1e, 0x68, 0x8e,
	0x51, 0x18, 0x25, 0xde, 0x54, 0x61, 0xda, 0x73, 0x50, 0x92, 0xfa, 0x51, 0xcd, 0x7b, 0x50, 0x74,
	0x58, 0x97, 0x0b, 0x17, 0x33, 0x81, 0xe0, 0x27, 0x4a, 0xa8, 0x74, 0x26, 0x10, 0xfc, 0x84, 0xd8,
	0x50, 0x0e, 0x79, 0xe4, 0x49, 0xef, 0x98, 0x69, 0x6f, 0x71, 0x92, 0x7d, 0xf3, 0x6f, 0x45, 0x80,
	0x9d, 0x41, 0xd0, 0xdd, 0x56, 0x8f, 0x20, 0xdb, 0x70, 0x25, 0x62, 0xb2, 0x1f, 0x76, 0x84, 0x8a,
	0xa3, 0x4e, 0x48, 0xe5, 0x81, 0x79, 0x68, 0x33, 0x79, 0x68, 0x82, 0xde, 0xda, 0x41, 0xdc, 0x61,
	0xc8, 0x6d, 0x66, 0x9c, 0xf9, 0x68, 0x14, 0x44, 0x7e, 0x08, 0x05, 0xc1, 0xa8, 0x3b, 0x30, 0xe6,
	0x6f, 0x4c, 0xa0, 0xe2, 0xe0, 0x39, 0x5a, 0x44, 0x21, 0x92, 0x55, 0x98, 0x3f, 0xa1, 0x9e, 0xec,
	0xec, 0x73, 0x61, 0xc4, 0x50, 0x5e, 0x80, 0x3e, 0x5e, 0xc3, 0x83, 0x47, 0x5c, 0x68, 0xfa, 0xe4,
	0x67, 0x30, 0x4f, 0x5d, 0xb7, 0xb3, 0x47, 0x23, 0xd6, 0xe9, 0x72, 0xbf, 0x7f, 0x14, 0x34, 0x60,
	0x2c, 0x9e, 0x86, 0x5c, 0xee, 0xbb, 0x6e, 0x9b, 0x46, 0xec, 0x81, 0xc2, 0x43, 0x5a, 0x34, 0x0d,
	0x20, 0x9f, 0xc2, 0x82, 0x2b, 0x78, 0x38, 0x42, 0xac, 0xa2, 0x88, 0xdd, 0x9a, 0x40, 0xec, 0xa1,
	0xe0, 0xe1, 0x08, 0xb5, 0xba, 0x3b, 0x02, 0xb1, 0xff, 0x92, 0x85, 0xf9, 0x31, 0xed, 0xc4, 0x85,
	0xc0, 0x3a, 0x5f, 0x08, 0xc8, 0xbb, 0x50, 0x8c, 0x94, 0xff, 0x4c, 0xc9, 0x71, 0x06, 0x83, 0xfc,
	0x00, 0xf2, 0xca, 0x2c, 0x39, 0x95, 0x66, 0x6f, 0xc4, 0xd2, 0x9d, 0xcb, 0x7c, 0x8e, 0x42, 0x23,
	0x9b, 0x70, 0x3d, 0x4e, 0x56, 0xfd, 0xc0, 0xeb, 0xd2, 0x48, 0xea, 0x30, 0x67, 0x42, 0x45, 0x4a,
	0xad, 0xbd, 0xf0, 0xea, 0x6c, 0xb9, 0xfa, 0x89, 0xa0, 0xe1, 0x81, 0xe2, 0xe5, 0x9e, 0x3a, 0x57,
	0xcd, 0x85, 0xcf, 0x34, 0xfe, 0x8e, 0x46, 0x27, 0xcb, 0x50, 0x09, 0xb8, 0xf4, 0xf6, 0x07, 0x1d,
	0x97, 0x07, 0xac, 0x51, 0x50, 0xae, 0x04, 0x1a, 0xf4, 0x90, 0x07, 0x8c, 0xbc, 0x97, 0x38, 0x66,
	0xa3, 0x38, 0x1a, 0x1c, 0x63, 0x41, 0xe8, 0xc4, 0x78, 0xf6, 0xef, 0x2d, 0x28, 0x28, 0xfb, 0xcf,
	0x9c, 0xa7, 0x7f, 0x04, 0x05, 0x0f, 0xb7, 0xe6, 0xfd, 0x4b, 0x17, 0x39, 0x54, 0x4b, 0x5f, 0xd2,
	0xc8, 0x76, 0x13, 0x0a, 0x6a, 0x1f, 0x57, 0xcc, 0xb1, 0xc0, 0x42, 0x98, 0x3d, 0x0f, 0xb5, 0x11,
	0x27, 0xb1, 0x17, 0xa0, 0x3e, 0x6a, 0xe8, 0x76, 0x09, 0x99, 0x07, 0x4c, 0x34, 0xbf, 0x69, 0x42,
	0xd1, 0xc4, 0xcc, 0x1d, 0x84, 0x85, 0x7d, 0x69, 0xe2, 0x64, 0x31, 0x16, 0xc8, 0x08, 0xa3, 0x2a,
	0x28, 0x7a, 0xb7, 0x42, 0x22, 0xeb, 0x50, 0x3a, 0x62, 0x51, 0x44, 0x7b, 0xcc, 0x44, 0xc4, 0xb5,
	0x31, 0xfc, 0x4f, 0xf5, 0xe9, 0x66, 0xc6, 0x89, 0x11, 0xf1, 0xce, 0x71, 0x24, 0x05, 0xa3, 0x47,
	0x26, 0x1f, 0x8e, 0xdf, 0xf9, 0x85, 0x3e, 0xc5, 0x3b, 0x06, 0x91, 0xdc, 0x83, 0x6a, 0x1c, 0xc3,
	0x1e, 0xeb, 0x32, 0x93, 0x15, 0xed, 0xb1, 0x8b, 0xc6, 0x69, 0x10, 0x63, 0x33, 0xe3, 0x54, 0xc4,
	0x70, 0x8b, 0xcf, 0x62, 0xc7, 0x5e, 0x57, 0x2a, 0x3b, 0x9f, 0x7f, 0xd6, 0x06, 0x9e, 0xe1, 0xb3,
	0x14, 0x12, 0xf9, 0x08, 0x40, 0x2d, 0xb0, 0x20, 0x46, 0xc6, 0xfa, 0x8d, 0x49, 0x57, 0x1e, 0xb3,
	0x41, 0x84, 0xc5, 0x88, 0xc5, 0x1b, 0xf2, 0x2b, 0xb8, 0x26, 0xd8, 0x17, 0x7d, 0x16, 0xc9, 0x4e,
	0xec, 0xa8, 0x26, 0xec, 0x75, 0x30, 0xbf, 0x79, 0x4e, 0x66, 0x85, 0xbc, 0xad, 0x71, 0xf5, 0x0b,
	0x36, 0x33, 0xce, 0xa2, 0x98, 0x00, 0x27, 0x9f, 0xc3, 0xd5, 0x98, 0x38, 0x66, 0x17, 0x96, 0xa4,
	0x94, 0xca, 0x68, 0x52, 0x1b, 0xa5, 0xed, 0x28, 0xd4, 0x84, 0xf4, 0x1b, 0xe2, 0x3c, 0x18, 0x15,
	0xac, 0x2a, 0x55, 0x4c, 0xb0, 0x3a, 0x51, 0xc1, 0xaa, 0xb6, 0x24, 0x84, 0x2a, 0xd1, 0x70, 0x4b,
	0xee, 0x42, 0x19, 0xb3, 0x97, 0x72, 0xfa, 0xc5, 0x89, 0x66, 0xbd, 0xef, 0xba, 0xe8, 0xfd, 0x68,
	0x56, 0xaa, 0x97, 0x64, 0x0d, 0x8a, 0xfb, 0x5e, 0xe0, 0x45, 0x07, 0x8d, 0xab, 0xea, 0xca, 0xd5,
	0xb1, 0x2b, 0x8f, 0xd4, 0xe1, 0x66, 0xc6, 0x31, 0x68, 0xda, 0x0f, 0x8e, 0xf8, 0x31, 0x53, 0x8c,
	0xa2, 0xc6, 0xb5, 0x0b, 0xfc, 0x00, 0x51, 0x90, 0x43, 0xa4, 0xfd, 0x20, 0xd9, 0x92, 0x36, 0xd4,
	0xfa, 0xaa, 0x29, 0xec, 0xb0, 0x9e, 0x60, 0x51, 0xd4, 0xb8, 0x3e, 0x5a, 0x92, 0x0d, 0x05, 0xdd,
	0x38, 0x6e, 0x28, 0x94, 0xcd, 0x8c, 0x53, 0xed, 0xa7, 0xf6, 0x64, 0x03, 0xea, 0x86, 0x46, 0x9c,
	0x7a, 0x1a, 0x8a, 0xc8, 0xf7, 0x26, 0x12, 0x31, 0xf9, 0x06, 0x73, 0x74, 0x3f, 0x0d, 0x40, 0x51,
	0x42, 0xc1, 0x42, 0x2a, 0x58, 0x27, 0x92, 0x54, 0xb2, 0xc6, 0x8d, 0x89, 0xa2, 0x6c, 0x6b, 0x9c,
	0x1d, 0x44, 0x41, 0x51, 0xc2, 0xd4, 0x9e, 0xd4, 0x21, 0xeb, 0xb9, 0x8d, 0x5b, 0x2b, 0xd6, 0x6a,
	0xc1, 0xc9, 0x7a, 0xae, 0xfd, 0xb5, 0x85, 0x99, 0x01, 0x23, 0xf3, 0x6d, 0x13, 0xdb, 0x26, 0x8e,
	0xaf, 0xc4, 0x54, 0x93, 0x36, 0xd8, 0xd1, 0xe7, 0xe4, 0x3d, 0xdd, 0xb3, 0xea, 0xf0, 0x5d, 0x1e,
	0xad, 0xff, 0xe7, 0x46, 0x05, 0xdd, 0xc0, 0x7e, 0x04, 0xa5, 0x88, 0x05, 0x2e, 0x13, 0x91, 0x49,
	0x5b, 0x97, 0x5e, 0x8b, 0xf1, 0xed, 0x3e, 0x94, 0x4c, 0x4a, 0x20, 0x2b, 0x90, 0xf7, 0xbd, 0xe0,
	0xd0, 0x08, 0x58, 0x8d, 0x49, 0x60, 0x23, 0xed, 0xa8, 0x13, 0xd2, 0x82, 0x92, 0x50, 0xfd, 0x40,
	0x64, 0xba, 0xf0, 0xfa, 0xb0, 0x3c, 0x20, 0xb8, 0x9d, 0x7f, 0x7e, 0xb6, 0x9c, 0x71, 0x62, 0x24,
	0xec, 0xeb, 0xbc, 0x5e, 0xc0, 0x05, 0xd3, 0x9d, 0x56, 0xd9, 0x89, 0xb7, 0xf6, 0x1f, 0x2c, 0x28,
	0x99, 0xb4, 0x32, 0x03, 0xdf, 0xb7, 0xa0, 0xb8, 0xc7, 0xf6, 0xb9, 0x88, 0x93, 0xda, 0x18, 0x5b,
	0xc7, 0x9c, 0x92, 0xdb, 0x50, 0xa0, 0xfb, 0x92, 0x09, 0x93, 0xc7, 0xc6, 0xd1, 0xf4, 0x21, 0x21,
	0x90, 0xef, 0x49, 0xcf, 0x55, 0x39, 0x6b, 0xce, 0x51, 0x6b, 0xfb, 0xeb, 0x02, 0x54, 0x52, 0xd9,
	0x6a, 0x06, 0x99, 0x4c, 0xb9, 0xcd, 0x4e, 0x28, 0xb7, 0x29, 0x35, 0xe5, 0x66, 0x51, 0xd3, 0x06,
	0x94, 0x4c, 0x6a, 0x32, 0x79, 0xf4, 0x9d, 0x8b, 0xf3, 0x68, 0xeb, 0x01, 0x0f, 0x24, 0x3b, 0x8d,
	0xf3, 0x10, 0x06, 0xaf, 0xb9, 0x8b, 0x64, 0x04, 0xeb, 0xf5, 0x7d, 0x2a, 0x4c, 0x52, 0x9d, 0x81,
	0x8c, 0xa3, 0x2f, 0x6c, 0x2a, 0x69, 0xd4, 0x92, 0x34, 0xa0, 0xb8, 0x4f, 0x3d, 0x9f, 0xb9, 0x8d,
	0x12, 0x2a, 0x48, 0x05, 0xbb, 0xda, 0x27, 0x8a, 0x83, 0xa1, 0xe2, 0xc8, 0x2d, 0xa8, 0xf6, 0xc3,
	0x2f, 0xfa, 0x4c, 0x0c, 0x3a, 0x91, 0xcf, 0xa5, 0x4a, 0x7c, 0x35, 0xa7, 0x62, 0x60, 0x3b, 0x3e,
	0x97, 0xf6, 0x1f, 0xb3, 0x50, 0x1f, 0x95, 0x9a, 0x3c, 0x83, 0x32, 0xf6, 0x5f, 0x2a, 0x9b, 0x5b,
	0x4a, 0x45, 0x3f, 0x9e, 0xf9, 0xc9, 0xad, 0x47, 0x5c, 0x60, 0x66, 0xdf, 0x08, 0xa4, 0x18, 0xb4,
	0x4b, 0xbf, 0xfb, 0xa7, 0xee, 0x45, 0x4b, 0xfb, 0x1a, 0x4c, 0xee, 0xc2, 0x82, 0x49, 0xa8, 0x5e,
	0xd0, 0x4b, 0x4d, 0x31, 0xf9, 0x76, 0xf9, 0xd5, 0xd9, 0x72, 0xbe, 0x8f, 0x05, 0x79, 0x7e, 0x88,
	0xa1, 0x27, 0x10, 0x1b, 0xca, 0x7d, 0x4c, 0x68, 0x88, 0xac, 0x5d, 0x35, 0xd9, 0x93, 0x6b, 0x50,
	0xd4, 0x6e, 0xab, 0xac, 0x53, 0x76, 0xcc, 0xce, 0xfe, 0x18, 0xaa, 0x69, 0x51, 0xc8, 0x42, 0x5c,
	0xfb, 0x51, 0x3b, 0xb8, 0xc4, 0x89, 0xfd, 0x98, 0xfa, 0xfd, 0xb8, 0x2f, 0xd6, 0x9b, 0x8f, 0xb3,
	0x1f, 0x5a, 0xf6, 0xed, 0x44, 0x25, 0xc6, 0x02, 0xa8, 0x5c, 0x9f, 0x9a, 0x29, 0xb8, 0xec, 0xa8,
	0x35, 0xb6, 0xe2, 0x5d, 0x8d, 0x65, 0x3f, 0x81, 0x82, 0x2a, 0x70, 0x33, 0x37, 0x32, 0x37, 0x61,
	0x2e, 0xe8, 0x1f, 0x75, 0xf6, 0x06, 0x92, 0xe9, 0xa9, 0x2a, 0xe7, 0x94, 0x83, 0xfe, 0x51, 0x1b,
	0xf7, 0x36, 0x83, 0xb9, 0xa4, 0x5c, 0xfe, 0x7f, 0xbe, 0x7e, 0x13, 0xf2, 0xca, 0x8a, 0xe8, 0xe8,
	0xa9, 0xc9, 0x40, 0x01, 0xed, 0xc7, 0x50, 0xd4, 0x15, 0x63, 0x5a, 0x73, 0x1a, 0x3f, 0x28, 0x3b,
	0xfd, 0x41, 0xf6, 0x2f, 0xa1, 0x64, 0x2a, 0x16, 0x59, 0x4a, 0xe9, 0xa0, 0xb2, 0x0e, 0x2d, 0xf5,
	0xad, 0x05, 0x4f, 0xcc, 0xdb, 0xef, 0xa8, 0x80, 0x62, 0x81, 0xd4, 0x79, 0x6a, 0x32, 0xd5, 0x18,
	0xc5, 0xfe, 0x00, 0x43, 0x7f, 0x58, 0x91, 0x56, 0xa1, 0xa0, 0x6b, 0x99, 0x75, 0xe1, 0x55, 0x8d,
	0x60, 0xff, 0x3d, 0x0b, 0xd5, 0x74, 0x61, 0x9a, 0xd9, 0x36, 0xef, 0x43, 0x31, 0x60, 0x27, 0x1d,
	0x79, 0x6a, 0xf2, 0xd9, 0xd2, 0x94, 0x6a, 0xd7, 0xda, 0x45, 0x7e, 0xec, 0x64, 0xf7, 0x94, 0x7c,
	0x08, 0x25, 0x75, 0xcd, 0x7c, 0xee, 0x49, 0xa5, 0xf9, 0x89, 0xf7, 0x68, 0xcf, 0x41, 0x36, 0xbb,
	0xb4, 0x67, 0x7f, 0x0e, 0xd9, 0xdd, 0x53, 0x74, 0xb1, 0xa1, 0x78, 0x46, 0x94, 0xc5, 0x78, 0xae,
	0x55, 0xea, 0x37, 0x63, 0x2b, 0x59, 0x4d, 0x46, 0x4a, 0xcd, 0x68, 0x41, 0xab, 0x58, 0x0f, 0x95,
	0xf7, 0x5d, 0x57, 0x24, 0x33, 0xe5, 0x23, 0xfd, 0x1d, 0x68, 0x8a, 0x7d, 0x6f, 0x8f, 0xd8, 0xf7,
	0xfc, 0x38, 0xa0, 0xad, 0xfb, 0x8d, 0x05, 0xb5, 0x91, 0xfa, 0x3c, 0xb3, 0x32, 0x63, 0xad, 0x9c,
	0xc6, 0x45, 0x69, 0x79, 0x5a, 0xd9, 0x47, 0x75, 0x2a, 0xad, 0x9c, 0x46, 0x46, 0x2b, 0xab, 0xb1,
	0x06, 0x2e, 0x66, 0x74, 0x4e, 0x2b, 0xd9, 0x4b, 0xb4, 0xf2, 0x55, 0x19, 0xaa, 0xe9, 0x3e, 0x61,
	0xe6, 0xc7, 0x3c, 0x85, 0x5a, 0xdc, 0xa5, 0x0e, 0xcd, 0x52, 0x59, 0x5f, 0x9d, 0xd2, 0x83, 0xb4,
	0x4c, 0x5e, 0x8c, 0xbf, 0x3c, 0x54, 0xc3, 0xd4, 0x1e, 0x09, 0xaa, 0x11, 0x85, 0xb9, 0x86, 0x60,
	0xee, 0x72, 0x82, 0x5b, 0xfa, 0x42, 0x42, 0xd0, 0x4b, 0xed, 0x89, 0x03, 0xf5, 0x58, 0xc2, 0x9e,
	0xcf, 0xf7, 0x2e, 0xac, 0x59, 0x93, 0x44, 0xfc, 0x44, 0x5d, 0xc0, 0xce, 0x2b, 0x4c, 0x03, 0xc8,
	0x4f, 0xa0, 0x68, 0x68, 0x15, 0x26, 0xf6, 0xcd, 0x23, 0xb4, 0x12, 0x22, 0xe6, 0x8e, 0xfd, 0x95,
	0x05, 0xd5, 0xb4, 0x0e, 0xc8, 0xc3, 0x78, 0x86, 0xd3, 0xa5, 0xa5, 0x35, 0xab, 0xf2, 0x46, 0x67,
	0xba, 0x7b, 0x97, 0xcf, 0x74, 0x98, 0xfd, 0x24, 0xed, 0xc5, 0x59, 0x26, 0xf1, 0x7b, 0x05, 0xb4,
	0x4f, 0xa1, 0x9a, 0xd6, 0xe4, 0x6b, 0x89, 0x95, 0xbe, 0xf8, 0xfa, 0xa3, 0xe6, 0x5f, 0xb3, 0x50,
	0x1b, 0x51, 0x39, 0x69, 0x42, 0xae, 0xe7, 0xb9, 0xc6, 0xfd, 0xce, 0xc7, 0x20, 0x1e, 0x26, 0x5f,
	0x85, 0xd0, 0xe5, 0x0a, 0x63, 0x5f, 0x85, 0x62, 0x6e, 0xb9, 0x09, 0x4a, 0xf8, 0x0d, 0xd4, 0xcd,
	0xbc, 0xdd, 0x31, 0xe1, 0xa1, 0x3d, 0xe2, 0x83, 0x99, 0x3d, 0x22, 0x1e, 0xe0, 0x75, 0x24, 0x39,
	0x35, 0x99, 0xde, 0xda, 0xcf, 0xa0, 0x36, 0x72, 0x9e, 0xfa, 0xe0, 0x65, 0x4d, 0xfd, 0xe0, 0x45,
	0x56, 0xa0, 0x98, 0xfe, 0xac, 0x98, 0x6a, 0x00, 0x0c, 0xdc, 0x76, 0xa1, 0xf8, 0xdd, 0x6b, 0x08,
	0xe7, 0x7a, 0x35, 0x51, 0xd8, 0x7f, 0xb6, 0x60, 0x71, 0xd2, 0x80, 0x39, 0x2d, 0x7f, 0xc6, 0x15,
	0x36, 0x3b, 0xa1, 0xc2, 0x4e, 0xed, 0x5b, 0x26, 0x35, 0x42, 0xf9, 0x4b, 0x1a, 0x21, 0xfb, 0x04,
	0xde, 0x98, 0x30, 0xa5, 0xbe, 0x46, 0xd7, 0x11, 0x6b, 0xe8, 0xfc, 0x97, 0xc5, 0xe9, 0xbd, 0xc2,
	0x36, 0x54, 0x52, 0xd3, 0xec, 0x25, 0x0d, 0xc3, 0xbe, 0xe0, 0x47, 0xd3, 0x1a, 0x06, 0x3c, 0x4f,
	0xbe, 0xa6, 0xb4, 0xef, 0x3d, 0xff, 0xf7, 0x52, 0xe6, 0xf9, 0x8b, 0x25, 0xeb, 0xdb, 0x17, 0x4b,
	0xd6, 0xbf, 0x5e, 0x2c, 0x59, 0x5f, 0xbe, 0x5c, 0xca, 0x7c, 0xfb, 0x72, 0x29, 0xf3, 0x8f, 0x97,
	0x4b, 0x99, 0x67, 0xb7, 0x8e, 0x3d, 0x89, 0xf5, 0xd2, 0xe3, 0x6b, 0x7a, 0xb5, 0xd6, 0xe3, 0x6b,
	0x7b, 0x9c, 0x47, 0x52, 0xff, 0x86, 0x7b, 0x7b, 0x45, 0xf5, 0x8f, 0xcd, 0xdd, 0xff, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x2e, 0x6d, 0x6d, 0xba, 0xeb, 0x19, 0x00, 0x00,
}

func (m *SourceChannelIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceChannelIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceChannelIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x18
	}
	if m.Epoch != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if m.Token != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Token))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TableOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TableOperation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TableOperation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FlowInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Dst != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Dst))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Link) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Link) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Link) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Dst != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Dst))
		i--
		dAtA[i] = 0x10
	}
	if m.Src != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Src))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplayPathSegment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplayPathSegment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplayPathSegment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PartialKey) > 0 {
		dAtA2 := make([]byte, len(m.PartialKey)*10)
		var j1 int
		for _, num1 := range m.PartialKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPacket(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x1a
	}
	if m.ForceTagTo != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.ForceTagTo))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SourceSelection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceSelection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Selection != nil {
		{
			size := m.Selection.Size()
			i -= size
			if _, err := m.Selection.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SourceSelection_KeyShard_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection_KeyShard_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.KeyShard != nil {
		{
			size, err := m.KeyShard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SourceSelection_SameShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection_SameShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.SameShard {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *SourceSelection_AllShards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection_AllShards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintPacket(dAtA, i, uint64(m.AllShards))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *SourceSelection_KeyShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceSelection_KeyShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceSelection_KeyShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Nshards != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Nshards))
		i--
		dAtA[i] = 0x10
	}
	if m.KeyIToShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.KeyIToShard))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEndpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Trigger != nil {
		{
			size := m.Trigger.Size()
			i -= size
			if _, err := m.Trigger.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEndpoint_Start_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_Start_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TriggerEndpoint_End_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_End_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.End != nil {
		{
			size, err := m.End.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TriggerEndpoint_Local_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_Local_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Local != nil {
		{
			size, err := m.Local.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TriggerEndpoint_Start) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEndpoint_Start) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_Start) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cols) > 0 {
		dAtA8 := make([]byte, len(m.Cols)*10)
		var j7 int
		for _, num1 := range m.Cols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintPacket(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEndpoint_End) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEndpoint_End) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_End) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x10
	}
	if m.Selection != nil {
		{
			size, err := m.Selection.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TriggerEndpoint_Local) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TriggerEndpoint_Local) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TriggerEndpoint_Local) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cols) > 0 {
		dAtA11 := make([]byte, len(m.Cols)*10)
		var j10 int
		for _, num1 := range m.Cols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		i -= j10
		copy(dAtA[i:], dAtA11[:j10])
		i = encodeVarintPacket(dAtA, i, uint64(j10))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Record) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Record) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Record) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Positive {
		i--
		if m.Positive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Row) > 0 {
		i -= len(m.Row)
		copy(dAtA[i:], m.Row)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Row)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncPacket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Inner != nil {
		{
			size := m.Inner.Size()
			i -= size
			if _, err := m.Inner.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncPacket_SetupReplayPath_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_SetupReplayPath_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetupReplayPath != nil {
		{
			size, err := m.SetupReplayPath.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SyncPacket_Ready_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_Ready_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ready != nil {
		{
			size, err := m.Ready.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SyncPacket_WaitForReplay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_WaitForReplay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.WaitForReplay {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *SyncPacket_AddBaseColumn_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_AddBaseColumn_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddBaseColumn != nil {
		{
			size, err := m.AddBaseColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *SyncPacket_DropBaseColumn_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_DropBaseColumn_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DropBaseColumn != nil {
		{
			size, err := m.DropBaseColumn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *SyncPacket_SetupReplayPath) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket_SetupReplayPath) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_SetupReplayPath) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.NotifyDone {
		i--
		if m.NotifyDone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PartialUnicastSharder != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.PartialUnicastSharder))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Path) > 0 {
		for iNdEx := len(m.Path) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Path[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Source != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncPacket_Ready) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket_Ready) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_Ready) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncPacket_Ready_Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket_Ready_Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_Ready_Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA18 := make([]byte, len(m.Key)*10)
		var j17 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintPacket(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncPacket_AddBaseColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket_AddBaseColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_AddBaseColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SyncPacket_DropBaseColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncPacket_DropBaseColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncPacket_DropBaseColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Packet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.Inner != nil {
		{
			size := m.Inner.Size()
			i -= size
			if _, err := m.Inner.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Packet_Input_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Input_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Packet_Message_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Message_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Packet_Vstream_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Vstream_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vstream != nil {
		{
			size, err := m.Vstream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_ReplayPiece_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ReplayPiece != nil {
		{
			size, err := m.ReplayPiece.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Packet_Evict_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Evict_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Evict != nil {
		{
			size, err := m.Evict.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_EvictKeys_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_EvictKeys_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.EvictKeys != nil {
		{
			size, err := m.EvictKeys.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Packet_RequestPartialReplay_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RequestPartialReplay_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestPartialReplay != nil {
		{
			size, err := m.RequestPartialReplay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Packet_RequestReaderReplay_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RequestReaderReplay_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RequestReaderReplay != nil {
		{
			size, err := m.RequestReaderReplay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_StartReplay_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_StartReplay_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.StartReplay != nil {
		{
			size, err := m.StartReplay.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *Packet_AddNode_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_AddNode_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddNode != nil {
		{
			size, err := m.AddNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *Packet_Finish_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Finish_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finish != nil {
		{
			size, err := m.Finish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Packet_RemoveNodes_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RemoveNodes_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RemoveNodes != nil {
		{
			size, err := m.RemoveNodes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Packet_UpdateEgress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateEgress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateEgress != nil {
		{
			size, err := m.UpdateEgress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Packet_UpdateSharder_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateSharder_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UpdateSharder != nil {
		{
			size, err := m.UpdateSharder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Packet_PrepareState_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrepareState != nil {
		{
			size, err := m.PrepareState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Packet_Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_Input) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Input) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Senders) > 0 {
		for iNdEx := len(m.Senders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Senders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Inner != nil {
		{
			size, err := m.Inner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ignored {
		i--
		if m.Ignored {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_Vstream) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_Vstream) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Vstream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x22
	}
	if m.After != nil {
		{
			size, err := m.After.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Before != nil {
		{
			size, err := m.Before.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_ReplayPiece) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_ReplayPiece) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpquerySlot != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.UpquerySlot))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Gtid) > 0 {
		i -= len(m.Gtid)
		copy(dAtA[i:], m.Gtid)
		i = encodeVarintPacket(dAtA, i, uint64(len(m.Gtid)))
		i--
		dAtA[i] = 0x52
	}
	if m.Context != nil {
		{
			size := m.Context.Size()
			i -= size
			if _, err := m.Context.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Records) > 0 {
		for iNdEx := len(m.Records) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Records[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_ReplayPiece_Partial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_Partial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Partial != nil {
		{
			size, err := m.Partial.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Packet_ReplayPiece_Regular) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_Regular) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Regular != nil {
		{
			size, err := m.Regular.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_ReplayPiece_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Failed)
	copy(dAtA[i:], m.Failed)
	i = encodeVarintPacket(dAtA, i, uint64(len(m.Failed)))
	i--
	dAtA[i] = 0x3a
	return len(dAtA) - i, nil
}
func (m *Packet_ReplayPiece_ContextPartial) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_ReplayPiece_ContextPartial) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_ContextPartial) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ignore {
		i--
		if m.Ignore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Unishard {
		i--
		if m.Unishard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.RequestingShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.RequestingShard))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ForKeys) > 0 {
		for k := range m.ForKeys {
			v := m.ForKeys[k]
			baseI := i
			i--
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPacket(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPacket(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Packet_ReplayPiece_ContextRegular) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_ReplayPiece_ContextRegular) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_ReplayPiece_ContextRegular) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Last {
		i--
		if m.Last {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_Evict) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_Evict) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Evict) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBytes != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.NumBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_EvictKeys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_EvictKeys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_EvictKeys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.Link != nil {
		{
			size, err := m.Link.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_Finish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_Finish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_Finish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_AddNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_AddNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_AddNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parents) > 0 {
		dAtA45 := make([]byte, len(m.Parents)*10)
		var j44 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		i -= j44
		copy(dAtA[i:], dAtA45[:j44])
		i = encodeVarintPacket(dAtA, i, uint64(j44))
		i--
		dAtA[i] = 0x12
	}
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_RemoveNodes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_RemoveNodes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RemoveNodes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		dAtA48 := make([]byte, len(m.Nodes)*10)
		var j47 int
		for _, num := range m.Nodes {
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		i -= j47
		copy(dAtA[i:], dAtA48[:j47])
		i = encodeVarintPacket(dAtA, i, uint64(j47))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_UpdateEgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_UpdateEgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateEgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewTag != nil {
		{
			size, err := m.NewTag.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.NewTx != nil {
		{
			size, err := m.NewTx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_UpdateEgress_Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_UpdateEgress_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateEgress_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Local != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Local))
		i--
		dAtA[i] = 0x10
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_UpdateEgress_Tag) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_UpdateEgress_Tag) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateEgress_Tag) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_UpdateSharder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_UpdateSharder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateSharder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewTxs) > 0 {
		for iNdEx := len(m.NewTxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewTxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_UpdateSharder_Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_UpdateSharder_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_UpdateSharder_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Domain != nil {
		{
			size, err := m.Domain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Local != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Local))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != nil {
		{
			size := m.State.Size()
			i -= size
			if _, err := m.State.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_PartialLocal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialLocal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartialLocal != nil {
		{
			size, err := m.PartialLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Packet_PrepareState_IndexedLocal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_IndexedLocal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.IndexedLocal != nil {
		{
			size, err := m.IndexedLocal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_PrepareState_PartialGlobal_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialGlobal_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PartialGlobal != nil {
		{
			size, err := m.PartialGlobal.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Packet_PrepareState_Global_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_Global_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Global != nil {
		{
			size, err := m.Global.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Packet_PrepareState_PartialLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_PartialLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_PartialLocal_Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_PartialLocal_Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialLocal_Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tags) > 0 {
		dAtA58 := make([]byte, len(m.Tags)*10)
		var j57 int
		for _, num := range m.Tags {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintPacket(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		dAtA60 := make([]byte, len(m.Key)*10)
		var j59 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintPacket(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_IndexedLocal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_IndexedLocal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_IndexedLocal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Index) > 0 {
		for iNdEx := len(m.Index) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Index[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPacket(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_IndexedLocal_Index) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_IndexedLocal_Index) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_IndexedLocal_Index) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA62 := make([]byte, len(m.Key)*10)
		var j61 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		i -= j61
		copy(dAtA[i:], dAtA62[:j61])
		i = encodeVarintPacket(dAtA, i, uint64(j61))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_PartialGlobal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_PartialGlobal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialGlobal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TriggerDomain != nil {
		{
			size, err := m.TriggerDomain.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPacket(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Key) > 0 {
		dAtA65 := make([]byte, len(m.Key)*10)
		var j64 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintPacket(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cols != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shards != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Shards))
		i--
		dAtA[i] = 0x10
	}
	if m.Domain != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_PrepareState_Global) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_PrepareState_Global) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_PrepareState_Global) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA67 := make([]byte, len(m.Key)*10)
		var j66 int
		for _, num1 := range m.Key {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintPacket(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x1a
	}
	if m.Cols != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x10
	}
	if m.Gid != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Gid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_RequestPartialReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_RequestPartialReplay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RequestPartialReplay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestingShard != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.RequestingShard))
		i--
		dAtA[i] = 0x20
	}
	if m.Unishard {
		i--
		if m.Unishard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_RequestReaderReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_RequestReaderReplay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_RequestReaderReplay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintPacket(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Cols) > 0 {
		dAtA69 := make([]byte, len(m.Cols)*10)
		var j68 int
		for _, num1 := range m.Cols {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintPacket(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x12
	}
	if m.Node != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Node))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Packet_StartReplay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Packet_StartReplay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Packet_StartReplay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.From != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.From))
		i--
		dAtA[i] = 0x10
	}
	if m.Tag != 0 {
		i = encodeVarintPacket(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPacket(dAtA []byte, offset int, v uint64) int {
	offset -= sovPacket(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SourceChannelIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Token != 0 {
		n += 1 + sovPacket(uint64(m.Token))
	}
	if m.Epoch != 0 {
		n += 1 + sovPacket(uint64(m.Epoch))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	return n
}

func (m *TableOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *FlowInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Dst != 0 {
		n += 1 + sovPacket(uint64(m.Dst))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Link) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != 0 {
		n += 1 + sovPacket(uint64(m.Src))
	}
	if m.Dst != 0 {
		n += 1 + sovPacket(uint64(m.Dst))
	}
	return n
}

func (m *ReplayPathSegment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.ForceTagTo != 0 {
		n += 1 + sovPacket(uint64(m.ForceTagTo))
	}
	if len(m.PartialKey) > 0 {
		l = 0
		for _, e := range m.PartialKey {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *SourceSelection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selection != nil {
		n += m.Selection.Size()
	}
	return n
}

func (m *SourceSelection_KeyShard_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyShard != nil {
		l = m.KeyShard.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *SourceSelection_SameShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *SourceSelection_AllShards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovPacket(uint64(m.AllShards))
	return n
}
func (m *SourceSelection_KeyShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyIToShard != 0 {
		n += 1 + sovPacket(uint64(m.KeyIToShard))
	}
	if m.Nshards != 0 {
		n += 1 + sovPacket(uint64(m.Nshards))
	}
	return n
}

func (m *TriggerEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Trigger != nil {
		n += m.Trigger.Size()
	}
	return n
}

func (m *TriggerEndpoint_Start_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *TriggerEndpoint_End_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *TriggerEndpoint_Local_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != nil {
		l = m.Local.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *TriggerEndpoint_Start) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *TriggerEndpoint_End) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Selection != nil {
		l = m.Selection.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Domain != 0 {
		n += 1 + sovPacket(uint64(m.Domain))
	}
	return n
}

func (m *TriggerEndpoint_Local) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Record) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Row)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Positive {
		n += 2
	}
	return n
}

func (m *SyncPacket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		n += m.Inner.Size()
	}
	return n
}

func (m *SyncPacket_SetupReplayPath_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetupReplayPath != nil {
		l = m.SetupReplayPath.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *SyncPacket_Ready_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ready != nil {
		l = m.Ready.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *SyncPacket_WaitForReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *SyncPacket_AddBaseColumn_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddBaseColumn != nil {
		l = m.AddBaseColumn.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *SyncPacket_DropBaseColumn_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DropBaseColumn != nil {
		l = m.DropBaseColumn.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *SyncPacket_SetupReplayPath) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Source != 0 {
		n += 1 + sovPacket(uint64(m.Source))
	}
	if len(m.Path) > 0 {
		for _, e := range m.Path {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.PartialUnicastSharder != 0 {
		n += 1 + sovPacket(uint64(m.PartialUnicastSharder))
	}
	if m.NotifyDone {
		n += 2
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *SyncPacket_Ready) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *SyncPacket_Ready_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *SyncPacket_AddBaseColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SyncPacket_DropBaseColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Packet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		n += m.Inner.Size()
	}
	if m.Id != 0 {
		n += 2 + sovPacket(uint64(m.Id))
	}
	return n
}

func (m *Packet_Input_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_Message_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_Vstream_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vstream != nil {
		l = m.Vstream.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_ReplayPiece_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReplayPiece != nil {
		l = m.ReplayPiece.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_Evict_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Evict != nil {
		l = m.Evict.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_EvictKeys_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EvictKeys != nil {
		l = m.EvictKeys.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_RequestPartialReplay_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestPartialReplay != nil {
		l = m.RequestPartialReplay.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_RequestReaderReplay_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequestReaderReplay != nil {
		l = m.RequestReaderReplay.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_StartReplay_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartReplay != nil {
		l = m.StartReplay.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_AddNode_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddNode != nil {
		l = m.AddNode.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_Finish_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finish != nil {
		l = m.Finish.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_RemoveNodes_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RemoveNodes != nil {
		l = m.RemoveNodes.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_UpdateEgress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateEgress != nil {
		l = m.UpdateEgress.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_UpdateSharder_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UpdateSharder != nil {
		l = m.UpdateSharder.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_PrepareState_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrepareState != nil {
		l = m.PrepareState.Size()
		n += 2 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Inner != nil {
		l = m.Inner.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Senders) > 0 {
		for _, e := range m.Senders {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.Ignored {
		n += 2
	}
	return n
}

func (m *Packet_Vstream) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Packet_ReplayPiece) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Records) > 0 {
		for _, e := range m.Records {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.Context != nil {
		n += m.Context.Size()
	}
	l = len(m.Gtid)
	if l > 0 {
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.UpquerySlot != 0 {
		n += 1 + sovPacket(uint64(m.UpquerySlot))
	}
	return n
}

func (m *Packet_ReplayPiece_Partial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Partial != nil {
		l = m.Partial.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_ReplayPiece_Regular) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Regular != nil {
		l = m.Regular.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_ReplayPiece_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Failed)
	n += 1 + l + sovPacket(uint64(l))
	return n
}
func (m *Packet_ReplayPiece_ContextPartial) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ForKeys) > 0 {
		for k, v := range m.ForKeys {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPacket(uint64(len(k))) + 1 + 1
			n += mapEntrySize + 1 + sovPacket(uint64(mapEntrySize))
		}
	}
	if m.RequestingShard != 0 {
		n += 1 + sovPacket(uint64(m.RequestingShard))
	}
	if m.Unishard {
		n += 2
	}
	if m.Ignore {
		n += 2
	}
	return n
}

func (m *Packet_ReplayPiece_ContextRegular) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Last {
		n += 2
	}
	return n
}

func (m *Packet_Evict) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.NumBytes != 0 {
		n += 1 + sovPacket(uint64(m.NumBytes))
	}
	return n
}

func (m *Packet_EvictKeys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Link != nil {
		l = m.Link.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_Finish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	return n
}

func (m *Packet_AddNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Packet_RemoveNodes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		l = 0
		for _, e := range m.Nodes {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Packet_UpdateEgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.NewTx != nil {
		l = m.NewTx.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	if m.NewTag != nil {
		l = m.NewTag.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Packet_UpdateEgress_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.Local != 0 {
		n += 1 + sovPacket(uint64(m.Local))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Packet_UpdateEgress_Tag) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	return n
}

func (m *Packet_UpdateSharder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.NewTxs) > 0 {
		for _, e := range m.NewTxs {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_UpdateSharder_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Local != 0 {
		n += 1 + sovPacket(uint64(m.Local))
	}
	if m.Domain != nil {
		l = m.Domain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Packet_PrepareState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if m.State != nil {
		n += m.State.Size()
	}
	return n
}

func (m *Packet_PrepareState_PartialLocal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartialLocal != nil {
		l = m.PartialLocal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_PrepareState_IndexedLocal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IndexedLocal != nil {
		l = m.IndexedLocal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_PrepareState_PartialGlobal_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartialGlobal != nil {
		l = m.PartialGlobal.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_PrepareState_Global_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Global != nil {
		l = m.Global.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}
func (m *Packet_PrepareState_PartialLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_PrepareState_PartialLocal_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if len(m.Tags) > 0 {
		l = 0
		for _, e := range m.Tags {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Packet_PrepareState_IndexedLocal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Index) > 0 {
		for _, e := range m.Index {
			l = e.Size()
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_PrepareState_IndexedLocal_Index) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Packet_PrepareState_PartialGlobal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovPacket(uint64(m.Gid))
	}
	if m.Cols != 0 {
		n += 1 + sovPacket(uint64(m.Cols))
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if m.TriggerDomain != nil {
		l = m.TriggerDomain.Size()
		n += 1 + l + sovPacket(uint64(l))
	}
	return n
}

func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != 0 {
		n += 1 + sovPacket(uint64(m.Domain))
	}
	if m.Shards != 0 {
		n += 1 + sovPacket(uint64(m.Shards))
	}
	return n
}

func (m *Packet_PrepareState_Global) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Gid != 0 {
		n += 1 + sovPacket(uint64(m.Gid))
	}
	if m.Cols != 0 {
		n += 1 + sovPacket(uint64(m.Cols))
	}
	if len(m.Key) > 0 {
		l = 0
		for _, e := range m.Key {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	return n
}

func (m *Packet_RequestPartialReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	if m.Unishard {
		n += 2
	}
	if m.RequestingShard != 0 {
		n += 1 + sovPacket(uint64(m.RequestingShard))
	}
	return n
}

func (m *Packet_RequestReaderReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != 0 {
		n += 1 + sovPacket(uint64(m.Node))
	}
	if len(m.Cols) > 0 {
		l = 0
		for _, e := range m.Cols {
			l += sovPacket(uint64(e))
		}
		n += 1 + sovPacket(uint64(l)) + l
	}
	if len(m.Keys) > 0 {
		for _, s := range m.Keys {
			l = len(s)
			n += 1 + l + sovPacket(uint64(l))
		}
	}
	return n
}

func (m *Packet_StartReplay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tag != 0 {
		n += 1 + sovPacket(uint64(m.Tag))
	}
	if m.From != 0 {
		n += 1 + sovPacket(uint64(m.From))
	}
	return n
}

func sovPacket(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPacket(x uint64) (n int) {
	return sovPacket(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SourceChannelIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceChannelIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceChannelIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			m.Token = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Token |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TableOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TableOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TableOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= TableOperation_Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = Row(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			m.Dst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dst |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &TableOperation{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Link) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			m.Src = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Src |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			m.Dst = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dst |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplayPathSegment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplayPathSegment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplayPathSegment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForceTagTo", wireType)
			}
			m.ForceTagTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForceTagTo |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PartialKey = append(m.PartialKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PartialKey) == 0 {
					m.PartialKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PartialKey = append(m.PartialKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialKey", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceSelection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceSelection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceSelection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceSelection_KeyShard{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Selection = &SourceSelection_KeyShard_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SameShard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Selection = &SourceSelection_SameShard{b}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllShards", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Selection = &SourceSelection_AllShards{v}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceSelection_KeyShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIToShard", wireType)
			}
			m.KeyIToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyIToShard |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nshards", wireType)
			}
			m.Nshards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nshards |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TriggerEndpoint_Start{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &TriggerEndpoint_Start_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TriggerEndpoint_End{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &TriggerEndpoint_End_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TriggerEndpoint_Local{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Trigger = &TriggerEndpoint_Local_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEndpoint_Start) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Start: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Start: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEndpoint_End) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: End: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: End: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Selection", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Selection == nil {
				m.Selection = &SourceSelection{}
			}
			if err := m.Selection.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TriggerEndpoint_Local) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Local: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Local: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Record) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Record: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Record: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Row = Row(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Positive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Positive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncPacket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncPacket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetupReplayPath", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncPacket_SetupReplayPath{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &SyncPacket_SetupReplayPath_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ready", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncPacket_Ready{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &SyncPacket_Ready_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitForReplay", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Inner = &SyncPacket_WaitForReplay{b}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddBaseColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncPacket_AddBaseColumn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &SyncPacket_AddBaseColumn_{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropBaseColumn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncPacket_DropBaseColumn{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &SyncPacket_DropBaseColumn_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket_SetupReplayPath) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetupReplayPath: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetupReplayPath: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, &ReplayPathSegment{})
			if err := m.Path[len(m.Path)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialUnicastSharder", wireType)
			}
			m.PartialUnicastSharder = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartialUnicastSharder |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotifyDone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NotifyDone = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &TriggerEndpoint{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket_Ready) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ready: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ready: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &SyncPacket_Ready_Index{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket_Ready_Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket_AddBaseColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddBaseColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddBaseColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncPacket_DropBaseColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropBaseColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropBaseColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Packet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Packet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_Input{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_Input_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_Message{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_Message_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_Vstream{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_Vstream_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplayPiece", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_ReplayPiece{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_ReplayPiece_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evict", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_Evict{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_Evict_{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvictKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_EvictKeys{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_EvictKeys_{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestPartialReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_RequestPartialReplay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_RequestPartialReplay_{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestReaderReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_RequestReaderReplay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_RequestReaderReplay_{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartReplay", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_StartReplay{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_StartReplay_{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_AddNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_AddNode_{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_Finish{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_Finish_{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_RemoveNodes{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_RemoveNodes_{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateEgress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_UpdateEgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_UpdateEgress_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateSharder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_UpdateSharder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_UpdateSharder_{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_PrepareState{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Inner = &Packet_PrepareState_{v}
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inner == nil {
				m.Inner = &FlowInput{}
			}
			if err := m.Inner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &SourceChannelIdentifier{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Senders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Senders = append(m.Senders, &SourceChannelIdentifier{})
			if err := m.Senders[len(m.Senders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, Record{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ignored = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_Vstream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Record{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Record{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_ReplayPiece) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplayPiece: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplayPiece: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Records", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Records = append(m.Records, Record{})
			if err := m.Records[len(m.Records)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_ReplayPiece_ContextPartial{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &Packet_ReplayPiece_Partial{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regular", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_ReplayPiece_ContextRegular{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Context = &Packet_ReplayPiece_Regular{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = &Packet_ReplayPiece_Failed{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gtid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gtid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpquerySlot", wireType)
			}
			m.UpquerySlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpquerySlot |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_ReplayPiece_ContextPartial) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextPartial: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextPartial: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForKeys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ForKeys == nil {
				m.ForKeys = make(map[Row]bool)
			}
			var mapkey Row
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPacket
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = Row(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPacket(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPacket
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ForKeys[Row(mapkey)] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestingShard", wireType)
			}
			m.RequestingShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestingShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unishard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unishard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ignore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ignore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_ReplayPiece_ContextRegular) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextRegular: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextRegular: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Last", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Last = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_Evict) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Evict: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Evict: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBytes", wireType)
			}
			m.NumBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_EvictKeys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EvictKeys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EvictKeys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Link == nil {
				m.Link = &Link{}
			}
			if err := m.Link.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_Finish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_AddNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &Node{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v LocalNodeIndex
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LocalNodeIndex(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parents) == 0 {
					m.Parents = make([]LocalNodeIndex, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LocalNodeIndex
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LocalNodeIndex(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_RemoveNodes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveNodes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveNodes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v LocalNodeIndex
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= LocalNodeIndex(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Nodes = append(m.Nodes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Nodes) == 0 {
					m.Nodes = make([]LocalNodeIndex, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v LocalNodeIndex
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= LocalNodeIndex(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Nodes = append(m.Nodes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_UpdateEgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateEgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateEgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewTx == nil {
				m.NewTx = &Packet_UpdateEgress_Tx{}
			}
			if err := m.NewTx.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTag", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewTag == nil {
				m.NewTag = &Packet_UpdateEgress_Tag{}
			}
			if err := m.NewTag.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_UpdateEgress_Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			m.Local = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Local |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainAddr{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_UpdateEgress_Tag) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tag: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tag: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_UpdateSharder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSharder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSharder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewTxs = append(m.NewTxs, &Packet_UpdateSharder_Tx{})
			if err := m.NewTxs[len(m.NewTxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_UpdateSharder_Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Local", wireType)
			}
			m.Local = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Local |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Domain == nil {
				m.Domain = &DomainAddr{}
			}
			if err := m.Domain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrepareState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrepareState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_PrepareState_PartialLocal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Packet_PrepareState_PartialLocal_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexedLocal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_PrepareState_IndexedLocal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Packet_PrepareState_IndexedLocal_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialGlobal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_PrepareState_PartialGlobal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Packet_PrepareState_PartialGlobal_{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Global", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Packet_PrepareState_Global{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.State = &Packet_PrepareState_Global_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_PartialLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &Packet_PrepareState_PartialLocal_Index{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_PartialLocal_Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 2:
			if wireType == 0 {
				var v Tag
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Tag(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Tags = append(m.Tags, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Tags) == 0 {
					m.Tags = make([]Tag, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Tag
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Tag(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Tags = append(m.Tags, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_IndexedLocal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexedLocal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexedLocal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Index = append(m.Index, &Packet_PrepareState_IndexedLocal_Index{})
			if err := m.Index[len(m.Index)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_IndexedLocal_Index) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Index: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Index: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_PartialGlobal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PartialGlobal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PartialGlobal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerDomain", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TriggerDomain == nil {
				m.TriggerDomain = &Packet_PrepareState_PartialGlobal_TriggerDomain{}
			}
			if err := m.TriggerDomain.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_PartialGlobal_TriggerDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TriggerDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TriggerDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= DomainIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_PrepareState_Global) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Global: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Global: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gid", wireType)
			}
			m.Gid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gid |= GraphNodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Key = append(m.Key, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Key) == 0 {
					m.Key = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Key = append(m.Key, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_RequestPartialReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestPartialReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestPartialReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unishard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unishard = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestingShard", wireType)
			}
			m.RequestingShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestingShard |= uint(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_RequestReaderReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestReaderReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestReaderReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			m.Node = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Node |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cols = append(m.Cols, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPacket
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPacket
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPacket
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Cols) == 0 {
					m.Cols = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPacket
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cols = append(m.Cols, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPacket
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPacket
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, Row(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Packet_StartReplay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartReplay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartReplay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= Tag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= LocalNodeIndex(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPacket(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPacket
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPacket(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPacket
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPacket
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPacket
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPacket
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPacket
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPacket        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPacket          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPacket = fmt.Errorf("proto: unexpected end of group")
)
