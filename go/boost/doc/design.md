# A new design for Boost

> This is a technical overview of the new architecture for Boost which we launched in early 2023. The main goal of this document is serving as an accurate technical description to be shared with our Patent Lawyers as part of finalizing our current patent process. It is also intended as an on-boarding tool for engineers who need to hack on Boost-related parts of Vitess. **It is not meant for public consumption**.

### In the beginning, there was Noria

The first beta version of Boost, which we soft-launched in November 2022, was based on the same architecture as Noria. Noria is an experimental OSS database designed by Jon Gjengset as part of his [PhD Thesis](https://jon.thesquareplanet.com/papers/phd-thesis.pdf). The code for Noria is [Open Source on GitHub](https://github.com/mit-pdos/noria), and it was initially presented in [a technical paper](https://jon.tsp.io/papers/osdi18-noria.pdf) at [OSDI'18](https://www.usenix.org/conference/osdi18/presentation/gjengset).

The key-point in Noria's design is that **it is a standalone database system**. This is in contrast to Boost, which is _not_ a standalone database system but a supplementary distributed system that acts as a caching layer on top of an existing database – in this case, a full Vitess cluster.

As a standalone database, Noria has a data storage layer. The actual data inserted into a Noria system is stored in a key-value database powered by [RocksDB](https://rocksdb.org/), with each table occupying a RocksDB namespace. That is the extent of the data storage capabilities that the Noria system possesses: it can insert data into these tables, and query data by its primary key. It also keeps secondary indexes for when the data needs to be queried by another column. 

In order to actually fulfill its purpose as a SQL-compatible database, Noria needs to transform the individual rows stored in the tables into the results of the SQL query that the user has requested. This is the core of Noria’s paper and PhD thesis. Noria is not a database that can be queried by arbitrary SQL queries. Instead, Noria needs to know ahead of time the exact queries that the user will be performing on the database, and based on this information, it creates a dataflow graph: a tree where the roots are the tables where the row data is stored (henceforth known as “bases”) and where the leaves are either fully or partially materialized views that represent each user’s specific SQL query (henceforth known as “readers”).

Between the Bases and the Readers, the dataflow graph contains a series of SQL operators that perform the actual transformations requested by the user (things like aggregating rows, transforming the values of columns, joining them, etc). If we consider this system where all the Readers are fully materialized views (i.e. where each Reader contains all the rows that could possibly be requested by a user’s query), the design of Noria is very similar to a traditional materialization engine, and not really novel. The fully materialized view acts as a fully populated table that can be queried by one or more constraints that exist in the user’s original query. For instance, a query like `SELECT table.a, SUM(table.b) FROM table WHERE table.a = ?` would result in a table keyed by `table.a` where each value contains the pre-computed value for `table.a, SUM(table.b)` for the given value of `table.a`.  In order to generate this table, which is capable of efficiently serving the user’s specific SQL query by converting it into a key-lookup, we need to do two things:

1. When the Noria system boots up, it needs to iterate through all the individual rows in the Bases, and pass them through all the SQL operators in the flow graph for this specific query, so the relevant transformations are applied (i.e. the `SUM` in this example) and the fully materialized view can be populated.
2. While the Noria system is running, every time a user inserts, deletes or updates data into the Bases, the new data needs to be passed through all the SQL operators in the flow graph, so that the fully materialized view can be kept up to date.

This is, again, very similar to a traditional materialization engine, and not particularly interesting.

The interesting part is when we consider the Readers as _partially_ materialized views: this is the key novel concept in Gjengset’s PhD thesis. A partially materialized view behaves like a fully materialized view, but it contains _gaps_ or _missing keys_. Its table is not fully populated. The behavior of this table is very different:

1. When the Noria system boots up, it does _not_ need to iterate through all the existing rows in the Bases. The final partially materialized view can start as an empty table.
2. While the Noria system is running, every time a user modifies data, it still needs this modification to be passed through the flow graph – although most of the time the information about these modifications will be discarded.

The main reason to have a _partially_ materialized view is to minimize the amount of data to be processed and the memory that the view will occupy in our system, as to not actively hold and maintain up-to-date rows that will be rarely read by the user. The partially materialized view always starts up being _empty_, and it only acquires data _lazily_, when the user requests it.

The process of data acquisition when a user _misses_ during a read to a partial view is one of the most complex technical details in the design of Noria. Let’s dive into it.

### Misses in Noria

We have seen how Noria keeps materialized state in several of the operators in its dataflow graph: on-disk state on its Bases (persisted with RocksDB) and in-memory state on its Readers. However, these are not the only places where state is kept. Noria also keeps memory tables used to calculate the output of many of the possible SQL operators in the dataflow. For instance, aggregation operators need to materialize the individual counts of the aggregation so they can be updated incrementally.

These intermediate materializations must be taken into account when _resolving_ misses in the system. When a request for a specific key arrives and the key is missing in the memory table for the Reader, the system attempts to resolve the miss _recursively_ by asking **the first ancestor of the Reader in the dataflow graph that has materialized state**. The operation of asking an ancestor to fill a miss is called an **upquery** throughout the Noria paper and dissertation. If this ancestor contains the desired data, the miss is resolved by triggering **a replay**. A replay means passing these rows through the dataflow graph all the way to the reader, so that they result in filling the target key on which we missed. If this ancestor with materialized state does not contain the data we require, then we recurse to the next ancestor with materialized state and perform the upquery there. This recursion resolves itself elegantly: if the second-order ancestor (this is, the ancestor of the ancestor) has the data, we trigger a replay which fills the miss in the first ancestor, and then this ancestor triggers its own replay, finally filling the miss on the Reader. Often, despite the intermediate state, a Miss on a Reader must fall back all the way to a Base. The recursive algorithm will always stop at the Base, because a Base is always _fully materialized_. It cannot miss.

This recursive algorithm is elegant, but not efficient. Although in some particular SQL dataflow graphs a replay is a quite efficient operation, most often it becomes a pathological performance issue. Picture a simple dataflow where we’re trying to fill a miss for the `COUNT(*)` of all the rows filtered by a specific column (`SELECT COUNT(*) from tbl where tbl.a = ?`). When we miss for any of the values of `tbl.a`, we trigger an upquery to the immediate ancestor, which here is the aggregation operator. Assuming the operator also misses, we need to fall back to the Base for `tbl`. The Base will not miss, but it will need to replay what we previously described as “required data” – in this case, all the rows in `tbl` where `tbl.a` equals our miss key. This could be millions, or even billions of rows! And they all need to be replayed, one by one, into the aggregation operator which will simply count them and store their count.

This extremely common case, which applies to any SQL query that performs an aggregation or grouping, can also be generalized to more SQL operators. The underlying issue is that Noria, as a stand-alone database system, does not have support for _directly executing SQL queries_. All it can do is feed individual rows through the SQL operators in its dataflow to compute the final results, but in many cases these calculations require millions of rows as an input. In practical effects, this means that filling misses in Noria is often tens or hundreds of times slower than just directly calculating the query in a traditional relational database.

### The first version of Boost

For the first prototype of Boost, and all the way to its first beta release, we followed Noria’s architecture very closely. Although Boost is implemented as a Go service in the Vitess codebase, we ported over a lot of the abstractions and designs in Noria’s Rust code. There were of course significant changes to be done, because after all Boost was implemented as a _cache_ on top of a Vitess cluster, while Noria was a stand-alone database.

The first major change was replacing the concept of a Base from Noria with an External Base. As a cache, Boost didn’t keep its own data. It had the underlying MySQL shards of the Vitess cluster as an authoritative source of truth. Hence, there was no need for a Base that stored individual rows. The roots of the dataflow graph in a Boost instance are an abstraction called External Base, which behave very similarly to a Base in Noria. Namely, they can be upqueried for the required data during misses, and they can replay this data into the Boost cluster; instead of replaying from disk like a Base in Noria, they replay over the network from the relevant MySQL instances. We call the process of performing an upquery on an External Base an **external upquery**. These external upqueries are handled by a version of Vitess’ client routing code, similarly to how a VTGate would serve an arbitrary SQL query.

The second major change is a consequence of removing Bases. Since the system doesn’t contain an authoritative source of the data like in Noria, we need a way to keep the system up to date. In the original Noria, when a write (insert, update or delete) came into the system, it would be applied directly to the base, and then forwarded through the dataflow operators to keep them updated. Writes into a Vitess cluster do not go through Boost —only reads do—, so to stay updated we have to subscribe to the VStream of the cluster (this is, an aggregation of the binary logs of all the MySQL instances in the cluster). This subscription allows us to witness changes to the underlying data, with some latency, and to pass them through the dataflow to keep our cached data up to date, but they introduce a complex data race.

As we’ve just explained, when a there’s a miss in a Boost Reader, we apply the same algorithm as Noria did — a recursive algorithm that will often fall back all the way to the base in order to trigger a replay of the missing data. In our case, the Base is not a local on-disk table but the existing Vitess cluster, so the replay will be the output of a specifically crafted SQL query to fetch the relevant rows from the MySQL instances. This external upquery, which can be triggered at any point as part of resolving a miss, is inherently racy with the changes we receive from the VStream. There can be rows in the query which are going to fill the miss and which we’ve never seen before, because they’ve just been inserted or updated in the underlying cluster. Since these are new rows, they could also be arriving at the exact same moment through the VStream subscription. Hence, the dataflow operators would process the same rows twice, leading to incorrect or inconsistent results.

To solve this problem, we developed an algorithm that is applied on each external base of the system and which uses GTID tracking to prioritize or mark rows as duplicate from the External Base queries and the VStream as to ensure there are rows processed twice through the dataflow. **This is the main subject of our preliminary patent filing for Boost**.

These two modifications are the main differentiators between Noria and Boost, and this is the design we launched as a limited beta on late November. However, after actual production testing of the system, we uncovered two glaring issues which forced us to re-architect Boost:

1. The underlying performance issue in Noria’s design, caused by having to replay individual rows from the Bases, is exacerbated by replacing the Bases with an external source of data.
2. The GTID tracker is not logically correct in all circumstances, and hence our preliminary patent filing is not particularly useful. The system is still vulnerable to seeing duplicated data in some dataflow layouts, which we will discuss later.

### The terrible performance of misses

We had suspicions that the way Noria handled misses would also affect Boost, as the design for filling misses was essentially identical, but it turned out that the problem was much worse. Replaying individual rows over the network was an order of magnitude more expensive than replaying them from local storage, mostly because of latency and (de)serialization costs. In practice, the performance when filling misses in Boost was so bad that most Boost queries that missed would simply time out.

The reason why the miss-filling algorithm in Noria is recursive is because it cannot compute SQL expressions directly. Upqueries would always end up missing throughout the dataflow all the way to a Base, because when you upquery an intermediate operator in Noria and the data is missing, the only possible way to fill this data is by replaying every individual row that is required to compute the data through the operator. This is incredibly inefficient.

The new algorithm exploits the fact that our underlying data store, a Vitess cluster backed by several MySQL instances, can actually compute SQL expressions without needing to replay data. It works as follows:

1. When a query misses on a Reader, instead of falling back to the first immediate parent with a partial materialization, we fall back to the _last one_. That is, we target the first partially materialized node in the dataflow when walking from the External Base.
2. This node, just like all the other nodes with state in the graph, has been extended with an _external upquery_ for the node, calculated at plan time. This means that our planner, after decomposing all the SQL primitives in the original query into individual operators for the dataflow, also extends each operator with its reverse-equivalent SQL expression.
3. To fill the miss on the target node, we perform the reverse-equivalent SQL expression for the operator in our upstream database. We use Vitess’ internal routing logic (the same logic that can be found inside a VTGate) to route the complex SQL across shards.
4. The results of this query are **not** considered a replay, as they do not contain _individual rows_ to be forwarded through the dataflow operator. Instead, these results are specifically tagged so that they fill the state in the target node by being _inserted directly_ into its state table, not processed (note that the “processing” that would be performed on the rows of a replay has already been performed by MySQL here).
5. If necessary, once the state has been filled, a replay is triggered to forward the new rows downstream all the way to the Reader.

To highlight the importance of point 4, let us see the difference between the way Noria and Boost would fill a miss on our previous example query (`SELECT COUNT(*) FROM tbl WHERE tbl.a = ?`). In an original Noria replay, to fill the miss for value `X`, the aggregation operator node would receive a replay containing all the rows in `tbl` where `tbl.a = X`. Then, it would process each row individually, accumulate their count, and store their count `C` in its state table. The result `C` is the single-row, single-column output of the operator, which will then be forwarded through any downstream operators in the dataflow until the miss is filled in the Reader. Hence, the aggregation operator has processed an arbitrary amount of rows, $O(n)$ with the total number of rows in the underlying table.

In contrast, the new algorithm in Boost would fill the miss by acquiring the reverse-equivalent SQL expression for the operator and extending it with a filter by `X`. In this particular example, the resulting query would be something almost identical to the user’s original query (e.g. `SELECT COUNT(*) FROM tbl WHERE tbl.a = X`), because the dataflow for this query is trivial, but for more complex and nested queries, the reverse-equivalent expression for an operator is usually a subset of the user’s original query. The composed query is then performed directly on the Vitess cluster, and the result `C` is _inserted directly_ into the state table for the operator, and forwarded downstream until it reaches the Reader. Note that the operator has not actually _processed_ the result of the external upquery — the processing has been performed by MySQL, which is why we receive a single row as the result, as opposed to $N$ individual rows that must be counted in Boost.

Lastly, also note that the design decision in point 1 is not mandatory: these external upqueries have been implemented on the nearest materialized node _from the External Base_ as a simplification. They could be performed at any height in the dataflow graph, but if the upqueried operator is not directly reachable from the External Base, all the other partially materialized operators above it will not become aware of the fact that new state has been filled downstream, so any updates that arrive through our VStream subscription will be discarded before they can reach the node with the newly filled state, so this state will become stale. This issue can be fixed (e.g. by adding “gaps” to all the upstream operators after receiving the result of the external upquery), but it has been implemented in its simplified form because that covers a large majority of currently known cases. The extended form can be implemented in the future if it turns out we have query patterns where this is necessary.

Overall, this new design to fill misses in the Boost cluster is wildly more efficient than the original design of Noria. The external upqueries performed in the middle of the dataflow allow us to fill a miss with performance that is _at worst_ equivalent to MySQL computing the query itself, and often much faster. The amount of data transmitted from Vitess to the Boost instance has been cut by orders of magnitude. However, the design introduces new complexity in the aforementioned data race, which we had to solve separately.

### Data races at any depth of the dataflow graph

The major change described in the previous section implies that upqueries (queries to the external Vitess cluster), which were previously performed solely on External Bases, can now be performed at any depth of the dataflow. The results of the original upqueries were always _replays_, because we were fetching ranges of individual rows from the underlying Base table. In these new upqueries performed on arbitrary SQL operators, the results are _not_ replays, because they contain the final results that need to be stored in the state tables, not the individual rows that must be processed by the operator. And yet these results are also vulnerable to the same data race between VStream changes and upquery rows which we’ve already discussed.

As we anticipated earlier, the way we initially fixed the data race was not fully correct. Let us understand the underlying issue in the previous version of the fix and see how a proper fix can also be applied to this more general problem:

The original fix, as described in the initial patent filing, keeps state in each of the External Bases of a Boost dataflow graph to ensure that rows that have been recently been seen in a VStream change event cannot be seen again in an in-flight upquery, and vice-versa. This check, which is performed essentially by comparing GTIDs, was performed _on the External Base_ itself. Incoming VStream changes were compared against the recent set of upqueries performed to the external base.

We can immediately intuit that this design will _not_ work after our new design for filling misses, because we no longer perform upqueries at the external base! The requests to the underlying Vitess cluster can be performed on any partially materialized operator throughout the dataflow graph, so filtering incoming change events cannot be performed in the External Base. It needs to be performed separately on each operator that can perform an external query. But simply porting our algorithm from the External Bases to all their children nodes is not enough to correctly fix the problem, as the underlying issue that applied to these bases is also relevant throughout when performing the algorithm on any other operator node.

The reason why this algorithm is not fully correct relates to the shape of the dataflow graph. Although in this document the graph of Bases, Readers and SQL operators has been discussed as a _tree_ (with a set of roots and leaves), in production environments it often looks more like a Directed Acyclic Graph (_DAG_), because individual nodes can be reused by more than one query.

The most obvious example of this are External Bases. If we have a Boost instance that is caching more than one query, and these queries depend on the same underlying SQL table, the dataflow will contain only _one_ External Base that represents the given SQL table, and this node will be shared by the dataflow of two or more queries. This generalizes to _any other SQL operator throughout the dataflow_. One of the important properties of Noria, which we’ve inherited in Boost, is that queries that share common patterns or subqueries can be efficiently cached by reusing parts of the dataflow, as to prevent the same partial state from being materialized more than once. This is a very powerful optimization in practice, but it complicates the algorithm to deduplicate rows between upqueries and VStream changes.

When analyzing the dataflow graph as a DAG, it becomes apparent that a VStream change event that arrives through a specific External Base must be fanned out to _all the children_ of this external base (which, as we’ve just explained, can be more than one because of node reuse), and for each one of those children, the change event must be fanned out again, and so on recursively. The event must be replicated throughout all the branches of the graph, because materialized state can exist on any SQL operator reachable from the External Base.

However, if we perform the same DAG analysis for the response of an external upquery (whether the result is a set of rows from an external base, or a final answer from an intermediate SQL operator), the resulting replay from the upquery will only be sent through the single path of the DAG that reaches the initial Reader that originally triggered a miss.

This dichotomy between the way VStream events are fully relayed through the DAG and upstream responses are relayed solely through _one path_ causes the original algorithm we designed to be incorrect. When a VStream event arrives through an External Base, we used to check if any of the upquery results that were recently received through the same base contained a row that was newer or equal to one of the rows in the VStream change event. If this was the case, we’d remove the row from the VStream change event, to prevent it from being seen twice. But this is clearly incorrect, because the resulting rows from the external upquery were only seen by _one of the paths_ of the DAG (the one that ends in the Reader that originally triggered the upquery), but the VStream change event needs to be seen _by all the paths_ of the DAG. Removing the row at the external base, like we were previously doing, would cause the data in _all but one_ of the paths of the DAG to become stale.

Taking this correctness issue into account, we can now amend the original design for row deduplication and generalize it as follows:

1. We define a GTID Tracker as an auxiliary data structure associated with any node in the dataflow graph that keeps partially materialized state. This applies to both External Bases and SQL operator nodes.
2. Every GTID Tracker tracks separately the recently seen upqueries for every path of the DAG that traverses the specific node. These paths are uniquely identified by a Tag, a strictly increasing identifier generated by our query planner.
3. When an upquery is triggered from a Reader, the upquery is marked with its corresponding Tag, again identifying the unique path through the DAG that the results of the upquery will traverse to arrive to the Reader.
4. If the upquery targets an External Base, or a partially materialized node directly reachable from an External base (this is, if the upquery will be resolved as an external upquery by reaching out to the underlying Vitess cluster), we store a record in the GTID tracker for the node. This record is global for the tracker (i.e. shared between all the separate replay paths that are tracked) and contains the _primary key_ that was requested for the external upquery.
5. When the upquery is finished, before we process its results:
	1. We access the Tag-scoped tracker inside the GTID Tracker for the node where the upquery was performed. We know the specific Tag because both the original upquery and its results are marked with a Tag, since the Tag represents the unique path through the DAG that the results of the upquery will traverse.
	2. For every record in the result of the external upquery, we store it in the set of recently seen upqueries for that Tag. We store the _primary key_ that uniquely identifies the record, and the GTID that the underlying database returned for the record. In our case, the underlying database is a Vitess cluster and the GTID is a MySQL [Global Transaction Identifier](https://dev.mysql.com/doc/refman/8.0/en/replication-gtids-concepts.html), but this can be generalized to any GTID-like value (i.e. a strictly-increasing counter or timestamp that allows us to compare whether a record comes _before_ or _after_ another record in time).
	3. We access the global set of in-flight queries for the GTID Tracker (this is _not_ Tag-scoped).
	4. We remove this upquery from the set of in-flight queries. If the in-flight record had any _buffered VStream change events_ accumulated in it (see item 6.3, below), we yield those events. They will be forwarded through the dataflow _right after_ the results of the upquery, so that the records in the events can be checked for recent duplicates.
	5. The result of the upquery is forwarded through the dataflow _unchanged_.
6. Meanwhile, when a VStream change event is processed by the GTID tracker for this node:
	1. We iterate through all the records in the change event. For every record, we check if any of the Tag-scoped trackers inside the GTID tracker has recently seen the record. We can efficiently check this by comparing the record’s _primary key_ with the _primary key_ we stored in the Tag-scoped tracker.
	2. For every record in the change event that has been recently seen by one of the Tag-scoped trackers, if the previously seen GTID is _newer our equal_ than the GTID for this new record, **we mark the record in the change event with the Tag where it was seen before**. Unlike in the original version of the algorithm, the record is **not** removed from the change event — it is simply tagged.
	3. Otherwise, if the record in the change event is a record that _could possibly be returned by one of the in-flight upqueries_ (we can check this because we know the _primary key_ for the in-flight upquery, and we know the primary key for this record): we buffer the full contents of the change event in the in-flight set for the GTID tracker. The buffered events will be yielded _after_ the in-flight query is finished, as explained in section 5.4. **Since the VStream change event has been buffered, we will skip processing it right now**. It is important to note that this whole check for a VStream change event will be applied _again_ after the buffered contents are yielded, and that this second check cannot trigger buffering again, because there won’t be any in-flight misses for the data we’ve already buffered.
7. Before we process _any record_ in any of the operators of the dataflow graph, we figure out all the Tags that belong to the operator’s node (this is, the set of all unique paths through the DAG that cross this specific node — this can be pre-computed at plan time). **If the record is tagged with any of the node’s Tags, we do not process it**.

This algorithm, which we believe to be novel, is applied on every node that contains a partial materialization, and is correct regardless of how many times this node is reused throughout the dataflow graph. It prevents any of the nodes from seeing duplicated packets between the external upqueries that are originated from each node and any VStream change events which the node observes. It does so by _tagging_ the records in VStream change events with unique identifiers for the paths in the DAG that have seen them before, and by delaying any of the VStream change events that could conflict with any existing in-flight external upqueries. This delay or buffering is pessimistic (it can delay events that won’t conflict in practice) but conservative (in practice, it delays a small subset of all the VStream change events that flow through the node).

### Conclusion

Although the first beta of Boost which we announced was very closely based on the original design of Noria, this new architecture is a significant divergence in design that exploits the functionality the underlying Vitess cluster and MySQL instances to move a lot of expensive computation away from the Boost cache. Performing external upqueries at any depth of the dataflow graph and resolving duplication in any of the nodes that can perform an external upquery are novel algorithms which are not covered or hinted at in the original Noria paper or PhD dissertation. We believe the new architecture supports a wider array of SQL patterns than the original Noria without having any pathological performance cases during misses, and without suffering any correctness issues due to duplicated data.
