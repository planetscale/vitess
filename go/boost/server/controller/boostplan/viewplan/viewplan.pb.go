// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: viewplan.proto

package viewplan

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
	sql "vitess.io/vitess/go/boost/sql"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Aggregation int32

const (
	Aggregation_FIRST Aggregation = 0
	Aggregation_COUNT Aggregation = 1
	Aggregation_SUM   Aggregation = 2
	Aggregation_MIN   Aggregation = 3
	Aggregation_MAX   Aggregation = 4
)

var Aggregation_name = map[int32]string{
	0: "FIRST",
	1: "COUNT",
	2: "SUM",
	3: "MIN",
	4: "MAX",
}

var Aggregation_value = map[string]int32{
	"FIRST": 0,
	"COUNT": 1,
	"SUM":   2,
	"MIN":   3,
	"MAX":   4,
}

func (x Aggregation) String() string {
	return proto.EnumName(Aggregation_name, int32(x))
}

func (Aggregation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{0}
}

type Param_Kind int32

const (
	Param_UNSUPPORTED Param_Kind = 0
	Param_SINGLE      Param_Kind = 1
	Param_MULTI       Param_Kind = 2
	Param_RANGE       Param_Kind = 3
	Param_POST        Param_Kind = 4
)

var Param_Kind_name = map[int32]string{
	0: "UNSUPPORTED",
	1: "SINGLE",
	2: "MULTI",
	3: "RANGE",
	4: "POST",
}

var Param_Kind_value = map[string]int32{
	"UNSUPPORTED": 0,
	"SINGLE":      1,
	"MULTI":       2,
	"RANGE":       3,
	"POST":        4,
}

func (x Param_Kind) String() string {
	return proto.EnumName(Param_Kind_name, int32(x))
}

func (Param_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{0, 0}
}

type Param struct {
	Name       string     `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Kind       Param_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=viewplan.Param_Kind" json:"kind,omitempty"`
	Col        int        `protobuf:"varint,3,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	PostFilter *sql.Expr  `protobuf:"bytes,4,opt,name=post_filter,json=postFilter,proto3" json:"post_filter,omitempty"`
}

func (m *Param) Reset()         { *m = Param{} }
func (m *Param) String() string { return proto.CompactTextString(m) }
func (*Param) ProtoMessage()    {}
func (*Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{0}
}
func (m *Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Param.Merge(m, src)
}
func (m *Param) XXX_Size() int {
	return m.Size()
}
func (m *Param) XXX_DiscardUnknown() {
	xxx_messageInfo_Param.DiscardUnknown(m)
}

var xxx_messageInfo_Param proto.InternalMessageInfo

type OrderedColumn struct {
	Col  int  `protobuf:"varint,1,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	Desc bool `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *OrderedColumn) Reset()         { *m = OrderedColumn{} }
func (m *OrderedColumn) String() string { return proto.CompactTextString(m) }
func (*OrderedColumn) ProtoMessage()    {}
func (*OrderedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{1}
}
func (m *OrderedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderedColumn.Merge(m, src)
}
func (m *OrderedColumn) XXX_Size() int {
	return m.Size()
}
func (m *OrderedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_OrderedColumn proto.InternalMessageInfo

type Plan struct {
	Parameters      []*Param        `protobuf:"bytes,1,rep,name=parameters,proto3" json:"parameters,omitempty"`
	TreeKey         *Plan_TreeKey   `protobuf:"bytes,2,opt,name=tree_key,json=treeKey,proto3" json:"tree_key,omitempty"`
	MapKey          []int           `protobuf:"varint,3,rep,packed,name=map_key,json=mapKey,proto3,casttype=int" json:"map_key,omitempty"`
	TopkOrder       []OrderedColumn `protobuf:"bytes,4,rep,name=topk_order,json=topkOrder,proto3" json:"topk_order"`
	TopkLimit       int             `protobuf:"varint,5,opt,name=topk_limit,json=topkLimit,proto3,casttype=int" json:"topk_limit,omitempty"`
	ColumnsForUser  int             `protobuf:"varint,6,opt,name=columns_for_user,json=columnsForUser,proto3,casttype=int" json:"columns_for_user,omitempty"`
	TriggerKey      []int           `protobuf:"varint,7,rep,packed,name=trigger_key,json=triggerKey,proto3,casttype=int" json:"trigger_key,omitempty"`
	PostAggregation []Aggregation   `protobuf:"varint,8,rep,packed,name=post_aggregation,json=postAggregation,proto3,enum=viewplan.Aggregation" json:"post_aggregation,omitempty"`
	PostGroupBy     []int           `protobuf:"varint,9,rep,packed,name=post_group_by,json=postGroupBy,proto3,casttype=int" json:"post_group_by,omitempty"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{2}
}
func (m *Plan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return m.Size()
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

type Plan_TreeKey struct {
	Lower          []int `protobuf:"varint,1,rep,packed,name=lower,proto3,casttype=int" json:"lower,omitempty"`
	LowerInclusive bool  `protobuf:"varint,2,opt,name=lower_inclusive,json=lowerInclusive,proto3" json:"lower_inclusive,omitempty"`
	Upper          []int `protobuf:"varint,3,rep,packed,name=upper,proto3,casttype=int" json:"upper,omitempty"`
	UpperInclusive bool  `protobuf:"varint,4,opt,name=upper_inclusive,json=upperInclusive,proto3" json:"upper_inclusive,omitempty"`
}

func (m *Plan_TreeKey) Reset()         { *m = Plan_TreeKey{} }
func (m *Plan_TreeKey) String() string { return proto.CompactTextString(m) }
func (*Plan_TreeKey) ProtoMessage()    {}
func (*Plan_TreeKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_5595b9753c52ea97, []int{2, 0}
}
func (m *Plan_TreeKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Plan_TreeKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Plan_TreeKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Plan_TreeKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan_TreeKey.Merge(m, src)
}
func (m *Plan_TreeKey) XXX_Size() int {
	return m.Size()
}
func (m *Plan_TreeKey) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan_TreeKey.DiscardUnknown(m)
}

var xxx_messageInfo_Plan_TreeKey proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("viewplan.Aggregation", Aggregation_name, Aggregation_value)
	proto.RegisterEnum("viewplan.Param_Kind", Param_Kind_name, Param_Kind_value)
	proto.RegisterType((*Param)(nil), "viewplan.Param")
	proto.RegisterType((*OrderedColumn)(nil), "viewplan.OrderedColumn")
	proto.RegisterType((*Plan)(nil), "viewplan.Plan")
	proto.RegisterType((*Plan_TreeKey)(nil), "viewplan.Plan.TreeKey")
}

func init() { proto.RegisterFile("viewplan.proto", fileDescriptor_5595b9753c52ea97) }

var fileDescriptor_5595b9753c52ea97 = []byte{
	// 672 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0xcd, 0x6a, 0xdb, 0x4c,
	0x14, 0xf5, 0x44, 0xf2, 0xdf, 0x35, 0xb1, 0xc5, 0x90, 0xef, 0xab, 0x1a, 0xa8, 0x22, 0xbc, 0x68,
	0x45, 0x0a, 0x16, 0x71, 0xb7, 0x25, 0x34, 0x4e, 0x9d, 0x60, 0x92, 0xd8, 0x46, 0xb6, 0xa1, 0x94,
	0x82, 0x50, 0xec, 0x89, 0x10, 0x91, 0x35, 0xea, 0x68, 0xec, 0xd4, 0x6f, 0xd1, 0x6d, 0xdf, 0x28,
	0xcb, 0x74, 0x57, 0xba, 0x08, 0x6d, 0xf2, 0x16, 0x5d, 0x95, 0x19, 0xd9, 0x89, 0x1c, 0xba, 0x31,
	0xc7, 0xe7, 0x9c, 0x7b, 0xe6, 0xde, 0x3b, 0x83, 0xa0, 0x3a, 0x0f, 0xc8, 0x55, 0x1c, 0x7a, 0x51,
	0x23, 0x66, 0x94, 0x53, 0x5c, 0x5a, 0xfd, 0xdf, 0xde, 0xf2, 0xa9, 0x4f, 0x25, 0x69, 0x0b, 0x94,
	0xea, 0xdb, 0xe5, 0xe4, 0x73, 0x98, 0xc2, 0xfa, 0x77, 0x04, 0xf9, 0xbe, 0xc7, 0xbc, 0x29, 0xc6,
	0xa0, 0x46, 0xde, 0x94, 0xe8, 0xc8, 0x44, 0x56, 0xd9, 0x91, 0x18, 0x5b, 0xa0, 0x5e, 0x06, 0xd1,
	0x44, 0xdf, 0x30, 0x91, 0x55, 0x6d, 0x6e, 0x35, 0x1e, 0xce, 0x91, 0x25, 0x8d, 0x93, 0x20, 0x9a,
	0x38, 0xd2, 0x81, 0x9f, 0x83, 0x32, 0xa6, 0xa1, 0xae, 0x98, 0xc8, 0x52, 0x5a, 0xc5, 0x3f, 0xb7,
	0x3b, 0x4a, 0x10, 0x71, 0x47, 0x70, 0x78, 0x17, 0x2a, 0x31, 0x4d, 0xb8, 0x7b, 0x11, 0x84, 0x9c,
	0x30, 0x5d, 0x35, 0x91, 0x55, 0x69, 0x96, 0x1b, 0xa2, 0x87, 0xf6, 0x97, 0x98, 0x39, 0x20, 0xd4,
	0x23, 0x29, 0xd6, 0x0f, 0x41, 0x15, 0xa1, 0xb8, 0x06, 0x95, 0x51, 0x77, 0x30, 0xea, 0xf7, 0x7b,
	0xce, 0xb0, 0xfd, 0x5e, 0xcb, 0x61, 0x80, 0xc2, 0xa0, 0xd3, 0x3d, 0x3e, 0x6d, 0x6b, 0x08, 0x97,
	0x21, 0x7f, 0x36, 0x3a, 0x1d, 0x76, 0xb4, 0x0d, 0x01, 0x9d, 0x83, 0xee, 0x71, 0x5b, 0x53, 0x70,
	0x09, 0xd4, 0x7e, 0x6f, 0x30, 0xd4, 0xd4, 0xfa, 0x3e, 0x6c, 0xf6, 0xd8, 0x84, 0x30, 0x32, 0x39,
	0xa4, 0xe1, 0x6c, 0x1a, 0xad, 0x9a, 0x43, 0xff, 0x68, 0x0e, 0x83, 0x3a, 0x21, 0xc9, 0x58, 0x4e,
	0x58, 0x72, 0x24, 0xae, 0xff, 0x54, 0x41, 0xed, 0x87, 0x5e, 0x84, 0x6d, 0x80, 0x58, 0x0c, 0x4a,
	0x38, 0x61, 0x89, 0x8e, 0x4c, 0xc5, 0xaa, 0x34, 0x6b, 0x4f, 0x96, 0xe0, 0x64, 0x2c, 0x78, 0x0f,
	0x4a, 0x9c, 0x11, 0xe2, 0x5e, 0x92, 0x85, 0x4c, 0xac, 0x34, 0xff, 0xcf, 0xd8, 0xc5, 0xcf, 0x90,
	0x11, 0x72, 0x42, 0x16, 0x4e, 0x91, 0xa7, 0x00, 0x9b, 0x50, 0x9c, 0x7a, 0xb1, 0xac, 0x50, 0x4c,
	0x25, 0xdb, 0x5f, 0x61, 0xea, 0xc5, 0xc2, 0xf1, 0x16, 0x80, 0xd3, 0xf8, 0xd2, 0xa5, 0x62, 0x26,
	0x5d, 0x95, 0x5d, 0x3c, 0x7b, 0x8c, 0x5d, 0x1b, 0xb5, 0xa5, 0x5e, 0xdf, 0xee, 0xe4, 0x9c, 0xb2,
	0x28, 0x90, 0x02, 0x7e, 0xb9, 0xac, 0x0e, 0x83, 0x69, 0xc0, 0xf5, 0xfc, 0xfa, 0x0a, 0xa4, 0xef,
	0x54, 0x28, 0x78, 0x0f, 0xb4, 0xb1, 0x8c, 0x48, 0xdc, 0x0b, 0xca, 0xdc, 0x59, 0x42, 0x98, 0x5e,
	0x58, 0x77, 0x57, 0x97, 0x86, 0x23, 0xca, 0x46, 0x09, 0x61, 0xd8, 0x82, 0x0a, 0x67, 0x81, 0xef,
	0x13, 0x26, 0xdb, 0x2f, 0xae, 0xb7, 0x0f, 0x4b, 0x4d, 0x8c, 0xf0, 0x0e, 0x34, 0xf9, 0x04, 0x3c,
	0xdf, 0x67, 0xc4, 0xf7, 0x78, 0x40, 0x23, 0xbd, 0x64, 0x2a, 0x56, 0xb5, 0xf9, 0xdf, 0xe3, 0x20,
	0x07, 0x8f, 0xa2, 0x53, 0x13, 0xf6, 0x0c, 0x81, 0x5f, 0xc3, 0xa6, 0x4c, 0xf0, 0x19, 0x9d, 0xc5,
	0xee, 0xf9, 0x42, 0x2f, 0xaf, 0x9f, 0x26, 0x9f, 0xd8, 0xb1, 0x10, 0x5b, 0x8b, 0xed, 0x6f, 0x08,
	0x8a, 0xcb, 0x45, 0xe3, 0x17, 0x90, 0x0f, 0xe9, 0x15, 0x61, 0xf2, 0xfa, 0x32, 0x05, 0x29, 0x8b,
	0x5f, 0x41, 0x4d, 0x02, 0x37, 0x88, 0xc6, 0xe1, 0x2c, 0x09, 0xe6, 0x64, 0xf9, 0x14, 0xaa, 0x92,
	0xee, 0xac, 0x58, 0x91, 0x33, 0x8b, 0x63, 0xc2, 0x9e, 0xde, 0x52, 0xca, 0x8a, 0x1c, 0x09, 0x32,
	0x39, 0x6a, 0x9a, 0x23, 0xe9, 0x87, 0x9c, 0xdd, 0x7d, 0xa8, 0x64, 0xe7, 0x2a, 0x43, 0xfe, 0xa8,
	0xe3, 0x0c, 0x86, 0x5a, 0x4e, 0xc0, 0xc3, 0xde, 0xa8, 0x3b, 0xd4, 0x10, 0x2e, 0x82, 0x32, 0x18,
	0x9d, 0x69, 0x1b, 0x02, 0x9c, 0x75, 0xba, 0x9a, 0x22, 0xc1, 0xc1, 0x07, 0x4d, 0x6d, 0x7d, 0xba,
	0xfe, 0x6d, 0xe4, 0xae, 0xef, 0x0c, 0x74, 0x73, 0x67, 0xa0, 0x5f, 0x77, 0x06, 0xfa, 0x7a, 0x6f,
	0xe4, 0x6e, 0xee, 0x8d, 0xdc, 0x8f, 0x7b, 0x23, 0xf7, 0x71, 0x7f, 0x1e, 0x70, 0x92, 0x24, 0x8d,
	0x80, 0xda, 0x29, 0xb2, 0x7d, 0x6a, 0x9f, 0x53, 0x9a, 0x70, 0x3b, 0x21, 0x6c, 0x4e, 0x98, 0x3d,
	0xa6, 0x11, 0x67, 0x34, 0x0c, 0x09, 0x4b, 0x79, 0xb1, 0x7a, 0x7b, 0x75, 0x07, 0xe7, 0x05, 0xf9,
	0x55, 0x78, 0xf3, 0x37, 0x00, 0x00, 0xff, 0xff, 0x8d, 0xd9, 0x54, 0x6a, 0x52, 0x04, 0x00, 0x00,
}

func (m *Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PostFilter != nil {
		{
			size, err := m.PostFilter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintViewplan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Col != 0 {
		i = encodeVarintViewplan(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x18
	}
	if m.Kind != 0 {
		i = encodeVarintViewplan(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintViewplan(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc {
		i--
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Col != 0 {
		i = encodeVarintViewplan(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Plan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PostGroupBy) > 0 {
		dAtA3 := make([]byte, len(m.PostGroupBy)*10)
		var j2 int
		for _, num1 := range m.PostGroupBy {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintViewplan(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PostAggregation) > 0 {
		dAtA5 := make([]byte, len(m.PostAggregation)*10)
		var j4 int
		for _, num := range m.PostAggregation {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintViewplan(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x42
	}
	if len(m.TriggerKey) > 0 {
		dAtA7 := make([]byte, len(m.TriggerKey)*10)
		var j6 int
		for _, num1 := range m.TriggerKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintViewplan(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0x3a
	}
	if m.ColumnsForUser != 0 {
		i = encodeVarintViewplan(dAtA, i, uint64(m.ColumnsForUser))
		i--
		dAtA[i] = 0x30
	}
	if m.TopkLimit != 0 {
		i = encodeVarintViewplan(dAtA, i, uint64(m.TopkLimit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TopkOrder) > 0 {
		for iNdEx := len(m.TopkOrder) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopkOrder[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintViewplan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MapKey) > 0 {
		dAtA9 := make([]byte, len(m.MapKey)*10)
		var j8 int
		for _, num1 := range m.MapKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintViewplan(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if m.TreeKey != nil {
		{
			size, err := m.TreeKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintViewplan(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintViewplan(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Plan_TreeKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Plan_TreeKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Plan_TreeKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpperInclusive {
		i--
		if m.UpperInclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Upper) > 0 {
		dAtA12 := make([]byte, len(m.Upper)*10)
		var j11 int
		for _, num1 := range m.Upper {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintViewplan(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if m.LowerInclusive {
		i--
		if m.LowerInclusive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Lower) > 0 {
		dAtA14 := make([]byte, len(m.Lower)*10)
		var j13 int
		for _, num1 := range m.Lower {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintViewplan(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintViewplan(dAtA []byte, offset int, v uint64) int {
	offset -= sovViewplan(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovViewplan(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovViewplan(uint64(m.Kind))
	}
	if m.Col != 0 {
		n += 1 + sovViewplan(uint64(m.Col))
	}
	if m.PostFilter != nil {
		l = m.PostFilter.Size()
		n += 1 + l + sovViewplan(uint64(l))
	}
	return n
}

func (m *OrderedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != 0 {
		n += 1 + sovViewplan(uint64(m.Col))
	}
	if m.Desc {
		n += 2
	}
	return n
}

func (m *Plan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovViewplan(uint64(l))
		}
	}
	if m.TreeKey != nil {
		l = m.TreeKey.Size()
		n += 1 + l + sovViewplan(uint64(l))
	}
	if len(m.MapKey) > 0 {
		l = 0
		for _, e := range m.MapKey {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	if len(m.TopkOrder) > 0 {
		for _, e := range m.TopkOrder {
			l = e.Size()
			n += 1 + l + sovViewplan(uint64(l))
		}
	}
	if m.TopkLimit != 0 {
		n += 1 + sovViewplan(uint64(m.TopkLimit))
	}
	if m.ColumnsForUser != 0 {
		n += 1 + sovViewplan(uint64(m.ColumnsForUser))
	}
	if len(m.TriggerKey) > 0 {
		l = 0
		for _, e := range m.TriggerKey {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	if len(m.PostAggregation) > 0 {
		l = 0
		for _, e := range m.PostAggregation {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	if len(m.PostGroupBy) > 0 {
		l = 0
		for _, e := range m.PostGroupBy {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	return n
}

func (m *Plan_TreeKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Lower) > 0 {
		l = 0
		for _, e := range m.Lower {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	if m.LowerInclusive {
		n += 2
	}
	if len(m.Upper) > 0 {
		l = 0
		for _, e := range m.Upper {
			l += sovViewplan(uint64(e))
		}
		n += 1 + sovViewplan(uint64(l)) + l
	}
	if m.UpperInclusive {
		n += 2
	}
	return n
}

func sovViewplan(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozViewplan(x uint64) (n int) {
	return sovViewplan(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowViewplan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthViewplan
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthViewplan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Param_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostFilter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthViewplan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthViewplan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PostFilter == nil {
				m.PostFilter = &sql.Expr{}
			}
			if err := m.PostFilter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipViewplan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthViewplan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowViewplan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipViewplan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthViewplan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowViewplan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Plan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Plan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthViewplan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthViewplan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, &Param{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthViewplan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthViewplan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeKey == nil {
				m.TreeKey = &Plan_TreeKey{}
			}
			if err := m.TreeKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MapKey = append(m.MapKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MapKey) == 0 {
					m.MapKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MapKey = append(m.MapKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MapKey", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthViewplan
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthViewplan
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopkOrder = append(m.TopkOrder, OrderedColumn{})
			if err := m.TopkOrder[len(m.TopkOrder)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkLimit", wireType)
			}
			m.TopkLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopkLimit |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsForUser", wireType)
			}
			m.ColumnsForUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnsForUser |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TriggerKey = append(m.TriggerKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.TriggerKey) == 0 {
					m.TriggerKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TriggerKey = append(m.TriggerKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerKey", wireType)
			}
		case 8:
			if wireType == 0 {
				var v Aggregation
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Aggregation(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PostAggregation = append(m.PostAggregation, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PostAggregation) == 0 {
					m.PostAggregation = make([]Aggregation, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Aggregation
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Aggregation(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PostAggregation = append(m.PostAggregation, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PostAggregation", wireType)
			}
		case 9:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PostGroupBy = append(m.PostGroupBy, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PostGroupBy) == 0 {
					m.PostGroupBy = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PostGroupBy = append(m.PostGroupBy, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PostGroupBy", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipViewplan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthViewplan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Plan_TreeKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowViewplan
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Lower = append(m.Lower, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Lower) == 0 {
					m.Lower = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Lower = append(m.Lower, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerInclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LowerInclusive = bool(v != 0)
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Upper = append(m.Upper, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowViewplan
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthViewplan
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthViewplan
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Upper) == 0 {
					m.Upper = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowViewplan
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Upper = append(m.Upper, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperInclusive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpperInclusive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipViewplan(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthViewplan
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipViewplan(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowViewplan
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowViewplan
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthViewplan
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupViewplan
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthViewplan
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthViewplan        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowViewplan          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupViewplan = fmt.Errorf("proto: unexpected end of group")
)
