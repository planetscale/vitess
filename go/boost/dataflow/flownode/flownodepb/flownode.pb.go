// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: flownode.proto

package flownodepb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"

	dataflow "vitess.io/vitess/go/boost/dataflow"
	vitess_io_vitess_go_boost_dataflow "vitess.io/vitess/go/boost/dataflow"
	sql "vitess.io/vitess/go/boost/sql"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Node_InternalJoin_JoinKind int32

const (
	Node_InternalJoin_Left  Node_InternalJoin_JoinKind = 0
	Node_InternalJoin_Inner Node_InternalJoin_JoinKind = 1
)

var Node_InternalJoin_JoinKind_name = map[int32]string{
	0: "Left",
	1: "Inner",
}

var Node_InternalJoin_JoinKind_value = map[string]int32{
	"Left":  0,
	"Inner": 1,
}

func (x Node_InternalJoin_JoinKind) String() string {
	return proto.EnumName(Node_InternalJoin_JoinKind_name, int32(x))
}

func (Node_InternalJoin_JoinKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 5, 0}
}

type Node_InternalGrouped_Aggregation_Kind int32

const (
	Node_InternalGrouped_Aggregation_Count Node_InternalGrouped_Aggregation_Kind = 0
	Node_InternalGrouped_Aggregation_Sum   Node_InternalGrouped_Aggregation_Kind = 2
	Node_InternalGrouped_Aggregation_Min   Node_InternalGrouped_Aggregation_Kind = 3
	Node_InternalGrouped_Aggregation_Max   Node_InternalGrouped_Aggregation_Kind = 4
)

var Node_InternalGrouped_Aggregation_Kind_name = map[int32]string{
	0: "Count",
	2: "Sum",
	3: "Min",
	4: "Max",
}

var Node_InternalGrouped_Aggregation_Kind_value = map[string]int32{
	"Count": 0,
	"Sum":   2,
	"Min":   3,
	"Max":   4,
}

func (x Node_InternalGrouped_Aggregation_Kind) String() string {
	return proto.EnumName(Node_InternalGrouped_Aggregation_Kind_name, int32(x))
}

func (Node_InternalGrouped_Aggregation_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 6, 0, 0}
}

type ViewParameter struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Multi bool   `protobuf:"varint,2,opt,name=multi,proto3" json:"multi,omitempty"`
}

func (m *ViewParameter) Reset()         { *m = ViewParameter{} }
func (m *ViewParameter) String() string { return proto.CompactTextString(m) }
func (*ViewParameter) ProtoMessage()    {}
func (*ViewParameter) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{0}
}
func (m *ViewParameter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewParameter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewParameter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewParameter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewParameter.Merge(m, src)
}
func (m *ViewParameter) XXX_Size() int {
	return m.Size()
}
func (m *ViewParameter) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewParameter.DiscardUnknown(m)
}

var xxx_messageInfo_ViewParameter proto.InternalMessageInfo

type OrderedColumn struct {
	Col  int  `protobuf:"varint,1,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	Desc bool `protobuf:"varint,2,opt,name=desc,proto3" json:"desc,omitempty"`
}

func (m *OrderedColumn) Reset()         { *m = OrderedColumn{} }
func (m *OrderedColumn) String() string { return proto.CompactTextString(m) }
func (*OrderedColumn) ProtoMessage()    {}
func (*OrderedColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{1}
}
func (m *OrderedColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderedColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderedColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderedColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderedColumn.Merge(m, src)
}
func (m *OrderedColumn) XXX_Size() int {
	return m.Size()
}
func (m *OrderedColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderedColumn.DiscardUnknown(m)
}

var xxx_messageInfo_OrderedColumn proto.InternalMessageInfo

type Node struct {
	Name     string                                            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index    *dataflow.IndexPair                               `protobuf:"bytes,2,opt,name=index,proto3" json:"index,omitempty"`
	Domain   vitess_io_vitess_go_boost_dataflow.DomainIdx      `protobuf:"varint,3,opt,name=domain,proto3,casttype=vitess.io/vitess/go/boost/dataflow.DomainIdx" json:"domain,omitempty"`
	Fields   []string                                          `protobuf:"bytes,4,rep,name=fields,proto3" json:"fields,omitempty"`
	Schema   []sql.Type                                        `protobuf:"bytes,5,rep,name=schema,proto3" json:"schema"`
	Parents  []vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,6,rep,packed,name=parents,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"parents,omitempty"`
	Children []vitess_io_vitess_go_boost_dataflow.LocalNodeIdx `protobuf:"varint,7,rep,packed,name=children,proto3,casttype=vitess.io/vitess/go/boost/dataflow.LocalNodeIdx" json:"children,omitempty"`
	Taken    bool                                              `protobuf:"varint,8,opt,name=taken,proto3" json:"taken,omitempty"`
	Sharding *dataflow.Sharding                                `protobuf:"bytes,10,opt,name=sharding,proto3" json:"sharding,omitempty"`
	// Types that are valid to be assigned to Impl:
	//	*Node_Ingress_
	//	*Node_Egress_
	//	*Node_Reader_
	//	*Node_Sharder_
	//	*Node_Table_
	//	*Node_Union
	//	*Node_Join
	//	*Node_Grouped
	//	*Node_Project
	//	*Node_Filter
	//	*Node_TopK
	Impl isNode_Impl `protobuf_oneof:"impl"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type isNode_Impl interface {
	isNode_Impl()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_Ingress_ struct {
	Ingress *Node_Ingress `protobuf:"bytes,21,opt,name=ingress,proto3,oneof" json:"ingress,omitempty"`
}
type Node_Egress_ struct {
	Egress *Node_Egress `protobuf:"bytes,22,opt,name=egress,proto3,oneof" json:"egress,omitempty"`
}
type Node_Reader_ struct {
	Reader *Node_Reader `protobuf:"bytes,23,opt,name=reader,proto3,oneof" json:"reader,omitempty"`
}
type Node_Sharder_ struct {
	Sharder *Node_Sharder `protobuf:"bytes,24,opt,name=sharder,proto3,oneof" json:"sharder,omitempty"`
}
type Node_Table_ struct {
	Table *Node_Table `protobuf:"bytes,25,opt,name=table,proto3,oneof" json:"table,omitempty"`
}
type Node_Union struct {
	Union *Node_InternalUnion `protobuf:"bytes,40,opt,name=union,proto3,oneof" json:"union,omitempty"`
}
type Node_Join struct {
	Join *Node_InternalJoin `protobuf:"bytes,41,opt,name=join,proto3,oneof" json:"join,omitempty"`
}
type Node_Grouped struct {
	Grouped *Node_InternalGrouped `protobuf:"bytes,42,opt,name=grouped,proto3,oneof" json:"grouped,omitempty"`
}
type Node_Project struct {
	Project *Node_InternalProject `protobuf:"bytes,43,opt,name=project,proto3,oneof" json:"project,omitempty"`
}
type Node_Filter struct {
	Filter *Node_InternalFilter `protobuf:"bytes,44,opt,name=filter,proto3,oneof" json:"filter,omitempty"`
}
type Node_TopK struct {
	TopK *Node_InternalTopK `protobuf:"bytes,45,opt,name=top_k,json=topK,proto3,oneof" json:"top_k,omitempty"`
}

func (*Node_Ingress_) isNode_Impl() {}
func (*Node_Egress_) isNode_Impl()  {}
func (*Node_Reader_) isNode_Impl()  {}
func (*Node_Sharder_) isNode_Impl() {}
func (*Node_Table_) isNode_Impl()   {}
func (*Node_Union) isNode_Impl()    {}
func (*Node_Join) isNode_Impl()     {}
func (*Node_Grouped) isNode_Impl()  {}
func (*Node_Project) isNode_Impl()  {}
func (*Node_Filter) isNode_Impl()   {}
func (*Node_TopK) isNode_Impl()     {}

func (m *Node) GetImpl() isNode_Impl {
	if m != nil {
		return m.Impl
	}
	return nil
}

func (m *Node) GetIngress() *Node_Ingress {
	if x, ok := m.GetImpl().(*Node_Ingress_); ok {
		return x.Ingress
	}
	return nil
}

func (m *Node) GetEgress() *Node_Egress {
	if x, ok := m.GetImpl().(*Node_Egress_); ok {
		return x.Egress
	}
	return nil
}

func (m *Node) GetReader() *Node_Reader {
	if x, ok := m.GetImpl().(*Node_Reader_); ok {
		return x.Reader
	}
	return nil
}

func (m *Node) GetSharder() *Node_Sharder {
	if x, ok := m.GetImpl().(*Node_Sharder_); ok {
		return x.Sharder
	}
	return nil
}

func (m *Node) GetTable() *Node_Table {
	if x, ok := m.GetImpl().(*Node_Table_); ok {
		return x.Table
	}
	return nil
}

func (m *Node) GetUnion() *Node_InternalUnion {
	if x, ok := m.GetImpl().(*Node_Union); ok {
		return x.Union
	}
	return nil
}

func (m *Node) GetJoin() *Node_InternalJoin {
	if x, ok := m.GetImpl().(*Node_Join); ok {
		return x.Join
	}
	return nil
}

func (m *Node) GetGrouped() *Node_InternalGrouped {
	if x, ok := m.GetImpl().(*Node_Grouped); ok {
		return x.Grouped
	}
	return nil
}

func (m *Node) GetProject() *Node_InternalProject {
	if x, ok := m.GetImpl().(*Node_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Node) GetFilter() *Node_InternalFilter {
	if x, ok := m.GetImpl().(*Node_Filter); ok {
		return x.Filter
	}
	return nil
}

func (m *Node) GetTopK() *Node_InternalTopK {
	if x, ok := m.GetImpl().(*Node_TopK); ok {
		return x.TopK
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_Ingress_)(nil),
		(*Node_Egress_)(nil),
		(*Node_Reader_)(nil),
		(*Node_Sharder_)(nil),
		(*Node_Table_)(nil),
		(*Node_Union)(nil),
		(*Node_Join)(nil),
		(*Node_Grouped)(nil),
		(*Node_Project)(nil),
		(*Node_Filter)(nil),
		(*Node_TopK)(nil),
	}
}

type Node_Table struct {
	PrimaryKey []int      `protobuf:"varint,1,rep,packed,name=primary_key,json=primaryKey,proto3,casttype=int" json:"primary_key,omitempty"`
	Keyspace   string     `protobuf:"bytes,2,opt,name=keyspace,proto3" json:"keyspace,omitempty"`
	Name       string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Schema     []sql.Type `protobuf:"bytes,4,rep,name=schema,proto3" json:"schema"`
}

func (m *Node_Table) Reset()         { *m = Node_Table{} }
func (m *Node_Table) String() string { return proto.CompactTextString(m) }
func (*Node_Table) ProtoMessage()    {}
func (*Node_Table) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 0}
}
func (m *Node_Table) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Table) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Table.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Table) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Table.Merge(m, src)
}
func (m *Node_Table) XXX_Size() int {
	return m.Size()
}
func (m *Node_Table) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Table.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Table proto.InternalMessageInfo

type Node_Ingress struct {
}

func (m *Node_Ingress) Reset()         { *m = Node_Ingress{} }
func (m *Node_Ingress) String() string { return proto.CompactTextString(m) }
func (*Node_Ingress) ProtoMessage()    {}
func (*Node_Ingress) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 1}
}
func (m *Node_Ingress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Ingress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Ingress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Ingress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Ingress.Merge(m, src)
}
func (m *Node_Ingress) XXX_Size() int {
	return m.Size()
}
func (m *Node_Ingress) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Ingress.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Ingress proto.InternalMessageInfo

type Node_Egress struct {
}

func (m *Node_Egress) Reset()         { *m = Node_Egress{} }
func (m *Node_Egress) String() string { return proto.CompactTextString(m) }
func (*Node_Egress) ProtoMessage()    {}
func (*Node_Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 2}
}
func (m *Node_Egress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Egress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Egress.Merge(m, src)
}
func (m *Node_Egress) XXX_Size() int {
	return m.Size()
}
func (m *Node_Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Egress proto.InternalMessageInfo

type Node_Reader struct {
	PublicId       string                                     `protobuf:"bytes,1,opt,name=public_id,json=publicId,proto3" json:"public_id,omitempty"`
	ForNode        vitess_io_vitess_go_boost_dataflow.NodeIdx `protobuf:"varint,2,opt,name=for_node,json=forNode,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"for_node,omitempty"`
	State          []int                                      `protobuf:"varint,3,rep,packed,name=state,proto3,casttype=int" json:"state,omitempty"`
	Parameters     []ViewParameter                            `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters"`
	TopkOrder      []OrderedColumn                            `protobuf:"bytes,5,rep,name=topk_order,json=topkOrder,proto3" json:"topk_order"`
	TopkLimit      int                                        `protobuf:"varint,6,opt,name=topk_limit,json=topkLimit,proto3,casttype=int" json:"topk_limit,omitempty"`
	ColumnsForView int                                        `protobuf:"varint,7,opt,name=columns_for_view,json=columnsForView,proto3,casttype=int" json:"columns_for_view,omitempty"`
	ColumnsForUser int                                        `protobuf:"varint,8,opt,name=columns_for_user,json=columnsForUser,proto3,casttype=int" json:"columns_for_user,omitempty"`
}

func (m *Node_Reader) Reset()         { *m = Node_Reader{} }
func (m *Node_Reader) String() string { return proto.CompactTextString(m) }
func (*Node_Reader) ProtoMessage()    {}
func (*Node_Reader) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 3}
}
func (m *Node_Reader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Reader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Reader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Reader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Reader.Merge(m, src)
}
func (m *Node_Reader) XXX_Size() int {
	return m.Size()
}
func (m *Node_Reader) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Reader.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Reader proto.InternalMessageInfo

type Node_InternalUnion struct {
	// Types that are valid to be assigned to Emit:
	//
	//	*Node_InternalUnion_Project
	//	*Node_InternalUnion_All
	Emit     isNode_InternalUnion_Emit                  `protobuf_oneof:"emit"`
	Required int                                        `protobuf:"varint,3,opt,name=required,proto3,casttype=int" json:"required,omitempty"`
	Me       vitess_io_vitess_go_boost_dataflow.NodeIdx `protobuf:"varint,4,opt,name=me,proto3,casttype=vitess.io/vitess/go/boost/dataflow.NodeIdx" json:"me,omitempty"`
}

func (m *Node_InternalUnion) Reset()         { *m = Node_InternalUnion{} }
func (m *Node_InternalUnion) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion) ProtoMessage()    {}
func (*Node_InternalUnion) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 4}
}
func (m *Node_InternalUnion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion.Merge(m, src)
}
func (m *Node_InternalUnion) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion proto.InternalMessageInfo

type isNode_InternalUnion_Emit interface {
	isNode_InternalUnion_Emit()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Node_InternalUnion_Project struct {
	Project *Node_InternalUnion_EmitProject `protobuf:"bytes,1,opt,name=project,proto3,oneof" json:"project,omitempty"`
}
type Node_InternalUnion_All struct {
	All *Node_InternalUnion_EmitAll `protobuf:"bytes,2,opt,name=all,proto3,oneof" json:"all,omitempty"`
}

func (*Node_InternalUnion_Project) isNode_InternalUnion_Emit() {}
func (*Node_InternalUnion_All) isNode_InternalUnion_Emit()     {}

func (m *Node_InternalUnion) GetEmit() isNode_InternalUnion_Emit {
	if m != nil {
		return m.Emit
	}
	return nil
}

func (m *Node_InternalUnion) GetProject() *Node_InternalUnion_EmitProject {
	if x, ok := m.GetEmit().(*Node_InternalUnion_Project); ok {
		return x.Project
	}
	return nil
}

func (m *Node_InternalUnion) GetAll() *Node_InternalUnion_EmitAll {
	if x, ok := m.GetEmit().(*Node_InternalUnion_All); ok {
		return x.All
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Node_InternalUnion) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Node_InternalUnion_Project)(nil),
		(*Node_InternalUnion_All)(nil),
	}
}

type Node_InternalUnion_EmitProject struct {
	Emit []Node_InternalUnion_EmitProject_EmitTuple `protobuf:"bytes,1,rep,name=emit,proto3" json:"emit"`
}

func (m *Node_InternalUnion_EmitProject) Reset()         { *m = Node_InternalUnion_EmitProject{} }
func (m *Node_InternalUnion_EmitProject) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitProject) ProtoMessage()    {}
func (*Node_InternalUnion_EmitProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 4, 0}
}
func (m *Node_InternalUnion_EmitProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject proto.InternalMessageInfo

type Node_InternalUnion_EmitProject_EmitTuple struct {
	Ip      dataflow.IndexPair `protobuf:"bytes,1,opt,name=ip,proto3" json:"ip"`
	Columns []int              `protobuf:"varint,2,rep,packed,name=columns,proto3,casttype=int" json:"columns,omitempty"`
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Reset() {
	*m = Node_InternalUnion_EmitProject_EmitTuple{}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitProject_EmitTuple) ProtoMessage()    {}
func (*Node_InternalUnion_EmitProject_EmitTuple) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 4, 0, 0}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.Merge(m, src)
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitProject_EmitTuple proto.InternalMessageInfo

type Node_InternalUnion_EmitAll struct {
	From     *dataflow.IndexPair `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	Sharding *dataflow.Sharding  `protobuf:"bytes,2,opt,name=sharding,proto3" json:"sharding,omitempty"`
}

func (m *Node_InternalUnion_EmitAll) Reset()         { *m = Node_InternalUnion_EmitAll{} }
func (m *Node_InternalUnion_EmitAll) String() string { return proto.CompactTextString(m) }
func (*Node_InternalUnion_EmitAll) ProtoMessage()    {}
func (*Node_InternalUnion_EmitAll) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 4, 1}
}
func (m *Node_InternalUnion_EmitAll) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalUnion_EmitAll) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalUnion_EmitAll.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalUnion_EmitAll) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalUnion_EmitAll.Merge(m, src)
}
func (m *Node_InternalUnion_EmitAll) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalUnion_EmitAll) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalUnion_EmitAll.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalUnion_EmitAll proto.InternalMessageInfo

type Node_InternalJoin struct {
	Left             dataflow.IndexPair           `protobuf:"bytes,1,opt,name=left,proto3" json:"left"`
	Right            dataflow.IndexPair           `protobuf:"bytes,2,opt,name=right,proto3" json:"right"`
	On0              int                          `protobuf:"varint,3,opt,name=on0,proto3,casttype=int" json:"on0,omitempty"`
	On1              int                          `protobuf:"varint,4,opt,name=on1,proto3,casttype=int" json:"on1,omitempty"`
	Emit             []Node_InternalJoin_Emission `protobuf:"bytes,5,rep,name=emit,proto3" json:"emit"`
	InPlaceLeftEmit  []Node_InternalJoin_Emission `protobuf:"bytes,6,rep,name=in_place_left_emit,json=inPlaceLeftEmit,proto3" json:"in_place_left_emit"`
	InPlaceRightEmit []Node_InternalJoin_Emission `protobuf:"bytes,7,rep,name=in_place_right_emit,json=inPlaceRightEmit,proto3" json:"in_place_right_emit"`
	Kind             Node_InternalJoin_JoinKind   `protobuf:"varint,8,opt,name=kind,proto3,enum=flownode.Node_InternalJoin_JoinKind" json:"kind,omitempty"`
	Type             sql.Type                     `protobuf:"bytes,9,opt,name=type,proto3" json:"type"`
}

func (m *Node_InternalJoin) Reset()         { *m = Node_InternalJoin{} }
func (m *Node_InternalJoin) String() string { return proto.CompactTextString(m) }
func (*Node_InternalJoin) ProtoMessage()    {}
func (*Node_InternalJoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 5}
}
func (m *Node_InternalJoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalJoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalJoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalJoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalJoin.Merge(m, src)
}
func (m *Node_InternalJoin) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalJoin) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalJoin.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalJoin proto.InternalMessageInfo

type Node_InternalJoin_Emission struct {
	Col         int  `protobuf:"varint,1,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
	Left        bool `protobuf:"varint,2,opt,name=left,proto3" json:"left,omitempty"`
	MultiParent bool `protobuf:"varint,3,opt,name=multi_parent,json=multiParent,proto3" json:"multi_parent,omitempty"`
}

func (m *Node_InternalJoin_Emission) Reset()         { *m = Node_InternalJoin_Emission{} }
func (m *Node_InternalJoin_Emission) String() string { return proto.CompactTextString(m) }
func (*Node_InternalJoin_Emission) ProtoMessage()    {}
func (*Node_InternalJoin_Emission) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 5, 0}
}
func (m *Node_InternalJoin_Emission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalJoin_Emission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalJoin_Emission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalJoin_Emission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalJoin_Emission.Merge(m, src)
}
func (m *Node_InternalJoin_Emission) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalJoin_Emission) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalJoin_Emission.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalJoin_Emission proto.InternalMessageInfo

type Node_InternalGrouped struct {
	Src        dataflow.IndexPair                 `protobuf:"bytes,1,opt,name=src,proto3" json:"src"`
	SrcSchema  []sql.Type                         `protobuf:"bytes,2,rep,name=src_schema,json=srcSchema,proto3" json:"src_schema"`
	Inner      []Node_InternalGrouped_Aggregation `protobuf:"bytes,3,rep,name=inner,proto3" json:"inner"`
	Cols       int                                `protobuf:"varint,4,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Scalar     bool                               `protobuf:"varint,5,opt,name=scalar,proto3" json:"scalar,omitempty"`
	GroupByKey []int                              `protobuf:"varint,6,rep,packed,name=group_by_key,json=groupByKey,proto3,casttype=int" json:"group_by_key,omitempty"`
	OutKey     []int                              `protobuf:"varint,7,rep,packed,name=out_key,json=outKey,proto3,casttype=int" json:"out_key,omitempty"`
	Colfix     []int                              `protobuf:"varint,8,rep,packed,name=colfix,proto3,casttype=int" json:"colfix,omitempty"`
}

func (m *Node_InternalGrouped) Reset()         { *m = Node_InternalGrouped{} }
func (m *Node_InternalGrouped) String() string { return proto.CompactTextString(m) }
func (*Node_InternalGrouped) ProtoMessage()    {}
func (*Node_InternalGrouped) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 6}
}
func (m *Node_InternalGrouped) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalGrouped) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalGrouped.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalGrouped) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalGrouped.Merge(m, src)
}
func (m *Node_InternalGrouped) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalGrouped) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalGrouped.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalGrouped proto.InternalMessageInfo

type Node_InternalGrouped_Aggregation struct {
	Kind Node_InternalGrouped_Aggregation_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=flownode.Node_InternalGrouped_Aggregation_Kind" json:"kind,omitempty"`
	Over int                                   `protobuf:"varint,2,opt,name=over,proto3,casttype=int" json:"over,omitempty"`
}

func (m *Node_InternalGrouped_Aggregation) Reset()         { *m = Node_InternalGrouped_Aggregation{} }
func (m *Node_InternalGrouped_Aggregation) String() string { return proto.CompactTextString(m) }
func (*Node_InternalGrouped_Aggregation) ProtoMessage()    {}
func (*Node_InternalGrouped_Aggregation) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 6, 0}
}
func (m *Node_InternalGrouped_Aggregation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalGrouped_Aggregation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalGrouped_Aggregation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalGrouped_Aggregation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalGrouped_Aggregation.Merge(m, src)
}
func (m *Node_InternalGrouped_Aggregation) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalGrouped_Aggregation) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalGrouped_Aggregation.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalGrouped_Aggregation proto.InternalMessageInfo

type Node_InternalProject struct {
	Src         *dataflow.IndexPair `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Cols        int                 `protobuf:"varint,3,opt,name=cols,proto3,casttype=int" json:"cols,omitempty"`
	Projections []string            `protobuf:"bytes,4,rep,name=projections,proto3" json:"projections,omitempty"`
}

func (m *Node_InternalProject) Reset()         { *m = Node_InternalProject{} }
func (m *Node_InternalProject) String() string { return proto.CompactTextString(m) }
func (*Node_InternalProject) ProtoMessage()    {}
func (*Node_InternalProject) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 7}
}
func (m *Node_InternalProject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalProject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalProject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalProject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalProject.Merge(m, src)
}
func (m *Node_InternalProject) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalProject) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalProject.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalProject proto.InternalMessageInfo

type Node_InternalFilter struct {
	Src    *dataflow.IndexPair               `protobuf:"bytes,1,opt,name=src,proto3" json:"src,omitempty"`
	Filter []*Node_InternalFilter_FilterExpr `protobuf:"bytes,2,rep,name=filter,proto3" json:"filter,omitempty"`
}

func (m *Node_InternalFilter) Reset()         { *m = Node_InternalFilter{} }
func (m *Node_InternalFilter) String() string { return proto.CompactTextString(m) }
func (*Node_InternalFilter) ProtoMessage()    {}
func (*Node_InternalFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 8}
}
func (m *Node_InternalFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalFilter.Merge(m, src)
}
func (m *Node_InternalFilter) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalFilter.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalFilter proto.InternalMessageInfo

type Node_InternalFilter_FilterExpr struct {
	Expr string `protobuf:"bytes,1,opt,name=expr,proto3" json:"expr,omitempty"`
	Col  int    `protobuf:"varint,2,opt,name=col,proto3,casttype=int" json:"col,omitempty"`
}

func (m *Node_InternalFilter_FilterExpr) Reset()         { *m = Node_InternalFilter_FilterExpr{} }
func (m *Node_InternalFilter_FilterExpr) String() string { return proto.CompactTextString(m) }
func (*Node_InternalFilter_FilterExpr) ProtoMessage()    {}
func (*Node_InternalFilter_FilterExpr) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 8, 0}
}
func (m *Node_InternalFilter_FilterExpr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalFilter_FilterExpr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalFilter_FilterExpr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalFilter_FilterExpr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalFilter_FilterExpr.Merge(m, src)
}
func (m *Node_InternalFilter_FilterExpr) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalFilter_FilterExpr) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalFilter_FilterExpr.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalFilter_FilterExpr proto.InternalMessageInfo

type Node_InternalTopK struct {
	Src       dataflow.IndexPair `protobuf:"bytes,1,opt,name=src,proto3" json:"src"`
	SrcSchema []sql.Type         `protobuf:"bytes,2,rep,name=src_schema,json=srcSchema,proto3" json:"src_schema"`
	Order     []OrderedColumn    `protobuf:"bytes,3,rep,name=order,proto3" json:"order"`
	K         int                `protobuf:"varint,4,opt,name=K,proto3,casttype=int" json:"K,omitempty"`
	Params    []int              `protobuf:"varint,5,rep,packed,name=params,proto3,casttype=int" json:"params,omitempty"`
}

func (m *Node_InternalTopK) Reset()         { *m = Node_InternalTopK{} }
func (m *Node_InternalTopK) String() string { return proto.CompactTextString(m) }
func (*Node_InternalTopK) ProtoMessage()    {}
func (*Node_InternalTopK) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 9}
}
func (m *Node_InternalTopK) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_InternalTopK) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_InternalTopK.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_InternalTopK) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_InternalTopK.Merge(m, src)
}
func (m *Node_InternalTopK) XXX_Size() int {
	return m.Size()
}
func (m *Node_InternalTopK) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_InternalTopK.DiscardUnknown(m)
}

var xxx_messageInfo_Node_InternalTopK proto.InternalMessageInfo

type Node_Sharder struct {
	ShardBy int `protobuf:"varint,1,opt,name=shard_by,json=shardBy,proto3,casttype=int" json:"shard_by,omitempty"`
}

func (m *Node_Sharder) Reset()         { *m = Node_Sharder{} }
func (m *Node_Sharder) String() string { return proto.CompactTextString(m) }
func (*Node_Sharder) ProtoMessage()    {}
func (*Node_Sharder) Descriptor() ([]byte, []int) {
	return fileDescriptor_aeaeaa4050b75071, []int{2, 10}
}
func (m *Node_Sharder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node_Sharder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node_Sharder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node_Sharder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node_Sharder.Merge(m, src)
}
func (m *Node_Sharder) XXX_Size() int {
	return m.Size()
}
func (m *Node_Sharder) XXX_DiscardUnknown() {
	xxx_messageInfo_Node_Sharder.DiscardUnknown(m)
}

var xxx_messageInfo_Node_Sharder proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("flownode.Node_InternalJoin_JoinKind", Node_InternalJoin_JoinKind_name, Node_InternalJoin_JoinKind_value)
	proto.RegisterEnum("flownode.Node_InternalGrouped_Aggregation_Kind", Node_InternalGrouped_Aggregation_Kind_name, Node_InternalGrouped_Aggregation_Kind_value)
	proto.RegisterType((*ViewParameter)(nil), "flownode.ViewParameter")
	proto.RegisterType((*OrderedColumn)(nil), "flownode.OrderedColumn")
	proto.RegisterType((*Node)(nil), "flownode.Node")
	proto.RegisterType((*Node_Table)(nil), "flownode.Node.Table")
	proto.RegisterType((*Node_Ingress)(nil), "flownode.Node.Ingress")
	proto.RegisterType((*Node_Egress)(nil), "flownode.Node.Egress")
	proto.RegisterType((*Node_Reader)(nil), "flownode.Node.Reader")
	proto.RegisterType((*Node_InternalUnion)(nil), "flownode.Node.InternalUnion")
	proto.RegisterType((*Node_InternalUnion_EmitProject)(nil), "flownode.Node.InternalUnion.EmitProject")
	proto.RegisterType((*Node_InternalUnion_EmitProject_EmitTuple)(nil), "flownode.Node.InternalUnion.EmitProject.EmitTuple")
	proto.RegisterType((*Node_InternalUnion_EmitAll)(nil), "flownode.Node.InternalUnion.EmitAll")
	proto.RegisterType((*Node_InternalJoin)(nil), "flownode.Node.InternalJoin")
	proto.RegisterType((*Node_InternalJoin_Emission)(nil), "flownode.Node.InternalJoin.Emission")
	proto.RegisterType((*Node_InternalGrouped)(nil), "flownode.Node.InternalGrouped")
	proto.RegisterType((*Node_InternalGrouped_Aggregation)(nil), "flownode.Node.InternalGrouped.Aggregation")
	proto.RegisterType((*Node_InternalProject)(nil), "flownode.Node.InternalProject")
	proto.RegisterType((*Node_InternalFilter)(nil), "flownode.Node.InternalFilter")
	proto.RegisterType((*Node_InternalFilter_FilterExpr)(nil), "flownode.Node.InternalFilter.FilterExpr")
	proto.RegisterType((*Node_InternalTopK)(nil), "flownode.Node.InternalTopK")
	proto.RegisterType((*Node_Sharder)(nil), "flownode.Node.Sharder")
}

func init() { proto.RegisterFile("flownode.proto", fileDescriptor_aeaeaa4050b75071) }

var fileDescriptor_aeaeaa4050b75071 = []byte{
	// 1573 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x5b, 0x6f, 0x13, 0x47,
	0x1b, 0xf6, 0x7a, 0xd7, 0xa7, 0x37, 0x24, 0x44, 0xc3, 0x69, 0xd9, 0x7c, 0x38, 0x26, 0xf0, 0x7d,
	0x38, 0x10, 0x6c, 0x12, 0x3e, 0xb5, 0xf4, 0x84, 0x8a, 0x39, 0x34, 0x69, 0x42, 0x89, 0x36, 0xa1,
	0x15, 0x55, 0x25, 0x6b, 0xbd, 0x3b, 0x76, 0x86, 0xac, 0x77, 0x96, 0xd9, 0x35, 0x89, 0xff, 0x42,
	0xaf, 0xb8, 0x6d, 0xa5, 0xfe, 0x8d, 0xfe, 0x06, 0x2e, 0xb9, 0xe4, 0x2a, 0x6a, 0xe1, 0x3f, 0x54,
	0x6a, 0xae, 0xaa, 0x39, 0xac, 0x4f, 0x18, 0x27, 0x20, 0xf5, 0x26, 0x99, 0x99, 0xf7, 0x79, 0x5e,
	0xcf, 0xbc, 0xe7, 0x85, 0x99, 0xa6, 0x4f, 0xf7, 0x02, 0xea, 0xe1, 0x4a, 0xc8, 0x68, 0x4c, 0x51,
	0x3e, 0xd9, 0x5b, 0xa7, 0x5b, 0xb4, 0x45, 0xc5, 0x61, 0x95, 0xaf, 0xa4, 0xdc, 0x2a, 0x44, 0xcf,
	0x7c, 0xb5, 0x9c, 0xf1, 0x9c, 0xd8, 0xe1, 0x70, 0xb9, 0x5f, 0xf8, 0x0c, 0xa6, 0xbf, 0x27, 0x78,
	0x6f, 0xd3, 0x61, 0x4e, 0x1b, 0xc7, 0x98, 0x21, 0x04, 0x46, 0xe0, 0xb4, 0xb1, 0xa9, 0x95, 0xb4,
	0x72, 0xc1, 0x16, 0x6b, 0x74, 0x1a, 0x32, 0xed, 0x8e, 0x1f, 0x13, 0x33, 0x5d, 0xd2, 0xca, 0x79,
	0x5b, 0x6e, 0x16, 0x6e, 0xc3, 0xf4, 0x23, 0xe6, 0x61, 0x86, 0xbd, 0xbb, 0xd4, 0xef, 0xb4, 0x03,
	0x74, 0x1e, 0x74, 0x97, 0xfa, 0x82, 0xa9, 0xd7, 0x72, 0x87, 0x07, 0xf3, 0x3a, 0x09, 0x62, 0x9b,
	0x9f, 0x71, 0xad, 0x1e, 0x8e, 0x5c, 0xa5, 0x40, 0xac, 0x17, 0x5e, 0x14, 0xc1, 0xf8, 0x8e, 0x7a,
	0x78, 0xec, 0x4f, 0x2e, 0x42, 0x86, 0x04, 0x1e, 0xde, 0x17, 0x8c, 0xa9, 0x95, 0x53, 0x95, 0xde,
	0xbd, 0xd7, 0xf8, 0xf1, 0xa6, 0x43, 0x98, 0x2d, 0x11, 0x68, 0x15, 0xb2, 0x1e, 0x6d, 0x3b, 0x24,
	0x30, 0xf5, 0x92, 0x56, 0x36, 0x6a, 0x37, 0x0e, 0x0f, 0xe6, 0x97, 0x9e, 0x93, 0x18, 0x47, 0x51,
	0x85, 0xd0, 0xaa, 0x5c, 0x55, 0x5b, 0xb4, 0xda, 0xa0, 0x34, 0x8a, 0xab, 0x3d, 0x45, 0xf7, 0x04,
	0x69, 0xcd, 0xdb, 0xb7, 0x15, 0x1f, 0x9d, 0x85, 0x6c, 0x93, 0x60, 0xdf, 0x8b, 0x4c, 0xa3, 0xa4,
	0x97, 0x0b, 0xb6, 0xda, 0xa1, 0x2b, 0x90, 0x8d, 0xdc, 0x1d, 0xdc, 0x76, 0xcc, 0x4c, 0x49, 0x2f,
	0x4f, 0xad, 0x14, 0x2a, 0xdc, 0xa0, 0xdb, 0xdd, 0x10, 0xd7, 0x8c, 0x97, 0x07, 0xf3, 0x29, 0x5b,
	0x89, 0xd1, 0x43, 0xc8, 0x85, 0x0e, 0xc3, 0x41, 0x1c, 0x99, 0xd9, 0x92, 0x5e, 0x9e, 0xae, 0xdd,
	0x3c, 0x3c, 0x98, 0xaf, 0x1e, 0xe3, 0x2e, 0x1b, 0xd4, 0x75, 0x7c, 0x6e, 0x0c, 0x7e, 0x9d, 0x44,
	0x07, 0x7a, 0x04, 0x79, 0x77, 0x87, 0xf8, 0x1e, 0xc3, 0x81, 0x99, 0xfb, 0x78, 0x7d, 0x3d, 0x25,
	0xdc, 0x91, 0xb1, 0xb3, 0x8b, 0x03, 0x33, 0x2f, 0x1d, 0x29, 0x36, 0xa8, 0x02, 0xf9, 0x68, 0xc7,
	0x61, 0x1e, 0x09, 0x5a, 0x26, 0x08, 0x73, 0xa3, 0xbe, 0xb9, 0xb7, 0x94, 0xc4, 0xee, 0x61, 0xd0,
	0x0a, 0xe4, 0x48, 0xd0, 0x62, 0x38, 0x8a, 0xcc, 0x33, 0x02, 0x7e, 0xb6, 0xd2, 0x0b, 0x48, 0xfe,
	0x9b, 0x95, 0x35, 0x29, 0x5d, 0x4d, 0xd9, 0x09, 0x10, 0x55, 0x21, 0x8b, 0x25, 0xe5, 0xac, 0xa0,
	0x9c, 0x19, 0xa1, 0xdc, 0x4f, 0x18, 0x0a, 0xc6, 0x09, 0x0c, 0x3b, 0x1e, 0x66, 0xe6, 0xb9, 0xb1,
	0x04, 0x5b, 0x08, 0x39, 0x41, 0xc2, 0xf8, 0xad, 0xc4, 0x0d, 0x31, 0x33, 0xcd, 0xb1, 0xb7, 0xda,
	0x92, 0x52, 0x7e, 0x2b, 0x05, 0x44, 0x4b, 0xdc, 0x1e, 0x0d, 0x1f, 0x9b, 0xe7, 0x05, 0xe3, 0xf4,
	0x08, 0x63, 0x9b, 0xcb, 0x56, 0x53, 0xb6, 0x04, 0xa1, 0xff, 0x43, 0xa6, 0x13, 0x10, 0x1a, 0x98,
	0x65, 0x81, 0xfe, 0xcf, 0x3b, 0xaf, 0x8e, 0x31, 0x0b, 0x1c, 0xff, 0x31, 0xc7, 0x70, 0x96, 0x00,
	0xa3, 0x65, 0x30, 0x9e, 0x52, 0x12, 0x98, 0x8b, 0x82, 0x34, 0xf7, 0x1e, 0xd2, 0xb7, 0x94, 0x70,
	0x8e, 0x80, 0xa2, 0xcf, 0x21, 0xd7, 0x62, 0xb4, 0x13, 0x62, 0xcf, 0xbc, 0x2a, 0x58, 0xc5, 0xf7,
	0xb0, 0xbe, 0x91, 0x28, 0xfe, 0x24, 0x45, 0xe0, 0xdc, 0x90, 0xd1, 0xa7, 0xd8, 0x8d, 0xcd, 0x6b,
	0x13, 0xb9, 0x9b, 0x12, 0xc5, 0xb9, 0x8a, 0x80, 0x3e, 0xe5, 0xf1, 0xef, 0xc7, 0x98, 0x99, 0x4b,
	0x82, 0x7a, 0xe1, 0x3d, 0xd4, 0x07, 0x02, 0xc4, 0x6d, 0x2f, 0xe1, 0x68, 0x05, 0x32, 0x31, 0x0d,
	0xeb, 0xbb, 0xe6, 0xf5, 0x89, 0x8f, 0xdc, 0xa6, 0xe1, 0x3a, 0x7f, 0x64, 0x4c, 0xc3, 0x75, 0xeb,
	0x67, 0x0d, 0x32, 0xc2, 0xc0, 0xa8, 0x0c, 0x53, 0x21, 0x23, 0x6d, 0x87, 0x75, 0xeb, 0xbb, 0xb8,
	0x6b, 0x6a, 0x25, 0x7d, 0xb0, 0x7e, 0x80, 0x92, 0xad, 0xe3, 0x2e, 0xb2, 0x20, 0xbf, 0x8b, 0xbb,
	0x51, 0xe8, 0xb8, 0x58, 0x14, 0x86, 0x82, 0xdd, 0xdb, 0xf7, 0xaa, 0x88, 0x3e, 0x50, 0x45, 0xfa,
	0x89, 0x6b, 0x4c, 0x4c, 0x5c, 0xab, 0x00, 0x39, 0x15, 0xb4, 0x56, 0x1e, 0xb2, 0x32, 0x18, 0xad,
	0x5f, 0x75, 0xc8, 0xca, 0x30, 0x43, 0x73, 0x50, 0x08, 0x3b, 0x0d, 0x9f, 0xb8, 0x75, 0xe2, 0xa9,
	0x3a, 0x95, 0x97, 0x07, 0x6b, 0x1e, 0x5a, 0x83, 0x7c, 0x93, 0xb2, 0x3a, 0x7f, 0xaf, 0xb8, 0xd5,
	0x74, 0xad, 0x72, 0x78, 0x30, 0x7f, 0xf5, 0x18, 0x69, 0xda, 0xcb, 0xf8, 0x26, 0x65, 0xa2, 0x14,
	0x5e, 0x80, 0x4c, 0x14, 0x3b, 0x31, 0x7f, 0xc5, 0x90, 0x11, 0xe4, 0x29, 0xfa, 0x0a, 0x20, 0x4c,
	0x2a, 0x75, 0xa4, 0xde, 0x74, 0xae, 0x6f, 0xec, 0xa1, 0x4a, 0xae, 0x5e, 0x38, 0x40, 0x40, 0x5f,
	0x02, 0xc4, 0x34, 0xdc, 0xad, 0x53, 0x91, 0x25, 0x99, 0x51, 0xfa, 0x50, 0x35, 0x57, 0xf4, 0x02,
	0x27, 0x08, 0x01, 0xfa, 0x9f, 0x62, 0xfb, 0xa4, 0x4d, 0x62, 0x33, 0x3b, 0x5c, 0xe5, 0x05, 0x6e,
	0x83, 0x4b, 0xd0, 0x32, 0xcc, 0xba, 0x42, 0x45, 0x54, 0xe7, 0x66, 0x79, 0x4e, 0xf0, 0x9e, 0x99,
	0x1b, 0x46, 0xcf, 0x28, 0xc0, 0x03, 0xca, 0xf8, 0x9d, 0x47, 0x29, 0x9d, 0x08, 0x33, 0x51, 0xa2,
	0xc6, 0x53, 0x1e, 0x47, 0x98, 0x59, 0xbf, 0x18, 0x30, 0x3d, 0x94, 0x71, 0xe8, 0x5e, 0x3f, 0xf2,
	0x35, 0x11, 0x86, 0xe5, 0x49, 0x09, 0x5a, 0xb9, 0xdf, 0x26, 0xf1, 0x98, 0x1c, 0xb8, 0x05, 0xba,
	0xe3, 0xfb, 0xaa, 0xed, 0x5c, 0x3e, 0x52, 0xc3, 0x1d, 0xdf, 0x5f, 0x4d, 0xd9, 0x9c, 0x82, 0x2e,
	0x41, 0x9e, 0xe1, 0x67, 0x1d, 0xc2, 0xb0, 0x27, 0x82, 0x70, 0xe0, 0xf2, 0x3d, 0x01, 0xba, 0x0d,
	0xe9, 0x36, 0x36, 0x8d, 0x8f, 0x8a, 0x92, 0x74, 0x1b, 0x5b, 0xbf, 0x6b, 0x30, 0x35, 0x70, 0x73,
	0xb4, 0x01, 0x06, 0xe6, 0xee, 0xd0, 0x84, 0x33, 0x57, 0x8e, 0xfb, 0x62, 0xb1, 0xde, 0xee, 0x84,
	0x7e, 0x92, 0x08, 0x42, 0x8b, 0xf5, 0x04, 0x0a, 0x3d, 0x01, 0x5a, 0x84, 0x34, 0x09, 0x95, 0x29,
	0xc7, 0xf5, 0x5f, 0xc5, 0x4c, 0x93, 0x10, 0x5d, 0x84, 0x9c, 0x72, 0x8f, 0x99, 0x1e, 0x0e, 0xdc,
	0xe4, 0xdc, 0x6a, 0x40, 0x4e, 0xd9, 0x0b, 0x5d, 0x01, 0xa3, 0xc9, 0x68, 0x7b, 0x82, 0x6a, 0x5b,
	0x00, 0x86, 0x1a, 0x53, 0xfa, 0xe8, 0xc6, 0x54, 0xcb, 0x4a, 0x63, 0x58, 0x7f, 0x19, 0x70, 0x62,
	0xb0, 0xb0, 0xa2, 0xeb, 0x60, 0xf8, 0xb8, 0x19, 0x1f, 0xfd, 0x18, 0x01, 0x43, 0x55, 0xc8, 0x30,
	0xd2, 0xda, 0x89, 0x27, 0x0c, 0x1f, 0x0a, 0x2f, 0x71, 0x7c, 0xf2, 0xa1, 0xc1, 0x8d, 0x51, 0xaf,
	0xf3, 0x33, 0x29, 0x5a, 0x16, 0x1e, 0x1f, 0x16, 0x2d, 0xa3, 0xdb, 0xca, 0x77, 0x32, 0x11, 0x2f,
	0x4f, 0xe8, 0x0c, 0xdc, 0x5d, 0x51, 0x44, 0x68, 0x30, 0xe8, 0x2d, 0xf4, 0x03, 0x20, 0x12, 0xd4,
	0x43, 0xdf, 0x71, 0x71, 0x9d, 0xdf, 0xbb, 0x8e, 0x65, 0x62, 0x7e, 0xa8, 0xb6, 0x93, 0x24, 0xd8,
	0xe4, 0x4a, 0x36, 0x70, 0x33, 0xe6, 0x3e, 0x42, 0x4f, 0xe0, 0x54, 0x4f, 0xb1, 0x78, 0xa0, 0xd4,
	0x9c, 0xfb, 0x60, 0xcd, 0xb3, 0x4a, 0xb3, 0xcd, 0x95, 0x08, 0xd5, 0xb7, 0xc0, 0xd8, 0x25, 0x81,
	0x27, 0xb2, 0x7b, 0x66, 0xb2, 0x2e, 0xfe, 0x67, 0x9d, 0x04, 0x9e, 0x2d, 0x18, 0xe8, 0x12, 0x18,
	0x71, 0x37, 0xc4, 0x66, 0x41, 0xf8, 0xe4, 0x9d, 0x4a, 0x2e, 0x84, 0xd6, 0x4f, 0x90, 0x4f, 0xae,
	0x70, 0xc4, 0x38, 0x2a, 0xe2, 0x41, 0x8d, 0xa3, 0xc2, 0xe9, 0x17, 0xe1, 0x84, 0x98, 0x6b, 0xeb,
	0x72, 0xfa, 0x12, 0xce, 0xcc, 0xdb, 0x53, 0xe2, 0x6c, 0x53, 0x1c, 0x2d, 0xcc, 0x43, 0x3e, 0xb9,
	0x14, 0xca, 0x83, 0xc1, 0xed, 0x35, 0x9b, 0x42, 0x05, 0xc8, 0xac, 0x05, 0x01, 0x66, 0xb3, 0x9a,
	0xf5, 0xb7, 0x0e, 0x27, 0x47, 0x7a, 0x33, 0xba, 0x06, 0x7a, 0xc4, 0xdc, 0xa3, 0x43, 0x8f, 0xa3,
	0x50, 0x05, 0x20, 0x62, 0x6e, 0x5d, 0x35, 0xad, 0xf4, 0xf8, 0xa6, 0x55, 0x88, 0x98, 0xbb, 0x25,
	0x07, 0xce, 0x07, 0x7c, 0x4c, 0x0e, 0x30, 0x13, 0xfd, 0x62, 0x6a, 0xe5, 0xea, 0xe4, 0x39, 0xa1,
	0x72, 0xa7, 0xd5, 0x62, 0xb8, 0xe5, 0xc4, 0x7d, 0x0f, 0x49, 0x3a, 0x9a, 0x03, 0xc3, 0xa5, 0x7e,
	0x34, 0x1a, 0xa6, 0xe2, 0x90, 0x8f, 0xc5, 0x91, 0xeb, 0xf8, 0x0e, 0x6f, 0x19, 0xdc, 0x26, 0x6a,
	0x87, 0x16, 0xe1, 0x84, 0x98, 0x3a, 0xea, 0x0d, 0xd9, 0xb8, 0xb3, 0x23, 0x8d, 0x5b, 0x08, 0x6b,
	0xa2, 0x71, 0x97, 0x20, 0x47, 0x3b, 0xb1, 0x40, 0xe5, 0x86, 0x51, 0x59, 0xda, 0x89, 0x39, 0x62,
	0x1e, 0xb2, 0x2e, 0xf5, 0x9b, 0x64, 0xdf, 0xcc, 0x8f, 0x00, 0xe4, 0xb1, 0xf5, 0x9b, 0x06, 0x53,
	0x03, 0xf7, 0x47, 0x77, 0x55, 0x24, 0x69, 0x22, 0x92, 0xaa, 0xc7, 0x7f, 0x79, 0x65, 0x20, 0xa8,
	0xe6, 0xc0, 0xa0, 0xcf, 0x31, 0x13, 0x81, 0x30, 0xf8, 0x6e, 0x7e, 0xb8, 0xb0, 0x04, 0x86, 0x70,
	0x75, 0x01, 0x32, 0x77, 0x69, 0x27, 0xe0, 0xbe, 0xce, 0x81, 0xbe, 0xd5, 0x69, 0xcf, 0xa6, 0xf9,
	0xe2, 0x21, 0x09, 0x66, 0x75, 0xb1, 0x70, 0xf6, 0x67, 0x0d, 0x6b, 0xaf, 0xef, 0xfa, 0xa4, 0x38,
	0xff, 0xf7, 0x28, 0xd7, 0x4b, 0xa7, 0x27, 0xc6, 0xd7, 0xc7, 0x19, 0xbf, 0xc4, 0x87, 0x23, 0xa1,
	0x8e, 0xd0, 0x20, 0xf9, 0x30, 0x19, 0x3c, 0xe2, 0x2d, 0x61, 0x66, 0x78, 0x32, 0x3b, 0xee, 0x0f,
	0x7f, 0xdd, 0x9b, 0xf7, 0x64, 0xa4, 0x95, 0x27, 0xce, 0x7b, 0x15, 0xf9, 0xef, 0xfe, 0x7e, 0xc8,
	0x92, 0xc1, 0xcf, 0xfa, 0x02, 0xa0, 0x7f, 0xca, 0xd3, 0x0a, 0xef, 0x87, 0x2c, 0xf9, 0x90, 0xe3,
	0xeb, 0x24, 0x0b, 0xd3, 0xef, 0x66, 0xa1, 0xf5, 0x5a, 0xeb, 0x97, 0x69, 0x3e, 0x1a, 0xfe, 0xbb,
	0xa9, 0x72, 0x13, 0x32, 0x72, 0xee, 0xd1, 0x8f, 0x33, 0xf7, 0x48, 0x2c, 0x3a, 0x03, 0xda, 0xfa,
	0x68, 0x52, 0x68, 0xeb, 0x3c, 0x58, 0xc5, 0x58, 0x15, 0x89, 0xda, 0x3d, 0x18, 0xac, 0xf2, 0xd8,
	0xba, 0x0e, 0x39, 0xf5, 0xb9, 0x81, 0x16, 0x54, 0x13, 0xab, 0x37, 0xba, 0xa3, 0xb5, 0x48, 0x7e,
	0x87, 0xd4, 0xba, 0xbc, 0x71, 0x91, 0x76, 0xe8, 0xd7, 0xb6, 0x5f, 0xfe, 0x59, 0x4c, 0xbd, 0x7c,
	0x53, 0xd4, 0x5e, 0xbd, 0x29, 0x6a, 0x7f, 0xbc, 0x29, 0x6a, 0x2f, 0xde, 0x16, 0x53, 0xaf, 0xde,
	0x16, 0x53, 0xaf, 0xdf, 0x16, 0x53, 0x3f, 0x7e, 0x72, 0xf4, 0xac, 0x50, 0x4d, 0x1e, 0xd5, 0x5b,
	0x84, 0x8d, 0x46, 0x56, 0x7c, 0xea, 0xdf, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xbc, 0x4a, 0xfc,
	0x6a, 0x37, 0x10, 0x00, 0x00,
}

func (m *ViewParameter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewParameter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewParameter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Multi {
		i--
		if m.Multi {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderedColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderedColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderedColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Desc {
		i--
		if m.Desc {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Col != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Impl != nil {
		{
			size := m.Impl.Size()
			i -= size
			if _, err := m.Impl.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Taken {
		i--
		if m.Taken {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.Children) > 0 {
		dAtA3 := make([]byte, len(m.Children)*10)
		var j2 int
		for _, num := range m.Children {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintFlownode(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Parents) > 0 {
		dAtA5 := make([]byte, len(m.Parents)*10)
		var j4 int
		for _, num := range m.Parents {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintFlownode(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Fields) > 0 {
		for iNdEx := len(m.Fields) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Fields[iNdEx])
			copy(dAtA[i:], m.Fields[iNdEx])
			i = encodeVarintFlownode(dAtA, i, uint64(len(m.Fields[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Domain != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Domain))
		i--
		dAtA[i] = 0x18
	}
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Ingress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Ingress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Ingress != nil {
		{
			size, err := m.Ingress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *Node_Egress_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Egress_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Egress != nil {
		{
			size, err := m.Egress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Reader_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Reader_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Reader != nil {
		{
			size, err := m.Reader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *Node_Sharder_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Sharder_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sharder != nil {
		{
			size, err := m.Sharder.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Table_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Table_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Table != nil {
		{
			size, err := m.Table.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Node_Union) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Union) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Union != nil {
		{
			size, err := m.Union.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Join) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Join) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Join != nil {
		{
			size, err := m.Join.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *Node_Grouped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Grouped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Grouped != nil {
		{
			size, err := m.Grouped.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *Node_Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *Node_Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *Node_TopK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_TopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TopK != nil {
		{
			size, err := m.TopK.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *Node_Table) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Table) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Table) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		for iNdEx := len(m.Schema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Schema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Keyspace) > 0 {
		i -= len(m.Keyspace)
		copy(dAtA[i:], m.Keyspace)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.Keyspace)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PrimaryKey) > 0 {
		dAtA19 := make([]byte, len(m.PrimaryKey)*10)
		var j18 int
		for _, num1 := range m.PrimaryKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintFlownode(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_Ingress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Ingress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Ingress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Node_Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Egress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Egress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *Node_Reader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Reader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Reader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ColumnsForUser != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.ColumnsForUser))
		i--
		dAtA[i] = 0x40
	}
	if m.ColumnsForView != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.ColumnsForView))
		i--
		dAtA[i] = 0x38
	}
	if m.TopkLimit != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.TopkLimit))
		i--
		dAtA[i] = 0x30
	}
	if len(m.TopkOrder) > 0 {
		for iNdEx := len(m.TopkOrder) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TopkOrder[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Parameters) > 0 {
		for iNdEx := len(m.Parameters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parameters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.State) > 0 {
		dAtA21 := make([]byte, len(m.State)*10)
		var j20 int
		for _, num1 := range m.State {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA21[j20] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j20++
			}
			dAtA21[j20] = uint8(num)
			j20++
		}
		i -= j20
		copy(dAtA[i:], dAtA21[:j20])
		i = encodeVarintFlownode(dAtA, i, uint64(j20))
		i--
		dAtA[i] = 0x1a
	}
	if m.ForNode != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.ForNode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PublicId) > 0 {
		i -= len(m.PublicId)
		copy(dAtA[i:], m.PublicId)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.PublicId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Me != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Me))
		i--
		dAtA[i] = 0x20
	}
	if m.Required != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Required))
		i--
		dAtA[i] = 0x18
	}
	if m.Emit != nil {
		{
			size := m.Emit.Size()
			i -= size
			if _, err := m.Emit.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Node_InternalUnion_All) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_All) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.All != nil {
		{
			size, err := m.All.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Node_InternalUnion_EmitProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Emit) > 0 {
		for iNdEx := len(m.Emit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		dAtA25 := make([]byte, len(m.Columns)*10)
		var j24 int
		for _, num1 := range m.Columns {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA25[j24] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j24++
			}
			dAtA25[j24] = uint8(num)
			j24++
		}
		i -= j24
		copy(dAtA[i:], dAtA25[:j24])
		i = encodeVarintFlownode(dAtA, i, uint64(j24))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Ip.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node_InternalUnion_EmitAll) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalUnion_EmitAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalUnion_EmitAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sharding != nil {
		{
			size, err := m.Sharding.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalJoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalJoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalJoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Type.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.Kind != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x40
	}
	if len(m.InPlaceRightEmit) > 0 {
		for iNdEx := len(m.InPlaceRightEmit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InPlaceRightEmit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.InPlaceLeftEmit) > 0 {
		for iNdEx := len(m.InPlaceLeftEmit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InPlaceLeftEmit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Emit) > 0 {
		for iNdEx := len(m.Emit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Emit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.On1 != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.On1))
		i--
		dAtA[i] = 0x20
	}
	if m.On0 != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.On0))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Right.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Left.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node_InternalJoin_Emission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalJoin_Emission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalJoin_Emission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MultiParent {
		i--
		if m.MultiParent {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Left {
		i--
		if m.Left {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Col != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalGrouped) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalGrouped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalGrouped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Colfix) > 0 {
		dAtA33 := make([]byte, len(m.Colfix)*10)
		var j32 int
		for _, num1 := range m.Colfix {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		i -= j32
		copy(dAtA[i:], dAtA33[:j32])
		i = encodeVarintFlownode(dAtA, i, uint64(j32))
		i--
		dAtA[i] = 0x42
	}
	if len(m.OutKey) > 0 {
		dAtA35 := make([]byte, len(m.OutKey)*10)
		var j34 int
		for _, num1 := range m.OutKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		i -= j34
		copy(dAtA[i:], dAtA35[:j34])
		i = encodeVarintFlownode(dAtA, i, uint64(j34))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GroupByKey) > 0 {
		dAtA37 := make([]byte, len(m.GroupByKey)*10)
		var j36 int
		for _, num1 := range m.GroupByKey {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintFlownode(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x32
	}
	if m.Scalar {
		i--
		if m.Scalar {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Cols != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Inner) > 0 {
		for iNdEx := len(m.Inner) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Inner[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SrcSchema) > 0 {
		for iNdEx := len(m.SrcSchema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcSchema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node_InternalGrouped_Aggregation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalGrouped_Aggregation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalGrouped_Aggregation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Over != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Over))
		i--
		dAtA[i] = 0x10
	}
	if m.Kind != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalProject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalProject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalProject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Projections) > 0 {
		for iNdEx := len(m.Projections) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Projections[iNdEx])
			copy(dAtA[i:], m.Projections[iNdEx])
			i = encodeVarintFlownode(dAtA, i, uint64(len(m.Projections[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Cols != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Cols))
		i--
		dAtA[i] = 0x18
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filter) > 0 {
		for iNdEx := len(m.Filter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlownode(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalFilter_FilterExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalFilter_FilterExpr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalFilter_FilterExpr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Col != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.Col))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Expr) > 0 {
		i -= len(m.Expr)
		copy(dAtA[i:], m.Expr)
		i = encodeVarintFlownode(dAtA, i, uint64(len(m.Expr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Node_InternalTopK) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_InternalTopK) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_InternalTopK) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Params) > 0 {
		dAtA42 := make([]byte, len(m.Params)*10)
		var j41 int
		for _, num1 := range m.Params {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintFlownode(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x2a
	}
	if m.K != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.K))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Order) > 0 {
		for iNdEx := len(m.Order) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Order[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.SrcSchema) > 0 {
		for iNdEx := len(m.SrcSchema) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SrcSchema[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlownode(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintFlownode(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Node_Sharder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node_Sharder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node_Sharder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ShardBy != 0 {
		i = encodeVarintFlownode(dAtA, i, uint64(m.ShardBy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlownode(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlownode(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ViewParameter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Multi {
		n += 2
	}
	return n
}

func (m *OrderedColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != 0 {
		n += 1 + sovFlownode(uint64(m.Col))
	}
	if m.Desc {
		n += 2
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Domain != 0 {
		n += 1 + sovFlownode(uint64(m.Domain))
	}
	if len(m.Fields) > 0 {
		for _, s := range m.Fields {
			l = len(s)
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.Parents) > 0 {
		l = 0
		for _, e := range m.Parents {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	if len(m.Children) > 0 {
		l = 0
		for _, e := range m.Children {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	if m.Taken {
		n += 2
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Impl != nil {
		n += m.Impl.Size()
	}
	return n
}

func (m *Node_Ingress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ingress != nil {
		l = m.Ingress.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Egress_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Reader_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reader != nil {
		l = m.Reader.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Sharder_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sharder != nil {
		l = m.Sharder.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Table_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Table != nil {
		l = m.Table.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Union) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Union != nil {
		l = m.Union.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Join) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Join != nil {
		l = m.Join.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Grouped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Grouped != nil {
		l = m.Grouped.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_TopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopK != nil {
		l = m.TopK.Size()
		n += 2 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_Table) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrimaryKey) > 0 {
		l = 0
		for _, e := range m.PrimaryKey {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	l = len(m.Keyspace)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	if len(m.Schema) > 0 {
		for _, e := range m.Schema {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	return n
}

func (m *Node_Ingress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Node_Egress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Node_Reader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicId)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.ForNode != 0 {
		n += 1 + sovFlownode(uint64(m.ForNode))
	}
	if len(m.State) > 0 {
		l = 0
		for _, e := range m.State {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	if len(m.Parameters) > 0 {
		for _, e := range m.Parameters {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.TopkOrder) > 0 {
		for _, e := range m.TopkOrder {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if m.TopkLimit != 0 {
		n += 1 + sovFlownode(uint64(m.TopkLimit))
	}
	if m.ColumnsForView != 0 {
		n += 1 + sovFlownode(uint64(m.ColumnsForView))
	}
	if m.ColumnsForUser != 0 {
		n += 1 + sovFlownode(uint64(m.ColumnsForUser))
	}
	return n
}

func (m *Node_InternalUnion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Emit != nil {
		n += m.Emit.Size()
	}
	if m.Required != 0 {
		n += 1 + sovFlownode(uint64(m.Required))
	}
	if m.Me != 0 {
		n += 1 + sovFlownode(uint64(m.Me))
	}
	return n
}

func (m *Node_InternalUnion_Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_InternalUnion_All) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.All != nil {
		l = m.All.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	return n
}
func (m *Node_InternalUnion_EmitProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Emit) > 0 {
		for _, e := range m.Emit {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalUnion_EmitProject_EmitTuple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Ip.Size()
	n += 1 + l + sovFlownode(uint64(l))
	if len(m.Columns) > 0 {
		l = 0
		for _, e := range m.Columns {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalUnion_EmitAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Sharding != nil {
		l = m.Sharding.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	return n
}

func (m *Node_InternalJoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Left.Size()
	n += 1 + l + sovFlownode(uint64(l))
	l = m.Right.Size()
	n += 1 + l + sovFlownode(uint64(l))
	if m.On0 != 0 {
		n += 1 + sovFlownode(uint64(m.On0))
	}
	if m.On1 != 0 {
		n += 1 + sovFlownode(uint64(m.On1))
	}
	if len(m.Emit) > 0 {
		for _, e := range m.Emit {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.InPlaceLeftEmit) > 0 {
		for _, e := range m.InPlaceLeftEmit {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.InPlaceRightEmit) > 0 {
		for _, e := range m.InPlaceRightEmit {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if m.Kind != 0 {
		n += 1 + sovFlownode(uint64(m.Kind))
	}
	l = m.Type.Size()
	n += 1 + l + sovFlownode(uint64(l))
	return n
}

func (m *Node_InternalJoin_Emission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Col != 0 {
		n += 1 + sovFlownode(uint64(m.Col))
	}
	if m.Left {
		n += 2
	}
	if m.MultiParent {
		n += 2
	}
	return n
}

func (m *Node_InternalGrouped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Src.Size()
	n += 1 + l + sovFlownode(uint64(l))
	if len(m.SrcSchema) > 0 {
		for _, e := range m.SrcSchema {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.Inner) > 0 {
		for _, e := range m.Inner {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if m.Cols != 0 {
		n += 1 + sovFlownode(uint64(m.Cols))
	}
	if m.Scalar {
		n += 2
	}
	if len(m.GroupByKey) > 0 {
		l = 0
		for _, e := range m.GroupByKey {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	if len(m.OutKey) > 0 {
		l = 0
		for _, e := range m.OutKey {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	if len(m.Colfix) > 0 {
		l = 0
		for _, e := range m.Colfix {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	return n
}

func (m *Node_InternalGrouped_Aggregation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovFlownode(uint64(m.Kind))
	}
	if m.Over != 0 {
		n += 1 + sovFlownode(uint64(m.Over))
	}
	return n
}

func (m *Node_InternalProject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Cols != 0 {
		n += 1 + sovFlownode(uint64(m.Cols))
	}
	if len(m.Projections) > 0 {
		for _, s := range m.Projections {
			l = len(s)
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovFlownode(uint64(l))
	}
	if len(m.Filter) > 0 {
		for _, e := range m.Filter {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	return n
}

func (m *Node_InternalFilter_FilterExpr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expr)
	if l > 0 {
		n += 1 + l + sovFlownode(uint64(l))
	}
	if m.Col != 0 {
		n += 1 + sovFlownode(uint64(m.Col))
	}
	return n
}

func (m *Node_InternalTopK) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Src.Size()
	n += 1 + l + sovFlownode(uint64(l))
	if len(m.SrcSchema) > 0 {
		for _, e := range m.SrcSchema {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovFlownode(uint64(l))
		}
	}
	if m.K != 0 {
		n += 1 + sovFlownode(uint64(m.K))
	}
	if len(m.Params) > 0 {
		l = 0
		for _, e := range m.Params {
			l += sovFlownode(uint64(e))
		}
		n += 1 + sovFlownode(uint64(l)) + l
	}
	return n
}

func (m *Node_Sharder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardBy != 0 {
		n += 1 + sovFlownode(uint64(m.ShardBy))
	}
	return n
}

func sovFlownode(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlownode(x uint64) (n int) {
	return sovFlownode(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ViewParameter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewParameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewParameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multi", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multi = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderedColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderedColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderedColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desc", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Desc = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &dataflow.IndexPair{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			m.Domain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Domain |= vitess_io_vitess_go_boost_dataflow.DomainIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fields = append(m.Fields, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, sql.Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Parents = append(m.Parents, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Parents) == 0 {
					m.Parents = make([]vitess_io_vitess_go_boost_dataflow.LocalNodeIdx, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Parents = append(m.Parents, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Parents", wireType)
			}
		case 7:
			if wireType == 0 {
				var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Children = append(m.Children, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Children) == 0 {
					m.Children = make([]vitess_io_vitess_go_boost_dataflow.LocalNodeIdx, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v vitess_io_vitess_go_boost_dataflow.LocalNodeIdx
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= vitess_io_vitess_go_boost_dataflow.LocalNodeIdx(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Children = append(m.Children, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Children", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Taken", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Taken = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &dataflow.Sharding{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ingress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Ingress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Ingress_{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Egress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Egress_{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Reader{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Reader_{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Sharder{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Sharder_{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Table", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_Table{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Table_{v}
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Union{v}
			iNdEx = postIndex
		case 41:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalJoin{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Join{v}
			iNdEx = postIndex
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grouped", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalGrouped{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Grouped{v}
			iNdEx = postIndex
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalProject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Project{v}
			iNdEx = postIndex
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalFilter{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_Filter{v}
			iNdEx = postIndex
		case 45:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopK", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalTopK{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Impl = &Node_TopK{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Table) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Table: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Table: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PrimaryKey = append(m.PrimaryKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PrimaryKey) == 0 {
					m.PrimaryKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PrimaryKey = append(m.PrimaryKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PrimaryKey", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keyspace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keyspace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema, sql.Type{})
			if err := m.Schema[len(m.Schema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Ingress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ingress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ingress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Reader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForNode", wireType)
			}
			m.ForNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ForNode |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.State = append(m.State, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.State) == 0 {
					m.State = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.State = append(m.State, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameters = append(m.Parameters, ViewParameter{})
			if err := m.Parameters[len(m.Parameters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkOrder", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopkOrder = append(m.TopkOrder, OrderedColumn{})
			if err := m.TopkOrder[len(m.TopkOrder)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopkLimit", wireType)
			}
			m.TopkLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopkLimit |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsForView", wireType)
			}
			m.ColumnsForView = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnsForView |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnsForUser", wireType)
			}
			m.ColumnsForUser = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ColumnsForUser |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalUnion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalUnion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion_EmitProject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Emit = &Node_InternalUnion_Project{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node_InternalUnion_EmitAll{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Emit = &Node_InternalUnion_All{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			m.Required = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Required |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Me", wireType)
			}
			m.Me = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Me |= vitess_io_vitess_go_boost_dataflow.NodeIdx(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emit = append(m.Emit, Node_InternalUnion_EmitProject_EmitTuple{})
			if err := m.Emit[len(m.Emit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitProject_EmitTuple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitTuple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitTuple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Ip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Columns = append(m.Columns, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Columns) == 0 {
					m.Columns = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Columns = append(m.Columns, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalUnion_EmitAll) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmitAll: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmitAll: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &dataflow.IndexPair{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharding", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sharding == nil {
				m.Sharding = &dataflow.Sharding{}
			}
			if err := m.Sharding.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalJoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalJoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalJoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On0", wireType)
			}
			m.On0 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.On0 |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field On1", wireType)
			}
			m.On1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.On1 |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Emit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Emit = append(m.Emit, Node_InternalJoin_Emission{})
			if err := m.Emit[len(m.Emit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPlaceLeftEmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InPlaceLeftEmit = append(m.InPlaceLeftEmit, Node_InternalJoin_Emission{})
			if err := m.InPlaceLeftEmit[len(m.InPlaceLeftEmit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InPlaceRightEmit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InPlaceRightEmit = append(m.InPlaceRightEmit, Node_InternalJoin_Emission{})
			if err := m.InPlaceRightEmit[len(m.InPlaceRightEmit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Node_InternalJoin_JoinKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Type.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalJoin_Emission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Emission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Emission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Left = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiParent", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MultiParent = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalGrouped) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalGrouped: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalGrouped: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcSchema = append(m.SrcSchema, sql.Type{})
			if err := m.SrcSchema[len(m.SrcSchema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inner = append(m.Inner, Node_InternalGrouped_Aggregation{})
			if err := m.Inner[len(m.Inner)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scalar", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Scalar = bool(v != 0)
		case 6:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GroupByKey = append(m.GroupByKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.GroupByKey) == 0 {
					m.GroupByKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GroupByKey = append(m.GroupByKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupByKey", wireType)
			}
		case 7:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutKey = append(m.OutKey, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.OutKey) == 0 {
					m.OutKey = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutKey = append(m.OutKey, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutKey", wireType)
			}
		case 8:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Colfix = append(m.Colfix, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Colfix) == 0 {
					m.Colfix = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Colfix = append(m.Colfix, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Colfix", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalGrouped_Aggregation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= Node_InternalGrouped_Aggregation_Kind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Over", wireType)
			}
			m.Over = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Over |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalProject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalProject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalProject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &dataflow.IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cols", wireType)
			}
			m.Cols = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cols |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projections", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projections = append(m.Projections, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &dataflow.IndexPair{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, &Node_InternalFilter_FilterExpr{})
			if err := m.Filter[len(m.Filter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalFilter_FilterExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilterExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilterExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Col", wireType)
			}
			m.Col = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Col |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_InternalTopK) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InternalTopK: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InternalTopK: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcSchema", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcSchema = append(m.SrcSchema, sql.Type{})
			if err := m.SrcSchema[len(m.SrcSchema)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlownode
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlownode
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, OrderedColumn{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field K", wireType)
			}
			m.K = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.K |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Params = append(m.Params, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlownode
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFlownode
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFlownode
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Params) == 0 {
					m.Params = make([]int, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlownode
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Params = append(m.Params, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node_Sharder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sharder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sharder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardBy", wireType)
			}
			m.ShardBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardBy |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlownode(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlownode
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlownode(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlownode
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlownode
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlownode
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlownode
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlownode
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlownode        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlownode          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlownode = fmt.Errorf("proto: unexpected end of group")
)
