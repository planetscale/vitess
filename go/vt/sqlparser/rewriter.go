/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

func replaceAddColumnsColumns(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*AddColumns).Columns[idx] = newNode.(*ColumnDefinition)
	}
}
func replaceStructAddColumnsFirst(newNode, parent SQLNode) {
	parent.(*AddColumns).First = newNode.(*ColName)
}
func replaceStructAddColumnsAfter(newNode, parent SQLNode) {
	parent.(*AddColumns).After = newNode.(*ColName)
}
func replaceStructAddConstraintDefinitionConstraintDefinition(newNode, parent SQLNode) {
	parent.(*AddConstraintDefinition).ConstraintDefinition = newNode.(*ConstraintDefinition)
}
func replaceStructAddIndexDefinitionIndexDefinition(newNode, parent SQLNode) {
	parent.(*AddIndexDefinition).IndexDefinition = newNode.(*IndexDefinition)
}
func replaceStructAliasedExprExpr(newNode, parent SQLNode) {
	parent.(*AliasedExpr).Expr = newNode.(Expr)
}
func replaceStructAliasedExprAs(newNode, parent SQLNode) {
	parent.(*AliasedExpr).As = newNode.(ColIdent)
}
func replaceStructAliasedTableExprExpr(newNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Expr = newNode.(SimpleTableExpr)
}
func replaceStructAliasedTableExprPartitions(newNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Partitions = newNode.(Partitions)
}
func replaceStructAliasedTableExprAs(newNode, parent SQLNode) {
	parent.(*AliasedTableExpr).As = newNode.(TableIdent)
}
func replaceStructAliasedTableExprHints(newNode, parent SQLNode) {
	parent.(*AliasedTableExpr).Hints = newNode.(*IndexHints)
}
func replaceStructAlterColumnColumn(newNode, parent SQLNode) {
	parent.(*AlterColumn).Column = newNode.(*ColName)
}
func replaceStructAlterColumnDefaultVal(newNode, parent SQLNode) {
	parent.(*AlterColumn).DefaultVal = newNode.(Expr)
}
func replaceStructAlterTableTable(newNode, parent SQLNode) {
	parent.(*AlterTable).Table = newNode.(TableName)
}
func replaceAlterTableAlterOptions(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*AlterTable).AlterOptions[idx] = newNode.(AlterOption)
	}
}
func replaceStructAlterTablePartitionSpec(newNode, parent SQLNode) {
	parent.(*AlterTable).PartitionSpec = newNode.(*PartitionSpec)
}
func replaceStructAlterViewViewName(newNode, parent SQLNode) {
	parent.(*AlterView).ViewName = newNode.(TableName)
}
func replaceStructAlterViewColumns(newNode, parent SQLNode) {
	parent.(*AlterView).Columns = newNode.(Columns)
}
func replaceStructAlterViewSelect(newNode, parent SQLNode) {
	parent.(*AlterView).Select = newNode.(SelectStatement)
}
func replaceStructAlterVschemaTable(newNode, parent SQLNode) {
	parent.(*AlterVschema).Table = newNode.(TableName)
}
func replaceStructAlterVschemaVindexSpec(newNode, parent SQLNode) {
	parent.(*AlterVschema).VindexSpec = newNode.(*VindexSpec)
}
func replaceAlterVschemaVindexCols(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*AlterVschema).VindexCols[idx] = newNode.(ColIdent)
	}
}
func replaceStructAlterVschemaAutoIncSpec(newNode, parent SQLNode) {
	parent.(*AlterVschema).AutoIncSpec = newNode.(*AutoIncSpec)
}
func replaceStructAndExprLeft(newNode, parent SQLNode) {
	parent.(*AndExpr).Left = newNode.(Expr)
}
func replaceStructAndExprRight(newNode, parent SQLNode) {
	parent.(*AndExpr).Right = newNode.(Expr)
}
func replaceStructAutoIncSpecColumn(newNode, parent SQLNode) {
	parent.(*AutoIncSpec).Column = newNode.(ColIdent)
}
func replaceStructAutoIncSpecSequence(newNode, parent SQLNode) {
	parent.(*AutoIncSpec).Sequence = newNode.(TableName)
}
func replaceStructBinaryExprLeft(newNode, parent SQLNode) {
	parent.(*BinaryExpr).Left = newNode.(Expr)
}
func replaceStructBinaryExprRight(newNode, parent SQLNode) {
	parent.(*BinaryExpr).Right = newNode.(Expr)
}
func replaceStructCallProcName(newNode, parent SQLNode) {
	parent.(*CallProc).Name = newNode.(TableName)
}
func replaceStructCallProcParams(newNode, parent SQLNode) {
	parent.(*CallProc).Params = newNode.(Exprs)
}
func replaceStructCaseExprExpr(newNode, parent SQLNode) {
	parent.(*CaseExpr).Expr = newNode.(Expr)
}
func replaceCaseExprWhens(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*CaseExpr).Whens[idx] = newNode.(*When)
	}
}
func replaceStructCaseExprElse(newNode, parent SQLNode) {
	parent.(*CaseExpr).Else = newNode.(Expr)
}
func replaceStructChangeColumnOldColumn(newNode, parent SQLNode) {
	parent.(*ChangeColumn).OldColumn = newNode.(*ColName)
}
func replaceStructChangeColumnNewColDefinition(newNode, parent SQLNode) {
	parent.(*ChangeColumn).NewColDefinition = newNode.(*ColumnDefinition)
}
func replaceStructChangeColumnFirst(newNode, parent SQLNode) {
	parent.(*ChangeColumn).First = newNode.(*ColName)
}
func replaceStructChangeColumnAfter(newNode, parent SQLNode) {
	parent.(*ChangeColumn).After = newNode.(*ColName)
}
func replaceStructCheckConstraintDefinitionExpr(newNode, parent SQLNode) {
	parent.(*CheckConstraintDefinition).Expr = newNode.(Expr)
}
func replaceStructColNameName(newNode, parent SQLNode) {
	parent.(*ColName).Name = newNode.(ColIdent)
}
func replaceStructColNameQualifier(newNode, parent SQLNode) {
	parent.(*ColName).Qualifier = newNode.(TableName)
}
func replaceStructCollateExprExpr(newNode, parent SQLNode) {
	parent.(*CollateExpr).Expr = newNode.(Expr)
}
func replaceStructColumnDefinitionName(newNode, parent SQLNode) {
	parent.(*ColumnDefinition).Name = newNode.(ColIdent)
}
func replaceStructColumnTypeLength(newNode, parent SQLNode) {
	parent.(*ColumnType).Length = newNode.(*Literal)
}
func replaceStructColumnTypeScale(newNode, parent SQLNode) {
	parent.(*ColumnType).Scale = newNode.(*Literal)
}
func replaceSliceColumns(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(Columns)[idx] = newNode.(ColIdent)
	}
}
func replaceStructComparisonExprLeft(newNode, parent SQLNode) {
	parent.(*ComparisonExpr).Left = newNode.(Expr)
}
func replaceStructComparisonExprRight(newNode, parent SQLNode) {
	parent.(*ComparisonExpr).Right = newNode.(Expr)
}
func replaceStructComparisonExprEscape(newNode, parent SQLNode) {
	parent.(*ComparisonExpr).Escape = newNode.(Expr)
}
func replaceStructConstraintDefinitionDetails(newNode, parent SQLNode) {
	parent.(*ConstraintDefinition).Details = newNode.(ConstraintInfo)
}
func replaceStructConvertExprExpr(newNode, parent SQLNode) {
	parent.(*ConvertExpr).Expr = newNode.(Expr)
}
func replaceStructConvertExprType(newNode, parent SQLNode) {
	parent.(*ConvertExpr).Type = newNode.(*ConvertType)
}
func replaceStructConvertTypeLength(newNode, parent SQLNode) {
	parent.(*ConvertType).Length = newNode.(*Literal)
}
func replaceStructConvertTypeScale(newNode, parent SQLNode) {
	parent.(*ConvertType).Scale = newNode.(*Literal)
}
func replaceStructConvertUsingExprExpr(newNode, parent SQLNode) {
	parent.(*ConvertUsingExpr).Expr = newNode.(Expr)
}
func replaceStructCreateTableTable(newNode, parent SQLNode) {
	parent.(*CreateTable).Table = newNode.(TableName)
}
func replaceStructCreateTableTableSpec(newNode, parent SQLNode) {
	parent.(*CreateTable).TableSpec = newNode.(*TableSpec)
}
func replaceStructCreateTableOptLike(newNode, parent SQLNode) {
	parent.(*CreateTable).OptLike = newNode.(*OptLike)
}
func replaceStructCreateViewViewName(newNode, parent SQLNode) {
	parent.(*CreateView).ViewName = newNode.(TableName)
}
func replaceStructCreateViewColumns(newNode, parent SQLNode) {
	parent.(*CreateView).Columns = newNode.(Columns)
}
func replaceStructCreateViewSelect(newNode, parent SQLNode) {
	parent.(*CreateView).Select = newNode.(SelectStatement)
}
func replaceStructCurTimeFuncExprName(newNode, parent SQLNode) {
	parent.(*CurTimeFuncExpr).Name = newNode.(ColIdent)
}
func replaceStructCurTimeFuncExprFsp(newNode, parent SQLNode) {
	parent.(*CurTimeFuncExpr).Fsp = newNode.(Expr)
}
func replaceStructDeleteComments(newNode, parent SQLNode) {
	parent.(*Delete).Comments = newNode.(Comments)
}
func replaceStructDeleteTargets(newNode, parent SQLNode) {
	parent.(*Delete).Targets = newNode.(TableNames)
}
func replaceStructDeleteTableExprs(newNode, parent SQLNode) {
	parent.(*Delete).TableExprs = newNode.(TableExprs)
}
func replaceStructDeletePartitions(newNode, parent SQLNode) {
	parent.(*Delete).Partitions = newNode.(Partitions)
}
func replaceStructDeleteWhere(newNode, parent SQLNode) {
	parent.(*Delete).Where = newNode.(*Where)
}
func replaceStructDeleteOrderBy(newNode, parent SQLNode) {
	parent.(*Delete).OrderBy = newNode.(OrderBy)
}
func replaceStructDeleteLimit(newNode, parent SQLNode) {
	parent.(*Delete).Limit = newNode.(*Limit)
}
func replaceStructDerivedTableSelect(newNode, parent SQLNode) {
	parent.(*DerivedTable).Select = newNode.(SelectStatement)
}
func replaceStructDropColumnName(newNode, parent SQLNode) {
	parent.(*DropColumn).Name = newNode.(*ColName)
}
func replaceStructDropTableFromTables(newNode, parent SQLNode) {
	parent.(*DropTable).FromTables = newNode.(TableNames)
}
func replaceStructDropViewFromTables(newNode, parent SQLNode) {
	parent.(*DropView).FromTables = newNode.(TableNames)
}
func replaceStructExistsExprSubquery(newNode, parent SQLNode) {
	parent.(*ExistsExpr).Subquery = newNode.(*Subquery)
}
func replaceStructExplainStmtStatement(newNode, parent SQLNode) {
	parent.(*ExplainStmt).Statement = newNode.(Statement)
}
func replaceStructExplainTabTable(newNode, parent SQLNode) {
	parent.(*ExplainTab).Table = newNode.(TableName)
}
func replaceSliceExprs(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(Exprs)[idx] = newNode.(Expr)
	}
}
func replaceStructFlushTableNames(newNode, parent SQLNode) {
	parent.(*Flush).TableNames = newNode.(TableNames)
}
func replaceStructForeignKeyDefinitionSource(newNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).Source = newNode.(Columns)
}
func replaceStructForeignKeyDefinitionReferencedTable(newNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).ReferencedTable = newNode.(TableName)
}
func replaceStructForeignKeyDefinitionReferencedColumns(newNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).ReferencedColumns = newNode.(Columns)
}
func replaceStructForeignKeyDefinitionOnDelete(newNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).OnDelete = newNode.(ReferenceAction)
}
func replaceStructForeignKeyDefinitionOnUpdate(newNode, parent SQLNode) {
	parent.(*ForeignKeyDefinition).OnUpdate = newNode.(ReferenceAction)
}
func replaceStructFuncExprQualifier(newNode, parent SQLNode) {
	parent.(*FuncExpr).Qualifier = newNode.(TableIdent)
}
func replaceStructFuncExprName(newNode, parent SQLNode) {
	parent.(*FuncExpr).Name = newNode.(ColIdent)
}
func replaceStructFuncExprExprs(newNode, parent SQLNode) {
	parent.(*FuncExpr).Exprs = newNode.(SelectExprs)
}
func replaceSliceGroupBy(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(GroupBy)[idx] = newNode.(Expr)
	}
}
func replaceStructGroupConcatExprExprs(newNode, parent SQLNode) {
	parent.(*GroupConcatExpr).Exprs = newNode.(SelectExprs)
}
func replaceStructGroupConcatExprOrderBy(newNode, parent SQLNode) {
	parent.(*GroupConcatExpr).OrderBy = newNode.(OrderBy)
}
func replaceStructGroupConcatExprLimit(newNode, parent SQLNode) {
	parent.(*GroupConcatExpr).Limit = newNode.(*Limit)
}
func replaceStructIndexDefinitionInfo(newNode, parent SQLNode) {
	parent.(*IndexDefinition).Info = newNode.(*IndexInfo)
}
func replaceIndexHintsIndexes(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*IndexHints).Indexes[idx] = newNode.(ColIdent)
	}
}
func replaceStructIndexInfoName(newNode, parent SQLNode) {
	parent.(*IndexInfo).Name = newNode.(ColIdent)
}
func replaceStructIndexInfoConstraintName(newNode, parent SQLNode) {
	parent.(*IndexInfo).ConstraintName = newNode.(ColIdent)
}
func replaceStructInsertComments(newNode, parent SQLNode) {
	parent.(*Insert).Comments = newNode.(Comments)
}
func replaceStructInsertTable(newNode, parent SQLNode) {
	parent.(*Insert).Table = newNode.(TableName)
}
func replaceStructInsertPartitions(newNode, parent SQLNode) {
	parent.(*Insert).Partitions = newNode.(Partitions)
}
func replaceStructInsertColumns(newNode, parent SQLNode) {
	parent.(*Insert).Columns = newNode.(Columns)
}
func replaceStructInsertRows(newNode, parent SQLNode) {
	parent.(*Insert).Rows = newNode.(InsertRows)
}
func replaceStructInsertOnDup(newNode, parent SQLNode) {
	parent.(*Insert).OnDup = newNode.(OnDup)
}
func replaceStructIntervalExprExpr(newNode, parent SQLNode) {
	parent.(*IntervalExpr).Expr = newNode.(Expr)
}
func replaceStructIsExprExpr(newNode, parent SQLNode) {
	parent.(*IsExpr).Expr = newNode.(Expr)
}
func replaceStructJoinConditionOn(newNode, parent SQLNode) {
	parent.(*JoinCondition).On = newNode.(Expr)
}
func replaceStructJoinConditionUsing(newNode, parent SQLNode) {
	parent.(*JoinCondition).Using = newNode.(Columns)
}
func replaceStructJoinTableExprLeftExpr(newNode, parent SQLNode) {
	parent.(*JoinTableExpr).LeftExpr = newNode.(TableExpr)
}
func replaceStructJoinTableExprRightExpr(newNode, parent SQLNode) {
	parent.(*JoinTableExpr).RightExpr = newNode.(TableExpr)
}
func replaceStructJoinTableExprCondition(newNode, parent SQLNode) {
	parent.(*JoinTableExpr).Condition = newNode.(JoinCondition)
}
func replaceStructLimitOffset(newNode, parent SQLNode) {
	parent.(*Limit).Offset = newNode.(Expr)
}
func replaceStructLimitRowcount(newNode, parent SQLNode) {
	parent.(*Limit).Rowcount = newNode.(Expr)
}
func replaceStructMatchExprColumns(newNode, parent SQLNode) {
	parent.(*MatchExpr).Columns = newNode.(SelectExprs)
}
func replaceStructMatchExprExpr(newNode, parent SQLNode) {
	parent.(*MatchExpr).Expr = newNode.(Expr)
}
func replaceStructModifyColumnNewColDefinition(newNode, parent SQLNode) {
	parent.(*ModifyColumn).NewColDefinition = newNode.(*ColumnDefinition)
}
func replaceStructModifyColumnFirst(newNode, parent SQLNode) {
	parent.(*ModifyColumn).First = newNode.(*ColName)
}
func replaceStructModifyColumnAfter(newNode, parent SQLNode) {
	parent.(*ModifyColumn).After = newNode.(*ColName)
}
func replaceStructNextvalExpr(newNode, parent SQLNode) {
	parent.(*Nextval).Expr = newNode.(Expr)
}
func replaceStructNotExprExpr(newNode, parent SQLNode) {
	parent.(*NotExpr).Expr = newNode.(Expr)
}
func replaceSliceOnDup(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(OnDup)[idx] = newNode.(*UpdateExpr)
	}
}
func replaceStructOptLikeLikeTable(newNode, parent SQLNode) {
	parent.(*OptLike).LikeTable = newNode.(TableName)
}
func replaceStructOrExprLeft(newNode, parent SQLNode) {
	parent.(*OrExpr).Left = newNode.(Expr)
}
func replaceStructOrExprRight(newNode, parent SQLNode) {
	parent.(*OrExpr).Right = newNode.(Expr)
}
func replaceStructOrderExpr(newNode, parent SQLNode) {
	parent.(*Order).Expr = newNode.(Expr)
}
func replaceSliceOrderBy(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(OrderBy)[idx] = newNode.(*Order)
	}
}
func replaceStructOrderByOptionCols(newNode, parent SQLNode) {
	parent.(*OrderByOption).Cols = newNode.(Columns)
}
func replaceStructParenSelectSelect(newNode, parent SQLNode) {
	parent.(*ParenSelect).Select = newNode.(SelectStatement)
}
func replaceStructParenTableExprExprs(newNode, parent SQLNode) {
	parent.(*ParenTableExpr).Exprs = newNode.(TableExprs)
}
func replaceStructPartitionDefinitionName(newNode, parent SQLNode) {
	parent.(*PartitionDefinition).Name = newNode.(ColIdent)
}
func replaceStructPartitionDefinitionLimit(newNode, parent SQLNode) {
	parent.(*PartitionDefinition).Limit = newNode.(Expr)
}
func replaceStructPartitionSpecNames(newNode, parent SQLNode) {
	parent.(*PartitionSpec).Names = newNode.(Partitions)
}
func replaceStructPartitionSpecNumber(newNode, parent SQLNode) {
	parent.(*PartitionSpec).Number = newNode.(*Literal)
}
func replaceStructPartitionSpecTableName(newNode, parent SQLNode) {
	parent.(*PartitionSpec).TableName = newNode.(TableName)
}
func replacePartitionSpecDefinitions(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*PartitionSpec).Definitions[idx] = newNode.(*PartitionDefinition)
	}
}
func replaceSlicePartitions(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(Partitions)[idx] = newNode.(ColIdent)
	}
}
func replaceStructRangeCondLeft(newNode, parent SQLNode) {
	parent.(*RangeCond).Left = newNode.(Expr)
}
func replaceStructRangeCondFrom(newNode, parent SQLNode) {
	parent.(*RangeCond).From = newNode.(Expr)
}
func replaceStructRangeCondTo(newNode, parent SQLNode) {
	parent.(*RangeCond).To = newNode.(Expr)
}
func replaceStructReleaseName(newNode, parent SQLNode) {
	parent.(*Release).Name = newNode.(ColIdent)
}
func replaceStructRenameTableNameTable(newNode, parent SQLNode) {
	parent.(*RenameTableName).Table = newNode.(TableName)
}
func replaceStructSRollbackName(newNode, parent SQLNode) {
	parent.(*SRollback).Name = newNode.(ColIdent)
}
func replaceStructSavepointName(newNode, parent SQLNode) {
	parent.(*Savepoint).Name = newNode.(ColIdent)
}
func replaceStructSelectComments(newNode, parent SQLNode) {
	parent.(*Select).Comments = newNode.(Comments)
}
func replaceStructSelectSelectExprs(newNode, parent SQLNode) {
	parent.(*Select).SelectExprs = newNode.(SelectExprs)
}
func replaceStructSelectFrom(newNode, parent SQLNode) {
	parent.(*Select).From = newNode.(TableExprs)
}
func replaceStructSelectWhere(newNode, parent SQLNode) {
	parent.(*Select).Where = newNode.(*Where)
}
func replaceStructSelectGroupBy(newNode, parent SQLNode) {
	parent.(*Select).GroupBy = newNode.(GroupBy)
}
func replaceStructSelectHaving(newNode, parent SQLNode) {
	parent.(*Select).Having = newNode.(*Where)
}
func replaceStructSelectOrderBy(newNode, parent SQLNode) {
	parent.(*Select).OrderBy = newNode.(OrderBy)
}
func replaceStructSelectLimit(newNode, parent SQLNode) {
	parent.(*Select).Limit = newNode.(*Limit)
}
func replaceStructSelectInto(newNode, parent SQLNode) {
	parent.(*Select).Into = newNode.(*SelectInto)
}
func replaceSliceSelectExprs(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(SelectExprs)[idx] = newNode.(SelectExpr)
	}
}
func replaceStructSetComments(newNode, parent SQLNode) {
	parent.(*Set).Comments = newNode.(Comments)
}
func replaceStructSetExprs(newNode, parent SQLNode) {
	parent.(*Set).Exprs = newNode.(SetExprs)
}
func replaceStructSetExprName(newNode, parent SQLNode) {
	parent.(*SetExpr).Name = newNode.(ColIdent)
}
func replaceStructSetExprExpr(newNode, parent SQLNode) {
	parent.(*SetExpr).Expr = newNode.(Expr)
}
func replaceSliceSetExprs(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(SetExprs)[idx] = newNode.(*SetExpr)
	}
}
func replaceStructSetTransactionSQLNode(newNode, parent SQLNode) {
	parent.(*SetTransaction).SQLNode = newNode.(SQLNode)
}
func replaceStructSetTransactionComments(newNode, parent SQLNode) {
	parent.(*SetTransaction).Comments = newNode.(Comments)
}
func replaceSetTransactionCharacteristics(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*SetTransaction).Characteristics[idx] = newNode.(Characteristic)
	}
}
func replaceStructShowInternal(newNode, parent SQLNode) {
	parent.(*Show).Internal = newNode.(ShowInternal)
}
func replaceStructShowBasicFilter(newNode, parent SQLNode) {
	parent.(*ShowBasic).Filter = newNode.(*ShowFilter)
}
func replaceStructShowColumnsTable(newNode, parent SQLNode) {
	parent.(*ShowColumns).Table = newNode.(TableName)
}
func replaceStructShowColumnsFilter(newNode, parent SQLNode) {
	parent.(*ShowColumns).Filter = newNode.(*ShowFilter)
}
func replaceStructShowFilterFilter(newNode, parent SQLNode) {
	parent.(*ShowFilter).Filter = newNode.(Expr)
}
func replaceStructShowLegacyOnTable(newNode, parent SQLNode) {
	parent.(*ShowLegacy).OnTable = newNode.(TableName)
}
func replaceStructShowLegacyTable(newNode, parent SQLNode) {
	parent.(*ShowLegacy).Table = newNode.(TableName)
}
func replaceStructShowLegacyShowCollationFilterOpt(newNode, parent SQLNode) {
	parent.(*ShowLegacy).ShowCollationFilterOpt = newNode.(Expr)
}
func replaceStructShowTableStatusFilter(newNode, parent SQLNode) {
	parent.(*ShowTableStatus).Filter = newNode.(*ShowFilter)
}
func replaceStructStarExprTableName(newNode, parent SQLNode) {
	parent.(*StarExpr).TableName = newNode.(TableName)
}
func replaceStructStreamComments(newNode, parent SQLNode) {
	parent.(*Stream).Comments = newNode.(Comments)
}
func replaceStructStreamSelectExpr(newNode, parent SQLNode) {
	parent.(*Stream).SelectExpr = newNode.(SelectExpr)
}
func replaceStructStreamTable(newNode, parent SQLNode) {
	parent.(*Stream).Table = newNode.(TableName)
}
func replaceStructSubquerySelect(newNode, parent SQLNode) {
	parent.(*Subquery).Select = newNode.(SelectStatement)
}
func replaceStructSubstrExprName(newNode, parent SQLNode) {
	parent.(*SubstrExpr).Name = newNode.(*ColName)
}
func replaceStructSubstrExprStrVal(newNode, parent SQLNode) {
	parent.(*SubstrExpr).StrVal = newNode.(*Literal)
}
func replaceStructSubstrExprFrom(newNode, parent SQLNode) {
	parent.(*SubstrExpr).From = newNode.(Expr)
}
func replaceStructSubstrExprTo(newNode, parent SQLNode) {
	parent.(*SubstrExpr).To = newNode.(Expr)
}
func replaceSliceTableExprs(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(TableExprs)[idx] = newNode.(TableExpr)
	}
}
func replaceStructTableNameName(newNode, parent SQLNode) {
	parent.(*TableName).Name = newNode.(TableIdent)
}
func replaceStructTableNameQualifier(newNode, parent SQLNode) {
	parent.(*TableName).Qualifier = newNode.(TableIdent)
}
func replaceSliceTableNames(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(TableNames)[idx] = newNode.(TableName)
	}
}
func replaceTableSpecColumns(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*TableSpec).Columns[idx] = newNode.(*ColumnDefinition)
	}
}
func replaceTableSpecIndexes(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*TableSpec).Indexes[idx] = newNode.(*IndexDefinition)
	}
}
func replaceTableSpecConstraints(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*TableSpec).Constraints[idx] = newNode.(*ConstraintDefinition)
	}
}
func replaceStructTableSpecOptions(newNode, parent SQLNode) {
	parent.(*TableSpec).Options = newNode.(TableOptions)
}
func replaceStructTimestampFuncExprExpr1(newNode, parent SQLNode) {
	parent.(*TimestampFuncExpr).Expr1 = newNode.(Expr)
}
func replaceStructTimestampFuncExprExpr2(newNode, parent SQLNode) {
	parent.(*TimestampFuncExpr).Expr2 = newNode.(Expr)
}
func replaceStructTruncateTableTable(newNode, parent SQLNode) {
	parent.(*TruncateTable).Table = newNode.(TableName)
}
func replaceStructUnaryExprExpr(newNode, parent SQLNode) {
	parent.(*UnaryExpr).Expr = newNode.(Expr)
}
func replaceStructUnionFirstStatement(newNode, parent SQLNode) {
	parent.(*Union).FirstStatement = newNode.(SelectStatement)
}
func replaceUnionUnionSelects(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*Union).UnionSelects[idx] = newNode.(*UnionSelect)
	}
}
func replaceStructUnionOrderBy(newNode, parent SQLNode) {
	parent.(*Union).OrderBy = newNode.(OrderBy)
}
func replaceStructUnionLimit(newNode, parent SQLNode) {
	parent.(*Union).Limit = newNode.(*Limit)
}
func replaceStructUnionSelectStatement(newNode, parent SQLNode) {
	parent.(*UnionSelect).Statement = newNode.(SelectStatement)
}
func replaceStructUpdateComments(newNode, parent SQLNode) {
	parent.(*Update).Comments = newNode.(Comments)
}
func replaceStructUpdateTableExprs(newNode, parent SQLNode) {
	parent.(*Update).TableExprs = newNode.(TableExprs)
}
func replaceStructUpdateExprs(newNode, parent SQLNode) {
	parent.(*Update).Exprs = newNode.(UpdateExprs)
}
func replaceStructUpdateWhere(newNode, parent SQLNode) {
	parent.(*Update).Where = newNode.(*Where)
}
func replaceStructUpdateOrderBy(newNode, parent SQLNode) {
	parent.(*Update).OrderBy = newNode.(OrderBy)
}
func replaceStructUpdateLimit(newNode, parent SQLNode) {
	parent.(*Update).Limit = newNode.(*Limit)
}
func replaceStructUpdateExprName(newNode, parent SQLNode) {
	parent.(*UpdateExpr).Name = newNode.(*ColName)
}
func replaceStructUpdateExprExpr(newNode, parent SQLNode) {
	parent.(*UpdateExpr).Expr = newNode.(Expr)
}
func replaceSliceUpdateExprs(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(UpdateExprs)[idx] = newNode.(*UpdateExpr)
	}
}
func replaceStructUseDBName(newNode, parent SQLNode) {
	parent.(*Use).DBName = newNode.(TableIdent)
}
func replaceStructVStreamComments(newNode, parent SQLNode) {
	parent.(*VStream).Comments = newNode.(Comments)
}
func replaceStructVStreamSelectExpr(newNode, parent SQLNode) {
	parent.(*VStream).SelectExpr = newNode.(SelectExpr)
}
func replaceStructVStreamTable(newNode, parent SQLNode) {
	parent.(*VStream).Table = newNode.(TableName)
}
func replaceStructVStreamWhere(newNode, parent SQLNode) {
	parent.(*VStream).Where = newNode.(*Where)
}
func replaceStructVStreamLimit(newNode, parent SQLNode) {
	parent.(*VStream).Limit = newNode.(*Limit)
}
func replaceSliceValTuple(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(ValTuple)[idx] = newNode.(Expr)
	}
}
func replaceSliceValues(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(Values)[idx] = newNode.(ValTuple)
	}
}
func replaceStructValuesFuncExprName(newNode, parent SQLNode) {
	parent.(*ValuesFuncExpr).Name = newNode.(*ColName)
}
func replaceStructVindexParamKey(newNode, parent SQLNode) {
	parent.(*VindexParam).Key = newNode.(ColIdent)
}
func replaceStructVindexSpecName(newNode, parent SQLNode) {
	parent.(*VindexSpec).Name = newNode.(ColIdent)
}
func replaceStructVindexSpecType(newNode, parent SQLNode) {
	parent.(*VindexSpec).Type = newNode.(ColIdent)
}
func replaceVindexSpecParams(idx int) func(SQLNode, SQLNode) {
	return func(newNode, container SQLNode) {
		container.(*VindexSpec).Params[idx] = newNode.(VindexParam)
	}
}
func replaceStructWhenCond(newNode, parent SQLNode) {
	parent.(*When).Cond = newNode.(Expr)
}
func replaceStructWhenVal(newNode, parent SQLNode) {
	parent.(*When).Val = newNode.(Expr)
}
func replaceStructWhereExpr(newNode, parent SQLNode) {
	parent.(*Where).Expr = newNode.(Expr)
}
func replaceStructXorExprLeft(newNode, parent SQLNode) {
	parent.(*XorExpr).Left = newNode.(Expr)
}
func replaceStructXorExprRight(newNode, parent SQLNode) {
	parent.(*XorExpr).Right = newNode.(Expr)
}
func (a *application) apply(parent, node SQLNode, replacer replacerFunc) {
	if node == nil || isNilValue(node) {
		return
	}
	saved := a.cursor
	a.cursor.replacer = replacer
	a.cursor.node = node
	a.cursor.parent = parent
	if a.pre != nil && !a.pre(&a.cursor) {
		a.cursor = saved
		return
	}
	switch n := node.(type) {
	case *AddColumns:
		for x, el := range n.Columns {
			a.apply(node, el, replaceAddColumnsColumns(x))
		}
		a.apply(node, n.First, replaceStructAddColumnsFirst)
		a.apply(node, n.After, replaceStructAddColumnsAfter)
	case *AddConstraintDefinition:
		a.apply(node, n.ConstraintDefinition, replaceStructAddConstraintDefinitionConstraintDefinition)
	case *AddIndexDefinition:
		a.apply(node, n.IndexDefinition, replaceStructAddIndexDefinitionIndexDefinition)
	case *AliasedExpr:
		a.apply(node, n.Expr, replaceStructAliasedExprExpr)
		a.apply(node, n.As, replaceStructAliasedExprAs)
	case *AliasedTableExpr:
		a.apply(node, n.Expr, replaceStructAliasedTableExprExpr)
		a.apply(node, n.Partitions, replaceStructAliasedTableExprPartitions)
		a.apply(node, n.As, replaceStructAliasedTableExprAs)
		a.apply(node, n.Hints, replaceStructAliasedTableExprHints)
	case *AlterCharset:
	case *AlterColumn:
		a.apply(node, n.Column, replaceStructAlterColumnColumn)
		a.apply(node, n.DefaultVal, replaceStructAlterColumnDefaultVal)
	case *AlterDatabase:
	case *AlterTable:
		a.apply(node, n.Table, replaceStructAlterTableTable)
		for x, el := range n.AlterOptions {
			a.apply(node, el, replaceAlterTableAlterOptions(x))
		}
		a.apply(node, n.PartitionSpec, replaceStructAlterTablePartitionSpec)
	case *AlterView:
		a.apply(node, n.ViewName, replaceStructAlterViewViewName)
		a.apply(node, n.Columns, replaceStructAlterViewColumns)
		a.apply(node, n.Select, replaceStructAlterViewSelect)
	case *AlterVschema:
		a.apply(node, n.Table, replaceStructAlterVschemaTable)
		a.apply(node, n.VindexSpec, replaceStructAlterVschemaVindexSpec)
		for x, el := range n.VindexCols {
			a.apply(node, el, replaceAlterVschemaVindexCols(x))
		}
		a.apply(node, n.AutoIncSpec, replaceStructAlterVschemaAutoIncSpec)
	case *AndExpr:
		a.apply(node, n.Left, replaceStructAndExprLeft)
		a.apply(node, n.Right, replaceStructAndExprRight)
	case Argument:
	case *AutoIncSpec:
		a.apply(node, n.Column, replaceStructAutoIncSpecColumn)
		a.apply(node, n.Sequence, replaceStructAutoIncSpecSequence)
	case *Begin:
	case *BinaryExpr:
		a.apply(node, n.Left, replaceStructBinaryExprLeft)
		a.apply(node, n.Right, replaceStructBinaryExprRight)
	case *CallProc:
		a.apply(node, n.Name, replaceStructCallProcName)
		a.apply(node, n.Params, replaceStructCallProcParams)
	case *CaseExpr:
		a.apply(node, n.Expr, replaceStructCaseExprExpr)
		for x, el := range n.Whens {
			a.apply(node, el, replaceCaseExprWhens(x))
		}
		a.apply(node, n.Else, replaceStructCaseExprElse)
	case *ChangeColumn:
		a.apply(node, n.OldColumn, replaceStructChangeColumnOldColumn)
		a.apply(node, n.NewColDefinition, replaceStructChangeColumnNewColDefinition)
		a.apply(node, n.First, replaceStructChangeColumnFirst)
		a.apply(node, n.After, replaceStructChangeColumnAfter)
	case *CheckConstraintDefinition:
		a.apply(node, n.Expr, replaceStructCheckConstraintDefinitionExpr)
	case ColIdent:
	case *ColIdent:
	case *ColName:
		a.apply(node, n.Name, replaceStructColNameName)
		a.apply(node, n.Qualifier, replaceStructColNameQualifier)
	case *CollateExpr:
		a.apply(node, n.Expr, replaceStructCollateExprExpr)
	case *ColumnDefinition:
		a.apply(node, n.Name, replaceStructColumnDefinitionName)
	case *ColumnType:
		a.apply(node, n.Length, replaceStructColumnTypeLength)
		a.apply(node, n.Scale, replaceStructColumnTypeScale)
	case Columns:
		for x, el := range n {
			a.apply(node, el, replaceSliceColumns(x))
		}
	case Comments:
	case *Commit:
	case *ComparisonExpr:
		a.apply(node, n.Left, replaceStructComparisonExprLeft)
		a.apply(node, n.Right, replaceStructComparisonExprRight)
		a.apply(node, n.Escape, replaceStructComparisonExprEscape)
	case *ConstraintDefinition:
		a.apply(node, n.Details, replaceStructConstraintDefinitionDetails)
	case *ConvertExpr:
		a.apply(node, n.Expr, replaceStructConvertExprExpr)
		a.apply(node, n.Type, replaceStructConvertExprType)
	case *ConvertType:
		a.apply(node, n.Length, replaceStructConvertTypeLength)
		a.apply(node, n.Scale, replaceStructConvertTypeScale)
	case *ConvertUsingExpr:
		a.apply(node, n.Expr, replaceStructConvertUsingExprExpr)
	case *CreateDatabase:
	case *CreateTable:
		a.apply(node, n.Table, replaceStructCreateTableTable)
		a.apply(node, n.TableSpec, replaceStructCreateTableTableSpec)
		a.apply(node, n.OptLike, replaceStructCreateTableOptLike)
	case *CreateView:
		a.apply(node, n.ViewName, replaceStructCreateViewViewName)
		a.apply(node, n.Columns, replaceStructCreateViewColumns)
		a.apply(node, n.Select, replaceStructCreateViewSelect)
	case *CurTimeFuncExpr:
		a.apply(node, n.Name, replaceStructCurTimeFuncExprName)
		a.apply(node, n.Fsp, replaceStructCurTimeFuncExprFsp)
	case *Default:
	case *Delete:
		a.apply(node, n.Comments, replaceStructDeleteComments)
		a.apply(node, n.Targets, replaceStructDeleteTargets)
		a.apply(node, n.TableExprs, replaceStructDeleteTableExprs)
		a.apply(node, n.Partitions, replaceStructDeletePartitions)
		a.apply(node, n.Where, replaceStructDeleteWhere)
		a.apply(node, n.OrderBy, replaceStructDeleteOrderBy)
		a.apply(node, n.Limit, replaceStructDeleteLimit)
	case *DerivedTable:
		a.apply(node, n.Select, replaceStructDerivedTableSelect)
	case *DropColumn:
		a.apply(node, n.Name, replaceStructDropColumnName)
	case *DropDatabase:
	case *DropKey:
	case *DropTable:
		a.apply(node, n.FromTables, replaceStructDropTableFromTables)
	case *DropView:
		a.apply(node, n.FromTables, replaceStructDropViewFromTables)
	case *ExistsExpr:
		a.apply(node, n.Subquery, replaceStructExistsExprSubquery)
	case *ExplainStmt:
		a.apply(node, n.Statement, replaceStructExplainStmtStatement)
	case *ExplainTab:
		a.apply(node, n.Table, replaceStructExplainTabTable)
	case Exprs:
		for x, el := range n {
			a.apply(node, el, replaceSliceExprs(x))
		}
	case *Flush:
		a.apply(node, n.TableNames, replaceStructFlushTableNames)
	case *Force:
	case *ForeignKeyDefinition:
		a.apply(node, n.Source, replaceStructForeignKeyDefinitionSource)
		a.apply(node, n.ReferencedTable, replaceStructForeignKeyDefinitionReferencedTable)
		a.apply(node, n.ReferencedColumns, replaceStructForeignKeyDefinitionReferencedColumns)
		a.apply(node, n.OnDelete, replaceStructForeignKeyDefinitionOnDelete)
		a.apply(node, n.OnUpdate, replaceStructForeignKeyDefinitionOnUpdate)
	case *FuncExpr:
		a.apply(node, n.Qualifier, replaceStructFuncExprQualifier)
		a.apply(node, n.Name, replaceStructFuncExprName)
		a.apply(node, n.Exprs, replaceStructFuncExprExprs)
	case GroupBy:
		for x, el := range n {
			a.apply(node, el, replaceSliceGroupBy(x))
		}
	case *GroupConcatExpr:
		a.apply(node, n.Exprs, replaceStructGroupConcatExprExprs)
		a.apply(node, n.OrderBy, replaceStructGroupConcatExprOrderBy)
		a.apply(node, n.Limit, replaceStructGroupConcatExprLimit)
	case *IndexDefinition:
		a.apply(node, n.Info, replaceStructIndexDefinitionInfo)
	case *IndexHints:
		for x, el := range n.Indexes {
			a.apply(node, el, replaceIndexHintsIndexes(x))
		}
	case *IndexInfo:
		a.apply(node, n.Name, replaceStructIndexInfoName)
		a.apply(node, n.ConstraintName, replaceStructIndexInfoConstraintName)
	case *Insert:
		a.apply(node, n.Comments, replaceStructInsertComments)
		a.apply(node, n.Table, replaceStructInsertTable)
		a.apply(node, n.Partitions, replaceStructInsertPartitions)
		a.apply(node, n.Columns, replaceStructInsertColumns)
		a.apply(node, n.Rows, replaceStructInsertRows)
		a.apply(node, n.OnDup, replaceStructInsertOnDup)
	case *IntervalExpr:
		a.apply(node, n.Expr, replaceStructIntervalExprExpr)
	case *IsExpr:
		a.apply(node, n.Expr, replaceStructIsExprExpr)
	case JoinCondition:
		a.apply(node, n.On, replacePanic("JoinCondition On"))
		a.apply(node, n.Using, replacePanic("JoinCondition Using"))
	case *JoinCondition:
		a.apply(node, n.On, replaceStructJoinConditionOn)
		a.apply(node, n.Using, replaceStructJoinConditionUsing)
	case *JoinTableExpr:
		a.apply(node, n.LeftExpr, replaceStructJoinTableExprLeftExpr)
		a.apply(node, n.RightExpr, replaceStructJoinTableExprRightExpr)
		a.apply(node, n.Condition, replaceStructJoinTableExprCondition)
	case *KeyState:
	case *Limit:
		a.apply(node, n.Offset, replaceStructLimitOffset)
		a.apply(node, n.Rowcount, replaceStructLimitRowcount)
	case ListArg:
	case *Literal:
	case *Load:
	case *LockOption:
	case *LockTables:
	case *MatchExpr:
		a.apply(node, n.Columns, replaceStructMatchExprColumns)
		a.apply(node, n.Expr, replaceStructMatchExprExpr)
	case *ModifyColumn:
		a.apply(node, n.NewColDefinition, replaceStructModifyColumnNewColDefinition)
		a.apply(node, n.First, replaceStructModifyColumnFirst)
		a.apply(node, n.After, replaceStructModifyColumnAfter)
	case Nextval:
		a.apply(node, n.Expr, replacePanic("Nextval Expr"))
	case *Nextval:
		a.apply(node, n.Expr, replaceStructNextvalExpr)
	case *NotExpr:
		a.apply(node, n.Expr, replaceStructNotExprExpr)
	case *NullVal:
	case OnDup:
		for x, el := range n {
			a.apply(node, el, replaceSliceOnDup(x))
		}
	case *OptLike:
		a.apply(node, n.LikeTable, replaceStructOptLikeLikeTable)
	case *OrExpr:
		a.apply(node, n.Left, replaceStructOrExprLeft)
		a.apply(node, n.Right, replaceStructOrExprRight)
	case *Order:
		a.apply(node, n.Expr, replaceStructOrderExpr)
	case OrderBy:
		for x, el := range n {
			a.apply(node, el, replaceSliceOrderBy(x))
		}
	case *OrderByOption:
		a.apply(node, n.Cols, replaceStructOrderByOptionCols)
	case *OtherAdmin:
	case *OtherRead:
	case *ParenSelect:
		a.apply(node, n.Select, replaceStructParenSelectSelect)
	case *ParenTableExpr:
		a.apply(node, n.Exprs, replaceStructParenTableExprExprs)
	case *PartitionDefinition:
		a.apply(node, n.Name, replaceStructPartitionDefinitionName)
		a.apply(node, n.Limit, replaceStructPartitionDefinitionLimit)
	case *PartitionSpec:
		a.apply(node, n.Names, replaceStructPartitionSpecNames)
		a.apply(node, n.Number, replaceStructPartitionSpecNumber)
		a.apply(node, n.TableName, replaceStructPartitionSpecTableName)
		for x, el := range n.Definitions {
			a.apply(node, el, replacePartitionSpecDefinitions(x))
		}
	case Partitions:
		for x, el := range n {
			a.apply(node, el, replaceSlicePartitions(x))
		}
	case *RangeCond:
		a.apply(node, n.Left, replaceStructRangeCondLeft)
		a.apply(node, n.From, replaceStructRangeCondFrom)
		a.apply(node, n.To, replaceStructRangeCondTo)
	case *Release:
		a.apply(node, n.Name, replaceStructReleaseName)
	case *RenameIndex:
	case *RenameTable:
	case *RenameTableName:
		a.apply(node, n.Table, replaceStructRenameTableNameTable)
	case *Rollback:
	case *SRollback:
		a.apply(node, n.Name, replaceStructSRollbackName)
	case *Savepoint:
		a.apply(node, n.Name, replaceStructSavepointName)
	case *Select:
		a.apply(node, n.Comments, replaceStructSelectComments)
		a.apply(node, n.SelectExprs, replaceStructSelectSelectExprs)
		a.apply(node, n.From, replaceStructSelectFrom)
		a.apply(node, n.Where, replaceStructSelectWhere)
		a.apply(node, n.GroupBy, replaceStructSelectGroupBy)
		a.apply(node, n.Having, replaceStructSelectHaving)
		a.apply(node, n.OrderBy, replaceStructSelectOrderBy)
		a.apply(node, n.Limit, replaceStructSelectLimit)
		a.apply(node, n.Into, replaceStructSelectInto)
	case SelectExprs:
		for x, el := range n {
			a.apply(node, el, replaceSliceSelectExprs(x))
		}
	case *SelectInto:
	case *Set:
		a.apply(node, n.Comments, replaceStructSetComments)
		a.apply(node, n.Exprs, replaceStructSetExprs)
	case *SetExpr:
		a.apply(node, n.Name, replaceStructSetExprName)
		a.apply(node, n.Expr, replaceStructSetExprExpr)
	case SetExprs:
		for x, el := range n {
			a.apply(node, el, replaceSliceSetExprs(x))
		}
	case *SetTransaction:
		a.apply(node, n.SQLNode, replaceStructSetTransactionSQLNode)
		a.apply(node, n.Comments, replaceStructSetTransactionComments)
		for x, el := range n.Characteristics {
			a.apply(node, el, replaceSetTransactionCharacteristics(x))
		}
	case *Show:
		a.apply(node, n.Internal, replaceStructShowInternal)
	case *ShowBasic:
		a.apply(node, n.Filter, replaceStructShowBasicFilter)
	case *ShowColumns:
		a.apply(node, n.Table, replaceStructShowColumnsTable)
		a.apply(node, n.Filter, replaceStructShowColumnsFilter)
	case *ShowFilter:
		a.apply(node, n.Filter, replaceStructShowFilterFilter)
	case *ShowLegacy:
		a.apply(node, n.OnTable, replaceStructShowLegacyOnTable)
		a.apply(node, n.Table, replaceStructShowLegacyTable)
		a.apply(node, n.ShowCollationFilterOpt, replaceStructShowLegacyShowCollationFilterOpt)
	case *ShowTableStatus:
		a.apply(node, n.Filter, replaceStructShowTableStatusFilter)
	case *StarExpr:
		a.apply(node, n.TableName, replaceStructStarExprTableName)
	case *Stream:
		a.apply(node, n.Comments, replaceStructStreamComments)
		a.apply(node, n.SelectExpr, replaceStructStreamSelectExpr)
		a.apply(node, n.Table, replaceStructStreamTable)
	case *Subquery:
		a.apply(node, n.Select, replaceStructSubquerySelect)
	case *SubstrExpr:
		a.apply(node, n.Name, replaceStructSubstrExprName)
		a.apply(node, n.StrVal, replaceStructSubstrExprStrVal)
		a.apply(node, n.From, replaceStructSubstrExprFrom)
		a.apply(node, n.To, replaceStructSubstrExprTo)
	case TableExprs:
		for x, el := range n {
			a.apply(node, el, replaceSliceTableExprs(x))
		}
	case TableIdent:
	case *TableIdent:
	case TableName:
		a.apply(node, n.Name, replacePanic("TableName Name"))
		a.apply(node, n.Qualifier, replacePanic("TableName Qualifier"))
	case *TableName:
		a.apply(node, n.Name, replaceStructTableNameName)
		a.apply(node, n.Qualifier, replaceStructTableNameQualifier)
	case TableNames:
		for x, el := range n {
			a.apply(node, el, replaceSliceTableNames(x))
		}
	case TableOptions:
	case *TableSpec:
		for x, el := range n.Columns {
			a.apply(node, el, replaceTableSpecColumns(x))
		}
		for x, el := range n.Indexes {
			a.apply(node, el, replaceTableSpecIndexes(x))
		}
		for x, el := range n.Constraints {
			a.apply(node, el, replaceTableSpecConstraints(x))
		}
		a.apply(node, n.Options, replaceStructTableSpecOptions)
	case *TablespaceOperation:
	case *TimestampFuncExpr:
		a.apply(node, n.Expr1, replaceStructTimestampFuncExprExpr1)
		a.apply(node, n.Expr2, replaceStructTimestampFuncExprExpr2)
	case *TruncateTable:
		a.apply(node, n.Table, replaceStructTruncateTableTable)
	case *UnaryExpr:
		a.apply(node, n.Expr, replaceStructUnaryExprExpr)
	case *Union:
		a.apply(node, n.FirstStatement, replaceStructUnionFirstStatement)
		for x, el := range n.UnionSelects {
			a.apply(node, el, replaceUnionUnionSelects(x))
		}
		a.apply(node, n.OrderBy, replaceStructUnionOrderBy)
		a.apply(node, n.Limit, replaceStructUnionLimit)
	case *UnionSelect:
		a.apply(node, n.Statement, replaceStructUnionSelectStatement)
	case *UnlockTables:
	case *Update:
		a.apply(node, n.Comments, replaceStructUpdateComments)
		a.apply(node, n.TableExprs, replaceStructUpdateTableExprs)
		a.apply(node, n.Exprs, replaceStructUpdateExprs)
		a.apply(node, n.Where, replaceStructUpdateWhere)
		a.apply(node, n.OrderBy, replaceStructUpdateOrderBy)
		a.apply(node, n.Limit, replaceStructUpdateLimit)
	case *UpdateExpr:
		a.apply(node, n.Name, replaceStructUpdateExprName)
		a.apply(node, n.Expr, replaceStructUpdateExprExpr)
	case UpdateExprs:
		for x, el := range n {
			a.apply(node, el, replaceSliceUpdateExprs(x))
		}
	case *Use:
		a.apply(node, n.DBName, replaceStructUseDBName)
	case *VStream:
		a.apply(node, n.Comments, replaceStructVStreamComments)
		a.apply(node, n.SelectExpr, replaceStructVStreamSelectExpr)
		a.apply(node, n.Table, replaceStructVStreamTable)
		a.apply(node, n.Where, replaceStructVStreamWhere)
		a.apply(node, n.Limit, replaceStructVStreamLimit)
	case ValTuple:
		for x, el := range n {
			a.apply(node, el, replaceSliceValTuple(x))
		}
	case *Validation:
	case Values:
		for x, el := range n {
			a.apply(node, el, replaceSliceValues(x))
		}
	case *ValuesFuncExpr:
		a.apply(node, n.Name, replaceStructValuesFuncExprName)
	case VindexParam:
		a.apply(node, n.Key, replacePanic("VindexParam Key"))
	case *VindexParam:
		a.apply(node, n.Key, replaceStructVindexParamKey)
	case *VindexSpec:
		a.apply(node, n.Name, replaceStructVindexSpecName)
		a.apply(node, n.Type, replaceStructVindexSpecType)
		for x, el := range n.Params {
			a.apply(node, el, replaceVindexSpecParams(x))
		}
	case *When:
		a.apply(node, n.Cond, replaceStructWhenCond)
		a.apply(node, n.Val, replaceStructWhenVal)
	case *Where:
		a.apply(node, n.Expr, replaceStructWhereExpr)
	case *XorExpr:
		a.apply(node, n.Left, replaceStructXorExprLeft)
		a.apply(node, n.Right, replaceStructXorExprRight)
	}
	if a.post != nil && !a.post(&a.cursor) {
		panic(abort)
	}
	a.cursor = saved
}
