/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by ASTHelperGen. DO NOT EDIT.

package sqlparser

// CloneAlterOption creates a deep clone of the input.
func CloneAlterOption(in AlterOption) AlterOption {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AddColumns:
		return CloneRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return CloneRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return CloneRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AlterCharset:
		return CloneRefOfAlterCharset(in)
	case *AlterColumn:
		return CloneRefOfAlterColumn(in)
	case *ChangeColumn:
		return CloneRefOfChangeColumn(in)
	case *DropColumn:
		return CloneRefOfDropColumn(in)
	case *DropKey:
		return CloneRefOfDropKey(in)
	case *Force:
		return CloneRefOfForce(in)
	case *KeyState:
		return CloneRefOfKeyState(in)
	case *LockOption:
		return CloneRefOfLockOption(in)
	case *ModifyColumn:
		return CloneRefOfModifyColumn(in)
	case *OrderByOption:
		return CloneRefOfOrderByOption(in)
	case *RenameIndex:
		return CloneRefOfRenameIndex(in)
	case *RenameTableName:
		return CloneRefOfRenameTableName(in)
	case TableOptions:
		return CloneTableOptions(in)
	case *TablespaceOperation:
		return CloneRefOfTablespaceOperation(in)
	case *Validation:
		return CloneRefOfValidation(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsAlterOption does deep equals between the two objects.
func EqualsAlterOption(inA, inB AlterOption) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return EqualsRefOfAddColumns(a, b)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddConstraintDefinition(a, b)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddIndexDefinition(a, b)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCharset(a, b)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return EqualsRefOfAlterColumn(a, b)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return EqualsRefOfChangeColumn(a, b)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return EqualsRefOfDropColumn(a, b)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return EqualsRefOfDropKey(a, b)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return EqualsRefOfForce(a, b)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return EqualsRefOfKeyState(a, b)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return EqualsRefOfLockOption(a, b)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return EqualsRefOfModifyColumn(a, b)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return EqualsRefOfOrderByOption(a, b)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return EqualsRefOfRenameIndex(a, b)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTableName(a, b)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return EqualsTableOptions(a, b)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return EqualsRefOfTablespaceOperation(a, b)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return EqualsRefOfValidation(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneCharacteristic creates a deep clone of the input.
func CloneCharacteristic(in Characteristic) Characteristic {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case AccessMode:
		return in
	case IsolationLevel:
		return in
	default:
		// this should never happen
		return nil
	}
}

// EqualsCharacteristic does deep equals between the two objects.
func EqualsCharacteristic(inA, inB Characteristic) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case AccessMode:
		b, ok := inB.(AccessMode)
		if !ok {
			return false
		}
		return a == b
	case IsolationLevel:
		b, ok := inB.(IsolationLevel)
		if !ok {
			return false
		}
		return a == b
	default:
		// this should never happen
		return false
	}
}

// CloneColTuple creates a deep clone of the input.
func CloneColTuple(in ColTuple) ColTuple {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case ListArg:
		return CloneListArg(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case ValTuple:
		return CloneValTuple(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsColTuple does deep equals between the two objects.
func EqualsColTuple(inA, inB ColTuple) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return EqualsListArg(a, b)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneConstraintInfo creates a deep clone of the input.
func CloneConstraintInfo(in ConstraintInfo) ConstraintInfo {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *CheckConstraintDefinition:
		return CloneRefOfCheckConstraintDefinition(in)
	case *ForeignKeyDefinition:
		return CloneRefOfForeignKeyDefinition(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsConstraintInfo does deep equals between the two objects.
func EqualsConstraintInfo(inA, inB ConstraintInfo) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfCheckConstraintDefinition(a, b)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfForeignKeyDefinition(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneDBDDLStatement creates a deep clone of the input.
func CloneDBDDLStatement(in DBDDLStatement) DBDDLStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsDBDDLStatement does deep equals between the two objects.
func EqualsDBDDLStatement(inA, inB DBDDLStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneDDLStatement creates a deep clone of the input.
func CloneDDLStatement(in DDLStatement) DDLStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsDDLStatement does deep equals between the two objects.
func EqualsDDLStatement(inA, inB DDLStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneExplain creates a deep clone of the input.
func CloneExplain(in Explain) Explain {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsExplain does deep equals between the two objects.
func EqualsExplain(inA, inB Explain) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneExpr creates a deep clone of the input.
func CloneExpr(in Expr) Expr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AndExpr:
		return CloneRefOfAndExpr(in)
	case Argument:
		return in
	case *BinaryExpr:
		return CloneRefOfBinaryExpr(in)
	case BoolVal:
		return in
	case *CaseExpr:
		return CloneRefOfCaseExpr(in)
	case *ColName:
		return CloneRefOfColName(in)
	case *CollateExpr:
		return CloneRefOfCollateExpr(in)
	case *ComparisonExpr:
		return CloneRefOfComparisonExpr(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *Default:
		return CloneRefOfDefault(in)
	case *ExistsExpr:
		return CloneRefOfExistsExpr(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *IntervalExpr:
		return CloneRefOfIntervalExpr(in)
	case *IsExpr:
		return CloneRefOfIsExpr(in)
	case ListArg:
		return CloneListArg(in)
	case *Literal:
		return CloneRefOfLiteral(in)
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *NotExpr:
		return CloneRefOfNotExpr(in)
	case *NullVal:
		return CloneRefOfNullVal(in)
	case *OrExpr:
		return CloneRefOfOrExpr(in)
	case *RangeCond:
		return CloneRefOfRangeCond(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *UnaryExpr:
		return CloneRefOfUnaryExpr(in)
	case ValTuple:
		return CloneValTuple(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case *XorExpr:
		return CloneRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsExpr does deep equals between the two objects.
func EqualsExpr(inA, inB Expr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAndExpr(a, b)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBinaryExpr(a, b)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCaseExpr(a, b)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return EqualsRefOfColName(a, b)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCollateExpr(a, b)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return EqualsRefOfComparisonExpr(a, b)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertExpr(a, b)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertUsingExpr(a, b)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCurTimeFuncExpr(a, b)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return EqualsRefOfDefault(a, b)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExistsExpr(a, b)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFuncExpr(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalExpr(a, b)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIsExpr(a, b)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return EqualsListArg(a, b)
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return EqualsRefOfLiteral(a, b)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMatchExpr(a, b)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNotExpr(a, b)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return EqualsRefOfNullVal(a, b)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfOrExpr(a, b)
	case *RangeCond:
		b, ok := inB.(*RangeCond)
		if !ok {
			return false
		}
		return EqualsRefOfRangeCond(a, b)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSubstrExpr(a, b)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTimestampFuncExpr(a, b)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUnaryExpr(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfValuesFuncExpr(a, b)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return EqualsRefOfXorExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneInsertRows creates a deep clone of the input.
func CloneInsertRows(in InsertRows) InsertRows {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ParenSelect:
		return CloneRefOfParenSelect(in)
	case *Select:
		return CloneRefOfSelect(in)
	case *Union:
		return CloneRefOfUnion(in)
	case Values:
		return CloneValues(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsInsertRows does deep equals between the two objects.
func EqualsInsertRows(inA, inB InsertRows) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ParenSelect:
		b, ok := inB.(*ParenSelect)
		if !ok {
			return false
		}
		return EqualsRefOfParenSelect(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return EqualsValues(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneSQLNode creates a deep clone of the input.
func CloneSQLNode(in SQLNode) SQLNode {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case AccessMode:
		return in
	case *AddColumns:
		return CloneRefOfAddColumns(in)
	case *AddConstraintDefinition:
		return CloneRefOfAddConstraintDefinition(in)
	case *AddIndexDefinition:
		return CloneRefOfAddIndexDefinition(in)
	case AlgorithmValue:
		return in
	case *AliasedExpr:
		return CloneRefOfAliasedExpr(in)
	case *AliasedTableExpr:
		return CloneRefOfAliasedTableExpr(in)
	case *AlterCharset:
		return CloneRefOfAlterCharset(in)
	case *AlterColumn:
		return CloneRefOfAlterColumn(in)
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *AlterVschema:
		return CloneRefOfAlterVschema(in)
	case *AndExpr:
		return CloneRefOfAndExpr(in)
	case Argument:
		return in
	case *AutoIncSpec:
		return CloneRefOfAutoIncSpec(in)
	case *Begin:
		return CloneRefOfBegin(in)
	case *BinaryExpr:
		return CloneRefOfBinaryExpr(in)
	case BoolVal:
		return in
	case *CallProc:
		return CloneRefOfCallProc(in)
	case *CaseExpr:
		return CloneRefOfCaseExpr(in)
	case *ChangeColumn:
		return CloneRefOfChangeColumn(in)
	case *CheckConstraintDefinition:
		return CloneRefOfCheckConstraintDefinition(in)
	case ColIdent:
		return CloneColIdent(in)
	case *ColName:
		return CloneRefOfColName(in)
	case *CollateExpr:
		return CloneRefOfCollateExpr(in)
	case *ColumnDefinition:
		return CloneRefOfColumnDefinition(in)
	case *ColumnType:
		return CloneRefOfColumnType(in)
	case Columns:
		return CloneColumns(in)
	case Comments:
		return CloneComments(in)
	case *Commit:
		return CloneRefOfCommit(in)
	case *ComparisonExpr:
		return CloneRefOfComparisonExpr(in)
	case *ConstraintDefinition:
		return CloneRefOfConstraintDefinition(in)
	case *ConvertExpr:
		return CloneRefOfConvertExpr(in)
	case *ConvertType:
		return CloneRefOfConvertType(in)
	case *ConvertUsingExpr:
		return CloneRefOfConvertUsingExpr(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *CurTimeFuncExpr:
		return CloneRefOfCurTimeFuncExpr(in)
	case *Default:
		return CloneRefOfDefault(in)
	case *Delete:
		return CloneRefOfDelete(in)
	case *DerivedTable:
		return CloneRefOfDerivedTable(in)
	case *DropColumn:
		return CloneRefOfDropColumn(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	case *DropKey:
		return CloneRefOfDropKey(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *ExistsExpr:
		return CloneRefOfExistsExpr(in)
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	case Exprs:
		return CloneExprs(in)
	case *Flush:
		return CloneRefOfFlush(in)
	case *Force:
		return CloneRefOfForce(in)
	case *ForeignKeyDefinition:
		return CloneRefOfForeignKeyDefinition(in)
	case *FuncExpr:
		return CloneRefOfFuncExpr(in)
	case GroupBy:
		return CloneGroupBy(in)
	case *GroupConcatExpr:
		return CloneRefOfGroupConcatExpr(in)
	case *IndexDefinition:
		return CloneRefOfIndexDefinition(in)
	case *IndexHints:
		return CloneRefOfIndexHints(in)
	case *IndexInfo:
		return CloneRefOfIndexInfo(in)
	case *Insert:
		return CloneRefOfInsert(in)
	case *IntervalExpr:
		return CloneRefOfIntervalExpr(in)
	case *IsExpr:
		return CloneRefOfIsExpr(in)
	case IsolationLevel:
		return in
	case JoinCondition:
		return CloneJoinCondition(in)
	case *JoinTableExpr:
		return CloneRefOfJoinTableExpr(in)
	case *KeyState:
		return CloneRefOfKeyState(in)
	case *Limit:
		return CloneRefOfLimit(in)
	case ListArg:
		return CloneListArg(in)
	case *Literal:
		return CloneRefOfLiteral(in)
	case *Load:
		return CloneRefOfLoad(in)
	case *LockOption:
		return CloneRefOfLockOption(in)
	case *LockTables:
		return CloneRefOfLockTables(in)
	case *MatchExpr:
		return CloneRefOfMatchExpr(in)
	case *ModifyColumn:
		return CloneRefOfModifyColumn(in)
	case *Nextval:
		return CloneRefOfNextval(in)
	case *NotExpr:
		return CloneRefOfNotExpr(in)
	case *NullVal:
		return CloneRefOfNullVal(in)
	case OnDup:
		return CloneOnDup(in)
	case *OptLike:
		return CloneRefOfOptLike(in)
	case *OrExpr:
		return CloneRefOfOrExpr(in)
	case *Order:
		return CloneRefOfOrder(in)
	case OrderBy:
		return CloneOrderBy(in)
	case *OrderByOption:
		return CloneRefOfOrderByOption(in)
	case *OtherAdmin:
		return CloneRefOfOtherAdmin(in)
	case *OtherRead:
		return CloneRefOfOtherRead(in)
	case *ParenSelect:
		return CloneRefOfParenSelect(in)
	case *ParenTableExpr:
		return CloneRefOfParenTableExpr(in)
	case *PartitionDefinition:
		return CloneRefOfPartitionDefinition(in)
	case *PartitionSpec:
		return CloneRefOfPartitionSpec(in)
	case Partitions:
		return ClonePartitions(in)
	case *RangeCond:
		return CloneRefOfRangeCond(in)
	case ReferenceAction:
		return in
	case *Release:
		return CloneRefOfRelease(in)
	case *RenameIndex:
		return CloneRefOfRenameIndex(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *RenameTableName:
		return CloneRefOfRenameTableName(in)
	case *RevertMigration:
		return CloneRefOfRevertMigration(in)
	case *Rollback:
		return CloneRefOfRollback(in)
	case *SRollback:
		return CloneRefOfSRollback(in)
	case *Savepoint:
		return CloneRefOfSavepoint(in)
	case *Select:
		return CloneRefOfSelect(in)
	case SelectExprs:
		return CloneSelectExprs(in)
	case *SelectInto:
		return CloneRefOfSelectInto(in)
	case *Set:
		return CloneRefOfSet(in)
	case *SetExpr:
		return CloneRefOfSetExpr(in)
	case SetExprs:
		return CloneSetExprs(in)
	case *SetTransaction:
		return CloneRefOfSetTransaction(in)
	case *Show:
		return CloneRefOfShow(in)
	case *ShowBasic:
		return CloneRefOfShowBasic(in)
	case *ShowCreate:
		return CloneRefOfShowCreate(in)
	case *ShowFilter:
		return CloneRefOfShowFilter(in)
	case *ShowLegacy:
		return CloneRefOfShowLegacy(in)
	case *StarExpr:
		return CloneRefOfStarExpr(in)
	case *Stream:
		return CloneRefOfStream(in)
	case *Subquery:
		return CloneRefOfSubquery(in)
	case *SubstrExpr:
		return CloneRefOfSubstrExpr(in)
	case TableExprs:
		return CloneTableExprs(in)
	case TableIdent:
		return CloneTableIdent(in)
	case TableName:
		return CloneTableName(in)
	case TableNames:
		return CloneTableNames(in)
	case TableOptions:
		return CloneTableOptions(in)
	case *TableSpec:
		return CloneRefOfTableSpec(in)
	case *TablespaceOperation:
		return CloneRefOfTablespaceOperation(in)
	case *TimestampFuncExpr:
		return CloneRefOfTimestampFuncExpr(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	case *UnaryExpr:
		return CloneRefOfUnaryExpr(in)
	case *Union:
		return CloneRefOfUnion(in)
	case *UnionSelect:
		return CloneRefOfUnionSelect(in)
	case *UnlockTables:
		return CloneRefOfUnlockTables(in)
	case *Update:
		return CloneRefOfUpdate(in)
	case *UpdateExpr:
		return CloneRefOfUpdateExpr(in)
	case UpdateExprs:
		return CloneUpdateExprs(in)
	case *Use:
		return CloneRefOfUse(in)
	case *VStream:
		return CloneRefOfVStream(in)
	case ValTuple:
		return CloneValTuple(in)
	case *Validation:
		return CloneRefOfValidation(in)
	case Values:
		return CloneValues(in)
	case *ValuesFuncExpr:
		return CloneRefOfValuesFuncExpr(in)
	case VindexParam:
		return CloneVindexParam(in)
	case *VindexSpec:
		return CloneRefOfVindexSpec(in)
	case *When:
		return CloneRefOfWhen(in)
	case *Where:
		return CloneRefOfWhere(in)
	case *XorExpr:
		return CloneRefOfXorExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsSQLNode does deep equals between the two objects.
func EqualsSQLNode(inA, inB SQLNode) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case AccessMode:
		b, ok := inB.(AccessMode)
		if !ok {
			return false
		}
		return a == b
	case *AddColumns:
		b, ok := inB.(*AddColumns)
		if !ok {
			return false
		}
		return EqualsRefOfAddColumns(a, b)
	case *AddConstraintDefinition:
		b, ok := inB.(*AddConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddConstraintDefinition(a, b)
	case *AddIndexDefinition:
		b, ok := inB.(*AddIndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfAddIndexDefinition(a, b)
	case AlgorithmValue:
		b, ok := inB.(AlgorithmValue)
		if !ok {
			return false
		}
		return a == b
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedExpr(a, b)
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedTableExpr(a, b)
	case *AlterCharset:
		b, ok := inB.(*AlterCharset)
		if !ok {
			return false
		}
		return EqualsRefOfAlterCharset(a, b)
	case *AlterColumn:
		b, ok := inB.(*AlterColumn)
		if !ok {
			return false
		}
		return EqualsRefOfAlterColumn(a, b)
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return EqualsRefOfAlterVschema(a, b)
	case *AndExpr:
		b, ok := inB.(*AndExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAndExpr(a, b)
	case Argument:
		b, ok := inB.(Argument)
		if !ok {
			return false
		}
		return a == b
	case *AutoIncSpec:
		b, ok := inB.(*AutoIncSpec)
		if !ok {
			return false
		}
		return EqualsRefOfAutoIncSpec(a, b)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return EqualsRefOfBegin(a, b)
	case *BinaryExpr:
		b, ok := inB.(*BinaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfBinaryExpr(a, b)
	case BoolVal:
		b, ok := inB.(BoolVal)
		if !ok {
			return false
		}
		return a == b
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return EqualsRefOfCallProc(a, b)
	case *CaseExpr:
		b, ok := inB.(*CaseExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCaseExpr(a, b)
	case *ChangeColumn:
		b, ok := inB.(*ChangeColumn)
		if !ok {
			return false
		}
		return EqualsRefOfChangeColumn(a, b)
	case *CheckConstraintDefinition:
		b, ok := inB.(*CheckConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfCheckConstraintDefinition(a, b)
	case ColIdent:
		b, ok := inB.(ColIdent)
		if !ok {
			return false
		}
		return EqualsColIdent(a, b)
	case *ColName:
		b, ok := inB.(*ColName)
		if !ok {
			return false
		}
		return EqualsRefOfColName(a, b)
	case *CollateExpr:
		b, ok := inB.(*CollateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCollateExpr(a, b)
	case *ColumnDefinition:
		b, ok := inB.(*ColumnDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfColumnDefinition(a, b)
	case *ColumnType:
		b, ok := inB.(*ColumnType)
		if !ok {
			return false
		}
		return EqualsRefOfColumnType(a, b)
	case Columns:
		b, ok := inB.(Columns)
		if !ok {
			return false
		}
		return EqualsColumns(a, b)
	case Comments:
		b, ok := inB.(Comments)
		if !ok {
			return false
		}
		return EqualsComments(a, b)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return EqualsRefOfCommit(a, b)
	case *ComparisonExpr:
		b, ok := inB.(*ComparisonExpr)
		if !ok {
			return false
		}
		return EqualsRefOfComparisonExpr(a, b)
	case *ConstraintDefinition:
		b, ok := inB.(*ConstraintDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfConstraintDefinition(a, b)
	case *ConvertExpr:
		b, ok := inB.(*ConvertExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertExpr(a, b)
	case *ConvertType:
		b, ok := inB.(*ConvertType)
		if !ok {
			return false
		}
		return EqualsRefOfConvertType(a, b)
	case *ConvertUsingExpr:
		b, ok := inB.(*ConvertUsingExpr)
		if !ok {
			return false
		}
		return EqualsRefOfConvertUsingExpr(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b)
	case *CurTimeFuncExpr:
		b, ok := inB.(*CurTimeFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfCurTimeFuncExpr(a, b)
	case *Default:
		b, ok := inB.(*Default)
		if !ok {
			return false
		}
		return EqualsRefOfDefault(a, b)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return EqualsRefOfDelete(a, b)
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return EqualsRefOfDerivedTable(a, b)
	case *DropColumn:
		b, ok := inB.(*DropColumn)
		if !ok {
			return false
		}
		return EqualsRefOfDropColumn(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b)
	case *DropKey:
		b, ok := inB.(*DropKey)
		if !ok {
			return false
		}
		return EqualsRefOfDropKey(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b)
	case *ExistsExpr:
		b, ok := inB.(*ExistsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfExistsExpr(a, b)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b)
	case Exprs:
		b, ok := inB.(Exprs)
		if !ok {
			return false
		}
		return EqualsExprs(a, b)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return EqualsRefOfFlush(a, b)
	case *Force:
		b, ok := inB.(*Force)
		if !ok {
			return false
		}
		return EqualsRefOfForce(a, b)
	case *ForeignKeyDefinition:
		b, ok := inB.(*ForeignKeyDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfForeignKeyDefinition(a, b)
	case *FuncExpr:
		b, ok := inB.(*FuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfFuncExpr(a, b)
	case GroupBy:
		b, ok := inB.(GroupBy)
		if !ok {
			return false
		}
		return EqualsGroupBy(a, b)
	case *GroupConcatExpr:
		b, ok := inB.(*GroupConcatExpr)
		if !ok {
			return false
		}
		return EqualsRefOfGroupConcatExpr(a, b)
	case *IndexDefinition:
		b, ok := inB.(*IndexDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfIndexDefinition(a, b)
	case *IndexHints:
		b, ok := inB.(*IndexHints)
		if !ok {
			return false
		}
		return EqualsRefOfIndexHints(a, b)
	case *IndexInfo:
		b, ok := inB.(*IndexInfo)
		if !ok {
			return false
		}
		return EqualsRefOfIndexInfo(a, b)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return EqualsRefOfInsert(a, b)
	case *IntervalExpr:
		b, ok := inB.(*IntervalExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIntervalExpr(a, b)
	case *IsExpr:
		b, ok := inB.(*IsExpr)
		if !ok {
			return false
		}
		return EqualsRefOfIsExpr(a, b)
	case IsolationLevel:
		b, ok := inB.(IsolationLevel)
		if !ok {
			return false
		}
		return a == b
	case JoinCondition:
		b, ok := inB.(JoinCondition)
		if !ok {
			return false
		}
		return EqualsJoinCondition(a, b)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJoinTableExpr(a, b)
	case *KeyState:
		b, ok := inB.(*KeyState)
		if !ok {
			return false
		}
		return EqualsRefOfKeyState(a, b)
	case *Limit:
		b, ok := inB.(*Limit)
		if !ok {
			return false
		}
		return EqualsRefOfLimit(a, b)
	case ListArg:
		b, ok := inB.(ListArg)
		if !ok {
			return false
		}
		return EqualsListArg(a, b)
	case *Literal:
		b, ok := inB.(*Literal)
		if !ok {
			return false
		}
		return EqualsRefOfLiteral(a, b)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return EqualsRefOfLoad(a, b)
	case *LockOption:
		b, ok := inB.(*LockOption)
		if !ok {
			return false
		}
		return EqualsRefOfLockOption(a, b)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return EqualsRefOfLockTables(a, b)
	case *MatchExpr:
		b, ok := inB.(*MatchExpr)
		if !ok {
			return false
		}
		return EqualsRefOfMatchExpr(a, b)
	case *ModifyColumn:
		b, ok := inB.(*ModifyColumn)
		if !ok {
			return false
		}
		return EqualsRefOfModifyColumn(a, b)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return EqualsRefOfNextval(a, b)
	case *NotExpr:
		b, ok := inB.(*NotExpr)
		if !ok {
			return false
		}
		return EqualsRefOfNotExpr(a, b)
	case *NullVal:
		b, ok := inB.(*NullVal)
		if !ok {
			return false
		}
		return EqualsRefOfNullVal(a, b)
	case OnDup:
		b, ok := inB.(OnDup)
		if !ok {
			return false
		}
		return EqualsOnDup(a, b)
	case *OptLike:
		b, ok := inB.(*OptLike)
		if !ok {
			return false
		}
		return EqualsRefOfOptLike(a, b)
	case *OrExpr:
		b, ok := inB.(*OrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfOrExpr(a, b)
	case *Order:
		b, ok := inB.(*Order)
		if !ok {
			return false
		}
		return EqualsRefOfOrder(a, b)
	case OrderBy:
		b, ok := inB.(OrderBy)
		if !ok {
			return false
		}
		return EqualsOrderBy(a, b)
	case *OrderByOption:
		b, ok := inB.(*OrderByOption)
		if !ok {
			return false
		}
		return EqualsRefOfOrderByOption(a, b)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return EqualsRefOfOtherAdmin(a, b)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return EqualsRefOfOtherRead(a, b)
	case *ParenSelect:
		b, ok := inB.(*ParenSelect)
		if !ok {
			return false
		}
		return EqualsRefOfParenSelect(a, b)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfParenTableExpr(a, b)
	case *PartitionDefinition:
		b, ok := inB.(*PartitionDefinition)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionDefinition(a, b)
	case *PartitionSpec:
		b, ok := inB.(*PartitionSpec)
		if !ok {
			return false
		}
		return EqualsRefOfPartitionSpec(a, b)
	case Partitions:
		b, ok := inB.(Partitions)
		if !ok {
			return false
		}
		return EqualsPartitions(a, b)
	case *RangeCond:
		b, ok := inB.(*RangeCond)
		if !ok {
			return false
		}
		return EqualsRefOfRangeCond(a, b)
	case ReferenceAction:
		b, ok := inB.(ReferenceAction)
		if !ok {
			return false
		}
		return a == b
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return EqualsRefOfRelease(a, b)
	case *RenameIndex:
		b, ok := inB.(*RenameIndex)
		if !ok {
			return false
		}
		return EqualsRefOfRenameIndex(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b)
	case *RenameTableName:
		b, ok := inB.(*RenameTableName)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTableName(a, b)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return EqualsRefOfRevertMigration(a, b)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return EqualsRefOfRollback(a, b)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return EqualsRefOfSRollback(a, b)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return EqualsRefOfSavepoint(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b)
	case SelectExprs:
		b, ok := inB.(SelectExprs)
		if !ok {
			return false
		}
		return EqualsSelectExprs(a, b)
	case *SelectInto:
		b, ok := inB.(*SelectInto)
		if !ok {
			return false
		}
		return EqualsRefOfSelectInto(a, b)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return EqualsRefOfSet(a, b)
	case *SetExpr:
		b, ok := inB.(*SetExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSetExpr(a, b)
	case SetExprs:
		b, ok := inB.(SetExprs)
		if !ok {
			return false
		}
		return EqualsSetExprs(a, b)
	case *SetTransaction:
		b, ok := inB.(*SetTransaction)
		if !ok {
			return false
		}
		return EqualsRefOfSetTransaction(a, b)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return EqualsRefOfShow(a, b)
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return EqualsRefOfShowBasic(a, b)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return EqualsRefOfShowCreate(a, b)
	case *ShowFilter:
		b, ok := inB.(*ShowFilter)
		if !ok {
			return false
		}
		return EqualsRefOfShowFilter(a, b)
	case *ShowLegacy:
		b, ok := inB.(*ShowLegacy)
		if !ok {
			return false
		}
		return EqualsRefOfShowLegacy(a, b)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return EqualsRefOfStarExpr(a, b)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return EqualsRefOfStream(a, b)
	case *Subquery:
		b, ok := inB.(*Subquery)
		if !ok {
			return false
		}
		return EqualsRefOfSubquery(a, b)
	case *SubstrExpr:
		b, ok := inB.(*SubstrExpr)
		if !ok {
			return false
		}
		return EqualsRefOfSubstrExpr(a, b)
	case TableExprs:
		b, ok := inB.(TableExprs)
		if !ok {
			return false
		}
		return EqualsTableExprs(a, b)
	case TableIdent:
		b, ok := inB.(TableIdent)
		if !ok {
			return false
		}
		return EqualsTableIdent(a, b)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return EqualsTableName(a, b)
	case TableNames:
		b, ok := inB.(TableNames)
		if !ok {
			return false
		}
		return EqualsTableNames(a, b)
	case TableOptions:
		b, ok := inB.(TableOptions)
		if !ok {
			return false
		}
		return EqualsTableOptions(a, b)
	case *TableSpec:
		b, ok := inB.(*TableSpec)
		if !ok {
			return false
		}
		return EqualsRefOfTableSpec(a, b)
	case *TablespaceOperation:
		b, ok := inB.(*TablespaceOperation)
		if !ok {
			return false
		}
		return EqualsRefOfTablespaceOperation(a, b)
	case *TimestampFuncExpr:
		b, ok := inB.(*TimestampFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfTimestampFuncExpr(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b)
	case *UnaryExpr:
		b, ok := inB.(*UnaryExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUnaryExpr(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b)
	case *UnionSelect:
		b, ok := inB.(*UnionSelect)
		if !ok {
			return false
		}
		return EqualsRefOfUnionSelect(a, b)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return EqualsRefOfUnlockTables(a, b)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return EqualsRefOfUpdate(a, b)
	case *UpdateExpr:
		b, ok := inB.(*UpdateExpr)
		if !ok {
			return false
		}
		return EqualsRefOfUpdateExpr(a, b)
	case UpdateExprs:
		b, ok := inB.(UpdateExprs)
		if !ok {
			return false
		}
		return EqualsUpdateExprs(a, b)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return EqualsRefOfUse(a, b)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return EqualsRefOfVStream(a, b)
	case ValTuple:
		b, ok := inB.(ValTuple)
		if !ok {
			return false
		}
		return EqualsValTuple(a, b)
	case *Validation:
		b, ok := inB.(*Validation)
		if !ok {
			return false
		}
		return EqualsRefOfValidation(a, b)
	case Values:
		b, ok := inB.(Values)
		if !ok {
			return false
		}
		return EqualsValues(a, b)
	case *ValuesFuncExpr:
		b, ok := inB.(*ValuesFuncExpr)
		if !ok {
			return false
		}
		return EqualsRefOfValuesFuncExpr(a, b)
	case VindexParam:
		b, ok := inB.(VindexParam)
		if !ok {
			return false
		}
		return EqualsVindexParam(a, b)
	case *VindexSpec:
		b, ok := inB.(*VindexSpec)
		if !ok {
			return false
		}
		return EqualsRefOfVindexSpec(a, b)
	case *When:
		b, ok := inB.(*When)
		if !ok {
			return false
		}
		return EqualsRefOfWhen(a, b)
	case *Where:
		b, ok := inB.(*Where)
		if !ok {
			return false
		}
		return EqualsRefOfWhere(a, b)
	case *XorExpr:
		b, ok := inB.(*XorExpr)
		if !ok {
			return false
		}
		return EqualsRefOfXorExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneSelectExpr creates a deep clone of the input.
func CloneSelectExpr(in SelectExpr) SelectExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AliasedExpr:
		return CloneRefOfAliasedExpr(in)
	case *Nextval:
		return CloneRefOfNextval(in)
	case *StarExpr:
		return CloneRefOfStarExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsSelectExpr does deep equals between the two objects.
func EqualsSelectExpr(inA, inB SelectExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedExpr:
		b, ok := inB.(*AliasedExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedExpr(a, b)
	case *Nextval:
		b, ok := inB.(*Nextval)
		if !ok {
			return false
		}
		return EqualsRefOfNextval(a, b)
	case *StarExpr:
		b, ok := inB.(*StarExpr)
		if !ok {
			return false
		}
		return EqualsRefOfStarExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneSelectStatement creates a deep clone of the input.
func CloneSelectStatement(in SelectStatement) SelectStatement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ParenSelect:
		return CloneRefOfParenSelect(in)
	case *Select:
		return CloneRefOfSelect(in)
	case *Union:
		return CloneRefOfUnion(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsSelectStatement does deep equals between the two objects.
func EqualsSelectStatement(inA, inB SelectStatement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ParenSelect:
		b, ok := inB.(*ParenSelect)
		if !ok {
			return false
		}
		return EqualsRefOfParenSelect(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneShowInternal creates a deep clone of the input.
func CloneShowInternal(in ShowInternal) ShowInternal {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *ShowBasic:
		return CloneRefOfShowBasic(in)
	case *ShowCreate:
		return CloneRefOfShowCreate(in)
	case *ShowLegacy:
		return CloneRefOfShowLegacy(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsShowInternal does deep equals between the two objects.
func EqualsShowInternal(inA, inB ShowInternal) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *ShowBasic:
		b, ok := inB.(*ShowBasic)
		if !ok {
			return false
		}
		return EqualsRefOfShowBasic(a, b)
	case *ShowCreate:
		b, ok := inB.(*ShowCreate)
		if !ok {
			return false
		}
		return EqualsRefOfShowCreate(a, b)
	case *ShowLegacy:
		b, ok := inB.(*ShowLegacy)
		if !ok {
			return false
		}
		return EqualsRefOfShowLegacy(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneSimpleTableExpr creates a deep clone of the input.
func CloneSimpleTableExpr(in SimpleTableExpr) SimpleTableExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *DerivedTable:
		return CloneRefOfDerivedTable(in)
	case TableName:
		return CloneTableName(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsSimpleTableExpr does deep equals between the two objects.
func EqualsSimpleTableExpr(inA, inB SimpleTableExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *DerivedTable:
		b, ok := inB.(*DerivedTable)
		if !ok {
			return false
		}
		return EqualsRefOfDerivedTable(a, b)
	case TableName:
		b, ok := inB.(TableName)
		if !ok {
			return false
		}
		return EqualsTableName(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneStatement creates a deep clone of the input.
func CloneStatement(in Statement) Statement {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AlterDatabase:
		return CloneRefOfAlterDatabase(in)
	case *AlterTable:
		return CloneRefOfAlterTable(in)
	case *AlterView:
		return CloneRefOfAlterView(in)
	case *AlterVschema:
		return CloneRefOfAlterVschema(in)
	case *Begin:
		return CloneRefOfBegin(in)
	case *CallProc:
		return CloneRefOfCallProc(in)
	case *Commit:
		return CloneRefOfCommit(in)
	case *CreateDatabase:
		return CloneRefOfCreateDatabase(in)
	case *CreateTable:
		return CloneRefOfCreateTable(in)
	case *CreateView:
		return CloneRefOfCreateView(in)
	case *Delete:
		return CloneRefOfDelete(in)
	case *DropDatabase:
		return CloneRefOfDropDatabase(in)
	case *DropTable:
		return CloneRefOfDropTable(in)
	case *DropView:
		return CloneRefOfDropView(in)
	case *ExplainStmt:
		return CloneRefOfExplainStmt(in)
	case *ExplainTab:
		return CloneRefOfExplainTab(in)
	case *Flush:
		return CloneRefOfFlush(in)
	case *Insert:
		return CloneRefOfInsert(in)
	case *Load:
		return CloneRefOfLoad(in)
	case *LockTables:
		return CloneRefOfLockTables(in)
	case *OtherAdmin:
		return CloneRefOfOtherAdmin(in)
	case *OtherRead:
		return CloneRefOfOtherRead(in)
	case *ParenSelect:
		return CloneRefOfParenSelect(in)
	case *Release:
		return CloneRefOfRelease(in)
	case *RenameTable:
		return CloneRefOfRenameTable(in)
	case *RevertMigration:
		return CloneRefOfRevertMigration(in)
	case *Rollback:
		return CloneRefOfRollback(in)
	case *SRollback:
		return CloneRefOfSRollback(in)
	case *Savepoint:
		return CloneRefOfSavepoint(in)
	case *Select:
		return CloneRefOfSelect(in)
	case *Set:
		return CloneRefOfSet(in)
	case *SetTransaction:
		return CloneRefOfSetTransaction(in)
	case *Show:
		return CloneRefOfShow(in)
	case *Stream:
		return CloneRefOfStream(in)
	case *TruncateTable:
		return CloneRefOfTruncateTable(in)
	case *Union:
		return CloneRefOfUnion(in)
	case *UnlockTables:
		return CloneRefOfUnlockTables(in)
	case *Update:
		return CloneRefOfUpdate(in)
	case *Use:
		return CloneRefOfUse(in)
	case *VStream:
		return CloneRefOfVStream(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsStatement does deep equals between the two objects.
func EqualsStatement(inA, inB Statement) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AlterDatabase:
		b, ok := inB.(*AlterDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfAlterDatabase(a, b)
	case *AlterTable:
		b, ok := inB.(*AlterTable)
		if !ok {
			return false
		}
		return EqualsRefOfAlterTable(a, b)
	case *AlterView:
		b, ok := inB.(*AlterView)
		if !ok {
			return false
		}
		return EqualsRefOfAlterView(a, b)
	case *AlterVschema:
		b, ok := inB.(*AlterVschema)
		if !ok {
			return false
		}
		return EqualsRefOfAlterVschema(a, b)
	case *Begin:
		b, ok := inB.(*Begin)
		if !ok {
			return false
		}
		return EqualsRefOfBegin(a, b)
	case *CallProc:
		b, ok := inB.(*CallProc)
		if !ok {
			return false
		}
		return EqualsRefOfCallProc(a, b)
	case *Commit:
		b, ok := inB.(*Commit)
		if !ok {
			return false
		}
		return EqualsRefOfCommit(a, b)
	case *CreateDatabase:
		b, ok := inB.(*CreateDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfCreateDatabase(a, b)
	case *CreateTable:
		b, ok := inB.(*CreateTable)
		if !ok {
			return false
		}
		return EqualsRefOfCreateTable(a, b)
	case *CreateView:
		b, ok := inB.(*CreateView)
		if !ok {
			return false
		}
		return EqualsRefOfCreateView(a, b)
	case *Delete:
		b, ok := inB.(*Delete)
		if !ok {
			return false
		}
		return EqualsRefOfDelete(a, b)
	case *DropDatabase:
		b, ok := inB.(*DropDatabase)
		if !ok {
			return false
		}
		return EqualsRefOfDropDatabase(a, b)
	case *DropTable:
		b, ok := inB.(*DropTable)
		if !ok {
			return false
		}
		return EqualsRefOfDropTable(a, b)
	case *DropView:
		b, ok := inB.(*DropView)
		if !ok {
			return false
		}
		return EqualsRefOfDropView(a, b)
	case *ExplainStmt:
		b, ok := inB.(*ExplainStmt)
		if !ok {
			return false
		}
		return EqualsRefOfExplainStmt(a, b)
	case *ExplainTab:
		b, ok := inB.(*ExplainTab)
		if !ok {
			return false
		}
		return EqualsRefOfExplainTab(a, b)
	case *Flush:
		b, ok := inB.(*Flush)
		if !ok {
			return false
		}
		return EqualsRefOfFlush(a, b)
	case *Insert:
		b, ok := inB.(*Insert)
		if !ok {
			return false
		}
		return EqualsRefOfInsert(a, b)
	case *Load:
		b, ok := inB.(*Load)
		if !ok {
			return false
		}
		return EqualsRefOfLoad(a, b)
	case *LockTables:
		b, ok := inB.(*LockTables)
		if !ok {
			return false
		}
		return EqualsRefOfLockTables(a, b)
	case *OtherAdmin:
		b, ok := inB.(*OtherAdmin)
		if !ok {
			return false
		}
		return EqualsRefOfOtherAdmin(a, b)
	case *OtherRead:
		b, ok := inB.(*OtherRead)
		if !ok {
			return false
		}
		return EqualsRefOfOtherRead(a, b)
	case *ParenSelect:
		b, ok := inB.(*ParenSelect)
		if !ok {
			return false
		}
		return EqualsRefOfParenSelect(a, b)
	case *Release:
		b, ok := inB.(*Release)
		if !ok {
			return false
		}
		return EqualsRefOfRelease(a, b)
	case *RenameTable:
		b, ok := inB.(*RenameTable)
		if !ok {
			return false
		}
		return EqualsRefOfRenameTable(a, b)
	case *RevertMigration:
		b, ok := inB.(*RevertMigration)
		if !ok {
			return false
		}
		return EqualsRefOfRevertMigration(a, b)
	case *Rollback:
		b, ok := inB.(*Rollback)
		if !ok {
			return false
		}
		return EqualsRefOfRollback(a, b)
	case *SRollback:
		b, ok := inB.(*SRollback)
		if !ok {
			return false
		}
		return EqualsRefOfSRollback(a, b)
	case *Savepoint:
		b, ok := inB.(*Savepoint)
		if !ok {
			return false
		}
		return EqualsRefOfSavepoint(a, b)
	case *Select:
		b, ok := inB.(*Select)
		if !ok {
			return false
		}
		return EqualsRefOfSelect(a, b)
	case *Set:
		b, ok := inB.(*Set)
		if !ok {
			return false
		}
		return EqualsRefOfSet(a, b)
	case *SetTransaction:
		b, ok := inB.(*SetTransaction)
		if !ok {
			return false
		}
		return EqualsRefOfSetTransaction(a, b)
	case *Show:
		b, ok := inB.(*Show)
		if !ok {
			return false
		}
		return EqualsRefOfShow(a, b)
	case *Stream:
		b, ok := inB.(*Stream)
		if !ok {
			return false
		}
		return EqualsRefOfStream(a, b)
	case *TruncateTable:
		b, ok := inB.(*TruncateTable)
		if !ok {
			return false
		}
		return EqualsRefOfTruncateTable(a, b)
	case *Union:
		b, ok := inB.(*Union)
		if !ok {
			return false
		}
		return EqualsRefOfUnion(a, b)
	case *UnlockTables:
		b, ok := inB.(*UnlockTables)
		if !ok {
			return false
		}
		return EqualsRefOfUnlockTables(a, b)
	case *Update:
		b, ok := inB.(*Update)
		if !ok {
			return false
		}
		return EqualsRefOfUpdate(a, b)
	case *Use:
		b, ok := inB.(*Use)
		if !ok {
			return false
		}
		return EqualsRefOfUse(a, b)
	case *VStream:
		b, ok := inB.(*VStream)
		if !ok {
			return false
		}
		return EqualsRefOfVStream(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneTableExpr creates a deep clone of the input.
func CloneTableExpr(in TableExpr) TableExpr {
	if in == nil {
		return nil
	}
	switch in := in.(type) {
	case *AliasedTableExpr:
		return CloneRefOfAliasedTableExpr(in)
	case *JoinTableExpr:
		return CloneRefOfJoinTableExpr(in)
	case *ParenTableExpr:
		return CloneRefOfParenTableExpr(in)
	default:
		// this should never happen
		return nil
	}
}

// EqualsTableExpr does deep equals between the two objects.
func EqualsTableExpr(inA, inB TableExpr) bool {
	if inA == nil && inB == nil {
		return true
	}
	if inA == nil || inB == nil {
		return false
	}
	switch a := inA.(type) {
	case *AliasedTableExpr:
		b, ok := inB.(*AliasedTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfAliasedTableExpr(a, b)
	case *JoinTableExpr:
		b, ok := inB.(*JoinTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfJoinTableExpr(a, b)
	case *ParenTableExpr:
		b, ok := inB.(*ParenTableExpr)
		if !ok {
			return false
		}
		return EqualsRefOfParenTableExpr(a, b)
	default:
		// this should never happen
		return false
	}
}

// CloneRefOfAddColumns creates a deep clone of the input.
func CloneRefOfAddColumns(n *AddColumns) *AddColumns {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSliceOfRefOfColumnDefinition(n.Columns)
	out.First = CloneRefOfColName(n.First)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// EqualsRefOfAddColumns does deep equals between the two objects.
func EqualsRefOfAddColumns(a, b *AddColumns) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfColumnDefinition(a.Columns, b.Columns) &&
		EqualsRefOfColName(a.First, b.First) &&
		EqualsRefOfColName(a.After, b.After)
}

// CloneRefOfAddConstraintDefinition creates a deep clone of the input.
func CloneRefOfAddConstraintDefinition(n *AddConstraintDefinition) *AddConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.ConstraintDefinition = CloneRefOfConstraintDefinition(n.ConstraintDefinition)
	return &out
}

// EqualsRefOfAddConstraintDefinition does deep equals between the two objects.
func EqualsRefOfAddConstraintDefinition(a, b *AddConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfConstraintDefinition(a.ConstraintDefinition, b.ConstraintDefinition)
}

// CloneRefOfAddIndexDefinition creates a deep clone of the input.
func CloneRefOfAddIndexDefinition(n *AddIndexDefinition) *AddIndexDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.IndexDefinition = CloneRefOfIndexDefinition(n.IndexDefinition)
	return &out
}

// EqualsRefOfAddIndexDefinition does deep equals between the two objects.
func EqualsRefOfAddIndexDefinition(a, b *AddIndexDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfIndexDefinition(a.IndexDefinition, b.IndexDefinition)
}

// CloneRefOfAlterCharset creates a deep clone of the input.
func CloneRefOfAlterCharset(n *AlterCharset) *AlterCharset {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfAlterCharset does deep equals between the two objects.
func EqualsRefOfAlterCharset(a, b *AlterCharset) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.CharacterSet == b.CharacterSet &&
		a.Collate == b.Collate
}

// CloneRefOfAlterColumn creates a deep clone of the input.
func CloneRefOfAlterColumn(n *AlterColumn) *AlterColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneRefOfColName(n.Column)
	out.DefaultVal = CloneExpr(n.DefaultVal)
	return &out
}

// EqualsRefOfAlterColumn does deep equals between the two objects.
func EqualsRefOfAlterColumn(a, b *AlterColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DropDefault == b.DropDefault &&
		EqualsRefOfColName(a.Column, b.Column) &&
		EqualsExpr(a.DefaultVal, b.DefaultVal)
}

// CloneRefOfChangeColumn creates a deep clone of the input.
func CloneRefOfChangeColumn(n *ChangeColumn) *ChangeColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.OldColumn = CloneRefOfColName(n.OldColumn)
	out.NewColDefinition = CloneRefOfColumnDefinition(n.NewColDefinition)
	out.First = CloneRefOfColName(n.First)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// EqualsRefOfChangeColumn does deep equals between the two objects.
func EqualsRefOfChangeColumn(a, b *ChangeColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.OldColumn, b.OldColumn) &&
		EqualsRefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition) &&
		EqualsRefOfColName(a.First, b.First) &&
		EqualsRefOfColName(a.After, b.After)
}

// CloneRefOfDropColumn creates a deep clone of the input.
func CloneRefOfDropColumn(n *DropColumn) *DropColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	return &out
}

// EqualsRefOfDropColumn does deep equals between the two objects.
func EqualsRefOfDropColumn(a, b *DropColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name)
}

// CloneRefOfDropKey creates a deep clone of the input.
func CloneRefOfDropKey(n *DropKey) *DropKey {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfDropKey does deep equals between the two objects.
func EqualsRefOfDropKey(a, b *DropKey) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Type == b.Type
}

// CloneRefOfForce creates a deep clone of the input.
func CloneRefOfForce(n *Force) *Force {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfForce does deep equals between the two objects.
func EqualsRefOfForce(a, b *Force) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfKeyState creates a deep clone of the input.
func CloneRefOfKeyState(n *KeyState) *KeyState {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfKeyState does deep equals between the two objects.
func EqualsRefOfKeyState(a, b *KeyState) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enable == b.Enable
}

// CloneRefOfLockOption creates a deep clone of the input.
func CloneRefOfLockOption(n *LockOption) *LockOption {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfLockOption does deep equals between the two objects.
func EqualsRefOfLockOption(a, b *LockOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type
}

// CloneRefOfModifyColumn creates a deep clone of the input.
func CloneRefOfModifyColumn(n *ModifyColumn) *ModifyColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.NewColDefinition = CloneRefOfColumnDefinition(n.NewColDefinition)
	out.First = CloneRefOfColName(n.First)
	out.After = CloneRefOfColName(n.After)
	return &out
}

// EqualsRefOfModifyColumn does deep equals between the two objects.
func EqualsRefOfModifyColumn(a, b *ModifyColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColumnDefinition(a.NewColDefinition, b.NewColDefinition) &&
		EqualsRefOfColName(a.First, b.First) &&
		EqualsRefOfColName(a.After, b.After)
}

// CloneRefOfOrderByOption creates a deep clone of the input.
func CloneRefOfOrderByOption(n *OrderByOption) *OrderByOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Cols = CloneColumns(n.Cols)
	return &out
}

// EqualsRefOfOrderByOption does deep equals between the two objects.
func EqualsRefOfOrderByOption(a, b *OrderByOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColumns(a.Cols, b.Cols)
}

// CloneRefOfRenameIndex creates a deep clone of the input.
func CloneRefOfRenameIndex(n *RenameIndex) *RenameIndex {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfRenameIndex does deep equals between the two objects.
func EqualsRefOfRenameIndex(a, b *RenameIndex) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.OldName == b.OldName &&
		a.NewName == b.NewName
}

// CloneRefOfRenameTableName creates a deep clone of the input.
func CloneRefOfRenameTableName(n *RenameTableName) *RenameTableName {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// EqualsRefOfRenameTableName does deep equals between the two objects.
func EqualsRefOfRenameTableName(a, b *RenameTableName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Table, b.Table)
}

// CloneTableOptions creates a deep clone of the input.
func CloneTableOptions(n TableOptions) TableOptions {
	res := make(TableOptions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfTableOption(x))
	}
	return res
}

// EqualsTableOptions does deep equals between the two objects.
func EqualsTableOptions(a, b TableOptions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfTableOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfTablespaceOperation creates a deep clone of the input.
func CloneRefOfTablespaceOperation(n *TablespaceOperation) *TablespaceOperation {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfTablespaceOperation does deep equals between the two objects.
func EqualsRefOfTablespaceOperation(a, b *TablespaceOperation) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Import == b.Import
}

// CloneRefOfValidation creates a deep clone of the input.
func CloneRefOfValidation(n *Validation) *Validation {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfValidation does deep equals between the two objects.
func EqualsRefOfValidation(a, b *Validation) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.With == b.With
}

// CloneListArg creates a deep clone of the input.
func CloneListArg(n ListArg) ListArg {
	res := make(ListArg, 0, len(n))
	copy(res, n)
	return res
}

// EqualsListArg does deep equals between the two objects.
func EqualsListArg(a, b ListArg) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// CloneRefOfSubquery creates a deep clone of the input.
func CloneRefOfSubquery(n *Subquery) *Subquery {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// EqualsRefOfSubquery does deep equals between the two objects.
func EqualsRefOfSubquery(a, b *Subquery) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectStatement(a.Select, b.Select)
}

// CloneValTuple creates a deep clone of the input.
func CloneValTuple(n ValTuple) ValTuple {
	res := make(ValTuple, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// EqualsValTuple does deep equals between the two objects.
func EqualsValTuple(a, b ValTuple) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfCheckConstraintDefinition creates a deep clone of the input.
func CloneRefOfCheckConstraintDefinition(n *CheckConstraintDefinition) *CheckConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfCheckConstraintDefinition does deep equals between the two objects.
func EqualsRefOfCheckConstraintDefinition(a, b *CheckConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Enforced == b.Enforced &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfForeignKeyDefinition creates a deep clone of the input.
func CloneRefOfForeignKeyDefinition(n *ForeignKeyDefinition) *ForeignKeyDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Source = CloneColumns(n.Source)
	out.ReferencedTable = CloneTableName(n.ReferencedTable)
	out.ReferencedColumns = CloneColumns(n.ReferencedColumns)
	return &out
}

// EqualsRefOfForeignKeyDefinition does deep equals between the two objects.
func EqualsRefOfForeignKeyDefinition(a, b *ForeignKeyDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColumns(a.Source, b.Source) &&
		EqualsTableName(a.ReferencedTable, b.ReferencedTable) &&
		EqualsColumns(a.ReferencedColumns, b.ReferencedColumns) &&
		a.OnDelete == b.OnDelete &&
		a.OnUpdate == b.OnUpdate
}

// CloneRefOfAlterDatabase creates a deep clone of the input.
func CloneRefOfAlterDatabase(n *AlterDatabase) *AlterDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.AlterOptions = CloneSliceOfCollateAndCharset(n.AlterOptions)
	return &out
}

// EqualsRefOfAlterDatabase does deep equals between the two objects.
func EqualsRefOfAlterDatabase(a, b *AlterDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DBName == b.DBName &&
		a.UpdateDataDirectory == b.UpdateDataDirectory &&
		a.FullyParsed == b.FullyParsed &&
		EqualsSliceOfCollateAndCharset(a.AlterOptions, b.AlterOptions)
}

// CloneRefOfCreateDatabase creates a deep clone of the input.
func CloneRefOfCreateDatabase(n *CreateDatabase) *CreateDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.CreateOptions = CloneSliceOfCollateAndCharset(n.CreateOptions)
	return &out
}

// EqualsRefOfCreateDatabase does deep equals between the two objects.
func EqualsRefOfCreateDatabase(a, b *CreateDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DBName == b.DBName &&
		a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		EqualsComments(a.Comments, b.Comments) &&
		EqualsSliceOfCollateAndCharset(a.CreateOptions, b.CreateOptions)
}

// CloneRefOfDropDatabase creates a deep clone of the input.
func CloneRefOfDropDatabase(n *DropDatabase) *DropDatabase {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	return &out
}

// EqualsRefOfDropDatabase does deep equals between the two objects.
func EqualsRefOfDropDatabase(a, b *DropDatabase) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.DBName == b.DBName &&
		a.IfExists == b.IfExists &&
		EqualsComments(a.Comments, b.Comments)
}

// CloneRefOfAlterTable creates a deep clone of the input.
func CloneRefOfAlterTable(n *AlterTable) *AlterTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.AlterOptions = CloneSliceOfAlterOption(n.AlterOptions)
	out.PartitionSpec = CloneRefOfPartitionSpec(n.PartitionSpec)
	return &out
}

// EqualsRefOfAlterTable does deep equals between the two objects.
func EqualsRefOfAlterTable(a, b *AlterTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FullyParsed == b.FullyParsed &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsSliceOfAlterOption(a.AlterOptions, b.AlterOptions) &&
		EqualsRefOfPartitionSpec(a.PartitionSpec, b.PartitionSpec)
}

// CloneRefOfAlterView creates a deep clone of the input.
func CloneRefOfAlterView(n *AlterView) *AlterView {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = CloneTableName(n.ViewName)
	out.Columns = CloneColumns(n.Columns)
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// EqualsRefOfAlterView does deep equals between the two objects.
func EqualsRefOfAlterView(a, b *AlterView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Definer == b.Definer &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		EqualsTableName(a.ViewName, b.ViewName) &&
		EqualsColumns(a.Columns, b.Columns) &&
		EqualsSelectStatement(a.Select, b.Select)
}

// CloneRefOfCreateTable creates a deep clone of the input.
func CloneRefOfCreateTable(n *CreateTable) *CreateTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.TableSpec = CloneRefOfTableSpec(n.TableSpec)
	out.OptLike = CloneRefOfOptLike(n.OptLike)
	return &out
}

// EqualsRefOfCreateTable does deep equals between the two objects.
func EqualsRefOfCreateTable(a, b *CreateTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfNotExists == b.IfNotExists &&
		a.FullyParsed == b.FullyParsed &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsRefOfTableSpec(a.TableSpec, b.TableSpec) &&
		EqualsRefOfOptLike(a.OptLike, b.OptLike)
}

// CloneRefOfCreateView creates a deep clone of the input.
func CloneRefOfCreateView(n *CreateView) *CreateView {
	if n == nil {
		return nil
	}
	out := *n
	out.ViewName = CloneTableName(n.ViewName)
	out.Columns = CloneColumns(n.Columns)
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// EqualsRefOfCreateView does deep equals between the two objects.
func EqualsRefOfCreateView(a, b *CreateView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Algorithm == b.Algorithm &&
		a.Definer == b.Definer &&
		a.Security == b.Security &&
		a.CheckOption == b.CheckOption &&
		a.IsReplace == b.IsReplace &&
		EqualsTableName(a.ViewName, b.ViewName) &&
		EqualsColumns(a.Columns, b.Columns) &&
		EqualsSelectStatement(a.Select, b.Select)
}

// CloneRefOfDropTable creates a deep clone of the input.
func CloneRefOfDropTable(n *DropTable) *DropTable {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = CloneTableNames(n.FromTables)
	return &out
}

// EqualsRefOfDropTable does deep equals between the two objects.
func EqualsRefOfDropTable(a, b *DropTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Temp == b.Temp &&
		a.IfExists == b.IfExists &&
		EqualsTableNames(a.FromTables, b.FromTables)
}

// CloneRefOfDropView creates a deep clone of the input.
func CloneRefOfDropView(n *DropView) *DropView {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTables = CloneTableNames(n.FromTables)
	return &out
}

// EqualsRefOfDropView does deep equals between the two objects.
func EqualsRefOfDropView(a, b *DropView) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IfExists == b.IfExists &&
		EqualsTableNames(a.FromTables, b.FromTables)
}

// CloneRefOfRenameTable creates a deep clone of the input.
func CloneRefOfRenameTable(n *RenameTable) *RenameTable {
	if n == nil {
		return nil
	}
	out := *n
	out.TablePairs = CloneSliceOfRefOfRenameTablePair(n.TablePairs)
	return &out
}

// EqualsRefOfRenameTable does deep equals between the two objects.
func EqualsRefOfRenameTable(a, b *RenameTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfRenameTablePair(a.TablePairs, b.TablePairs)
}

// CloneRefOfTruncateTable creates a deep clone of the input.
func CloneRefOfTruncateTable(n *TruncateTable) *TruncateTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// EqualsRefOfTruncateTable does deep equals between the two objects.
func EqualsRefOfTruncateTable(a, b *TruncateTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Table, b.Table)
}

// CloneRefOfExplainStmt creates a deep clone of the input.
func CloneRefOfExplainStmt(n *ExplainStmt) *ExplainStmt {
	if n == nil {
		return nil
	}
	out := *n
	out.Statement = CloneStatement(n.Statement)
	return &out
}

// EqualsRefOfExplainStmt does deep equals between the two objects.
func EqualsRefOfExplainStmt(a, b *ExplainStmt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsStatement(a.Statement, b.Statement)
}

// CloneRefOfExplainTab creates a deep clone of the input.
func CloneRefOfExplainTab(n *ExplainTab) *ExplainTab {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	return &out
}

// EqualsRefOfExplainTab does deep equals between the two objects.
func EqualsRefOfExplainTab(a, b *ExplainTab) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Wild == b.Wild &&
		EqualsTableName(a.Table, b.Table)
}

// CloneRefOfAndExpr creates a deep clone of the input.
func CloneRefOfAndExpr(n *AndExpr) *AndExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// EqualsRefOfAndExpr does deep equals between the two objects.
func EqualsRefOfAndExpr(a, b *AndExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.Right, b.Right)
}

// CloneRefOfBinaryExpr creates a deep clone of the input.
func CloneRefOfBinaryExpr(n *BinaryExpr) *BinaryExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// EqualsRefOfBinaryExpr does deep equals between the two objects.
func EqualsRefOfBinaryExpr(a, b *BinaryExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.Right, b.Right)
}

// CloneRefOfCaseExpr creates a deep clone of the input.
func CloneRefOfCaseExpr(n *CaseExpr) *CaseExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Whens = CloneSliceOfRefOfWhen(n.Whens)
	out.Else = CloneExpr(n.Else)
	return &out
}

// EqualsRefOfCaseExpr does deep equals between the two objects.
func EqualsRefOfCaseExpr(a, b *CaseExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr) &&
		EqualsSliceOfRefOfWhen(a.Whens, b.Whens) &&
		EqualsExpr(a.Else, b.Else)
}

// CloneRefOfColName creates a deep clone of the input.
func CloneRefOfColName(n *ColName) *ColName {
	return n
}

// EqualsRefOfColName does deep equals between the two objects.
func EqualsRefOfColName(a, b *ColName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name) &&
		EqualsTableName(a.Qualifier, b.Qualifier)
}

// CloneRefOfCollateExpr creates a deep clone of the input.
func CloneRefOfCollateExpr(n *CollateExpr) *CollateExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfCollateExpr does deep equals between the two objects.
func EqualsRefOfCollateExpr(a, b *CollateExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Charset == b.Charset &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfComparisonExpr creates a deep clone of the input.
func CloneRefOfComparisonExpr(n *ComparisonExpr) *ComparisonExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	out.Escape = CloneExpr(n.Escape)
	return &out
}

// EqualsRefOfComparisonExpr does deep equals between the two objects.
func EqualsRefOfComparisonExpr(a, b *ComparisonExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.Right, b.Right) &&
		EqualsExpr(a.Escape, b.Escape)
}

// CloneRefOfConvertExpr creates a deep clone of the input.
func CloneRefOfConvertExpr(n *ConvertExpr) *ConvertExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.Type = CloneRefOfConvertType(n.Type)
	return &out
}

// EqualsRefOfConvertExpr does deep equals between the two objects.
func EqualsRefOfConvertExpr(a, b *ConvertExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr) &&
		EqualsRefOfConvertType(a.Type, b.Type)
}

// CloneRefOfConvertUsingExpr creates a deep clone of the input.
func CloneRefOfConvertUsingExpr(n *ConvertUsingExpr) *ConvertUsingExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfConvertUsingExpr does deep equals between the two objects.
func EqualsRefOfConvertUsingExpr(a, b *ConvertUsingExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfCurTimeFuncExpr creates a deep clone of the input.
func CloneRefOfCurTimeFuncExpr(n *CurTimeFuncExpr) *CurTimeFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Fsp = CloneExpr(n.Fsp)
	return &out
}

// EqualsRefOfCurTimeFuncExpr does deep equals between the two objects.
func EqualsRefOfCurTimeFuncExpr(a, b *CurTimeFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name) &&
		EqualsExpr(a.Fsp, b.Fsp)
}

// CloneRefOfDefault creates a deep clone of the input.
func CloneRefOfDefault(n *Default) *Default {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfDefault does deep equals between the two objects.
func EqualsRefOfDefault(a, b *Default) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.ColName == b.ColName
}

// CloneRefOfExistsExpr creates a deep clone of the input.
func CloneRefOfExistsExpr(n *ExistsExpr) *ExistsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Subquery = CloneRefOfSubquery(n.Subquery)
	return &out
}

// EqualsRefOfExistsExpr does deep equals between the two objects.
func EqualsRefOfExistsExpr(a, b *ExistsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfSubquery(a.Subquery, b.Subquery)
}

// CloneRefOfFuncExpr creates a deep clone of the input.
func CloneRefOfFuncExpr(n *FuncExpr) *FuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Qualifier = CloneTableIdent(n.Qualifier)
	out.Name = CloneColIdent(n.Name)
	out.Exprs = CloneSelectExprs(n.Exprs)
	return &out
}

// EqualsRefOfFuncExpr does deep equals between the two objects.
func EqualsRefOfFuncExpr(a, b *FuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsTableIdent(a.Qualifier, b.Qualifier) &&
		EqualsColIdent(a.Name, b.Name) &&
		EqualsSelectExprs(a.Exprs, b.Exprs)
}

// CloneRefOfGroupConcatExpr creates a deep clone of the input.
func CloneRefOfGroupConcatExpr(n *GroupConcatExpr) *GroupConcatExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = CloneSelectExprs(n.Exprs)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// EqualsRefOfGroupConcatExpr does deep equals between the two objects.
func EqualsRefOfGroupConcatExpr(a, b *GroupConcatExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.Separator == b.Separator &&
		EqualsSelectExprs(a.Exprs, b.Exprs) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy) &&
		EqualsRefOfLimit(a.Limit, b.Limit)
}

// CloneRefOfIntervalExpr creates a deep clone of the input.
func CloneRefOfIntervalExpr(n *IntervalExpr) *IntervalExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfIntervalExpr does deep equals between the two objects.
func EqualsRefOfIntervalExpr(a, b *IntervalExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Unit == b.Unit &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfIsExpr creates a deep clone of the input.
func CloneRefOfIsExpr(n *IsExpr) *IsExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfIsExpr does deep equals between the two objects.
func EqualsRefOfIsExpr(a, b *IsExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfLiteral creates a deep clone of the input.
func CloneRefOfLiteral(n *Literal) *Literal {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfLiteral does deep equals between the two objects.
func EqualsRefOfLiteral(a, b *Literal) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		a.Type == b.Type
}

// CloneRefOfMatchExpr creates a deep clone of the input.
func CloneRefOfMatchExpr(n *MatchExpr) *MatchExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSelectExprs(n.Columns)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfMatchExpr does deep equals between the two objects.
func EqualsRefOfMatchExpr(a, b *MatchExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectExprs(a.Columns, b.Columns) &&
		EqualsExpr(a.Expr, b.Expr) &&
		a.Option == b.Option
}

// CloneRefOfNotExpr creates a deep clone of the input.
func CloneRefOfNotExpr(n *NotExpr) *NotExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfNotExpr does deep equals between the two objects.
func EqualsRefOfNotExpr(a, b *NotExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfNullVal creates a deep clone of the input.
func CloneRefOfNullVal(n *NullVal) *NullVal {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfNullVal does deep equals between the two objects.
func EqualsRefOfNullVal(a, b *NullVal) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfOrExpr creates a deep clone of the input.
func CloneRefOfOrExpr(n *OrExpr) *OrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// EqualsRefOfOrExpr does deep equals between the two objects.
func EqualsRefOfOrExpr(a, b *OrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.Right, b.Right)
}

// CloneRefOfRangeCond creates a deep clone of the input.
func CloneRefOfRangeCond(n *RangeCond) *RangeCond {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.From = CloneExpr(n.From)
	out.To = CloneExpr(n.To)
	return &out
}

// EqualsRefOfRangeCond does deep equals between the two objects.
func EqualsRefOfRangeCond(a, b *RangeCond) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.From, b.From) &&
		EqualsExpr(a.To, b.To)
}

// CloneRefOfSubstrExpr creates a deep clone of the input.
func CloneRefOfSubstrExpr(n *SubstrExpr) *SubstrExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	out.StrVal = CloneRefOfLiteral(n.StrVal)
	out.From = CloneExpr(n.From)
	out.To = CloneExpr(n.To)
	return &out
}

// EqualsRefOfSubstrExpr does deep equals between the two objects.
func EqualsRefOfSubstrExpr(a, b *SubstrExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name) &&
		EqualsRefOfLiteral(a.StrVal, b.StrVal) &&
		EqualsExpr(a.From, b.From) &&
		EqualsExpr(a.To, b.To)
}

// CloneRefOfTimestampFuncExpr creates a deep clone of the input.
func CloneRefOfTimestampFuncExpr(n *TimestampFuncExpr) *TimestampFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr1 = CloneExpr(n.Expr1)
	out.Expr2 = CloneExpr(n.Expr2)
	return &out
}

// EqualsRefOfTimestampFuncExpr does deep equals between the two objects.
func EqualsRefOfTimestampFuncExpr(a, b *TimestampFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.Unit == b.Unit &&
		EqualsExpr(a.Expr1, b.Expr1) &&
		EqualsExpr(a.Expr2, b.Expr2)
}

// CloneRefOfUnaryExpr creates a deep clone of the input.
func CloneRefOfUnaryExpr(n *UnaryExpr) *UnaryExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfUnaryExpr does deep equals between the two objects.
func EqualsRefOfUnaryExpr(a, b *UnaryExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Operator == b.Operator &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneRefOfValuesFuncExpr creates a deep clone of the input.
func CloneRefOfValuesFuncExpr(n *ValuesFuncExpr) *ValuesFuncExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	return &out
}

// EqualsRefOfValuesFuncExpr does deep equals between the two objects.
func EqualsRefOfValuesFuncExpr(a, b *ValuesFuncExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name)
}

// CloneRefOfXorExpr creates a deep clone of the input.
func CloneRefOfXorExpr(n *XorExpr) *XorExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Left = CloneExpr(n.Left)
	out.Right = CloneExpr(n.Right)
	return &out
}

// EqualsRefOfXorExpr does deep equals between the two objects.
func EqualsRefOfXorExpr(a, b *XorExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Left, b.Left) &&
		EqualsExpr(a.Right, b.Right)
}

// CloneRefOfParenSelect creates a deep clone of the input.
func CloneRefOfParenSelect(n *ParenSelect) *ParenSelect {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// EqualsRefOfParenSelect does deep equals between the two objects.
func EqualsRefOfParenSelect(a, b *ParenSelect) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectStatement(a.Select, b.Select)
}

// CloneRefOfSelect creates a deep clone of the input.
func CloneRefOfSelect(n *Select) *Select {
	if n == nil {
		return nil
	}
	out := *n
	out.Cache = CloneRefOfBool(n.Cache)
	out.Comments = CloneComments(n.Comments)
	out.SelectExprs = CloneSelectExprs(n.SelectExprs)
	out.From = CloneTableExprs(n.From)
	out.Where = CloneRefOfWhere(n.Where)
	out.GroupBy = CloneGroupBy(n.GroupBy)
	out.Having = CloneRefOfWhere(n.Having)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	out.Into = CloneRefOfSelectInto(n.Into)
	return &out
}

// EqualsRefOfSelect does deep equals between the two objects.
func EqualsRefOfSelect(a, b *Select) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		a.StraightJoinHint == b.StraightJoinHint &&
		a.SQLCalcFoundRows == b.SQLCalcFoundRows &&
		EqualsRefOfBool(a.Cache, b.Cache) &&
		EqualsComments(a.Comments, b.Comments) &&
		EqualsSelectExprs(a.SelectExprs, b.SelectExprs) &&
		EqualsTableExprs(a.From, b.From) &&
		EqualsRefOfWhere(a.Where, b.Where) &&
		EqualsGroupBy(a.GroupBy, b.GroupBy) &&
		EqualsRefOfWhere(a.Having, b.Having) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy) &&
		EqualsRefOfLimit(a.Limit, b.Limit) &&
		a.Lock == b.Lock &&
		EqualsRefOfSelectInto(a.Into, b.Into)
}

// CloneRefOfUnion creates a deep clone of the input.
func CloneRefOfUnion(n *Union) *Union {
	if n == nil {
		return nil
	}
	out := *n
	out.FirstStatement = CloneSelectStatement(n.FirstStatement)
	out.UnionSelects = CloneSliceOfRefOfUnionSelect(n.UnionSelects)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// EqualsRefOfUnion does deep equals between the two objects.
func EqualsRefOfUnion(a, b *Union) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectStatement(a.FirstStatement, b.FirstStatement) &&
		EqualsSliceOfRefOfUnionSelect(a.UnionSelects, b.UnionSelects) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy) &&
		EqualsRefOfLimit(a.Limit, b.Limit) &&
		a.Lock == b.Lock
}

// CloneValues creates a deep clone of the input.
func CloneValues(n Values) Values {
	res := make(Values, 0, len(n))
	for _, x := range n {
		res = append(res, CloneValTuple(x))
	}
	return res
}

// EqualsValues does deep equals between the two objects.
func EqualsValues(a, b Values) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsValTuple(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfAliasedExpr creates a deep clone of the input.
func CloneRefOfAliasedExpr(n *AliasedExpr) *AliasedExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	out.As = CloneColIdent(n.As)
	return &out
}

// EqualsRefOfAliasedExpr does deep equals between the two objects.
func EqualsRefOfAliasedExpr(a, b *AliasedExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr) &&
		EqualsColIdent(a.As, b.As)
}

// CloneRefOfAliasedTableExpr creates a deep clone of the input.
func CloneRefOfAliasedTableExpr(n *AliasedTableExpr) *AliasedTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneSimpleTableExpr(n.Expr)
	out.Partitions = ClonePartitions(n.Partitions)
	out.As = CloneTableIdent(n.As)
	out.Hints = CloneRefOfIndexHints(n.Hints)
	return &out
}

// EqualsRefOfAliasedTableExpr does deep equals between the two objects.
func EqualsRefOfAliasedTableExpr(a, b *AliasedTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSimpleTableExpr(a.Expr, b.Expr) &&
		EqualsPartitions(a.Partitions, b.Partitions) &&
		EqualsTableIdent(a.As, b.As) &&
		EqualsRefOfIndexHints(a.Hints, b.Hints)
}

// CloneRefOfAlterVschema creates a deep clone of the input.
func CloneRefOfAlterVschema(n *AlterVschema) *AlterVschema {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableName(n.Table)
	out.VindexSpec = CloneRefOfVindexSpec(n.VindexSpec)
	out.VindexCols = CloneSliceOfColIdent(n.VindexCols)
	out.AutoIncSpec = CloneRefOfAutoIncSpec(n.AutoIncSpec)
	return &out
}

// EqualsRefOfAlterVschema does deep equals between the two objects.
func EqualsRefOfAlterVschema(a, b *AlterVschema) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsRefOfVindexSpec(a.VindexSpec, b.VindexSpec) &&
		EqualsSliceOfColIdent(a.VindexCols, b.VindexCols) &&
		EqualsRefOfAutoIncSpec(a.AutoIncSpec, b.AutoIncSpec)
}

// CloneRefOfAutoIncSpec creates a deep clone of the input.
func CloneRefOfAutoIncSpec(n *AutoIncSpec) *AutoIncSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneColIdent(n.Column)
	out.Sequence = CloneTableName(n.Sequence)
	return &out
}

// EqualsRefOfAutoIncSpec does deep equals between the two objects.
func EqualsRefOfAutoIncSpec(a, b *AutoIncSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Column, b.Column) &&
		EqualsTableName(a.Sequence, b.Sequence)
}

// CloneRefOfBegin creates a deep clone of the input.
func CloneRefOfBegin(n *Begin) *Begin {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfBegin does deep equals between the two objects.
func EqualsRefOfBegin(a, b *Begin) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfCallProc creates a deep clone of the input.
func CloneRefOfCallProc(n *CallProc) *CallProc {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneTableName(n.Name)
	out.Params = CloneExprs(n.Params)
	return &out
}

// EqualsRefOfCallProc does deep equals between the two objects.
func EqualsRefOfCallProc(a, b *CallProc) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.Name, b.Name) &&
		EqualsExprs(a.Params, b.Params)
}

// CloneColIdent creates a deep clone of the input.
func CloneColIdent(n ColIdent) ColIdent {
	return *CloneRefOfColIdent(&n)
}

// EqualsColIdent does deep equals between the two objects.
func EqualsColIdent(a, b ColIdent) bool {
	return a.val == b.val &&
		a.lowered == b.lowered &&
		a.at == b.at
}

// CloneRefOfColumnDefinition creates a deep clone of the input.
func CloneRefOfColumnDefinition(n *ColumnDefinition) *ColumnDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Type = CloneColumnType(n.Type)
	return &out
}

// EqualsRefOfColumnDefinition does deep equals between the two objects.
func EqualsRefOfColumnDefinition(a, b *ColumnDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name) &&
		EqualsColumnType(a.Type, b.Type)
}

// CloneRefOfColumnType creates a deep clone of the input.
func CloneRefOfColumnType(n *ColumnType) *ColumnType {
	if n == nil {
		return nil
	}
	out := *n
	out.Options = CloneRefOfColumnTypeOptions(n.Options)
	out.Length = CloneRefOfLiteral(n.Length)
	out.Scale = CloneRefOfLiteral(n.Scale)
	out.EnumValues = CloneSliceOfString(n.EnumValues)
	return &out
}

// EqualsRefOfColumnType does deep equals between the two objects.
func EqualsRefOfColumnType(a, b *ColumnType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Unsigned == b.Unsigned &&
		a.Zerofill == b.Zerofill &&
		a.Charset == b.Charset &&
		a.Collate == b.Collate &&
		EqualsRefOfColumnTypeOptions(a.Options, b.Options) &&
		EqualsRefOfLiteral(a.Length, b.Length) &&
		EqualsRefOfLiteral(a.Scale, b.Scale) &&
		EqualsSliceOfString(a.EnumValues, b.EnumValues)
}

// CloneColumns creates a deep clone of the input.
func CloneColumns(n Columns) Columns {
	res := make(Columns, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// EqualsColumns does deep equals between the two objects.
func EqualsColumns(a, b Columns) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsColIdent(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneComments creates a deep clone of the input.
func CloneComments(n Comments) Comments {
	res := make(Comments, 0, len(n))
	copy(res, n)
	return res
}

// EqualsComments does deep equals between the two objects.
func EqualsComments(a, b Comments) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// CloneRefOfCommit creates a deep clone of the input.
func CloneRefOfCommit(n *Commit) *Commit {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfCommit does deep equals between the two objects.
func EqualsRefOfCommit(a, b *Commit) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfConstraintDefinition creates a deep clone of the input.
func CloneRefOfConstraintDefinition(n *ConstraintDefinition) *ConstraintDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Details = CloneConstraintInfo(n.Details)
	return &out
}

// EqualsRefOfConstraintDefinition does deep equals between the two objects.
func EqualsRefOfConstraintDefinition(a, b *ConstraintDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		EqualsConstraintInfo(a.Details, b.Details)
}

// CloneRefOfConvertType creates a deep clone of the input.
func CloneRefOfConvertType(n *ConvertType) *ConvertType {
	if n == nil {
		return nil
	}
	out := *n
	out.Length = CloneRefOfLiteral(n.Length)
	out.Scale = CloneRefOfLiteral(n.Scale)
	return &out
}

// EqualsRefOfConvertType does deep equals between the two objects.
func EqualsRefOfConvertType(a, b *ConvertType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Charset == b.Charset &&
		EqualsRefOfLiteral(a.Length, b.Length) &&
		EqualsRefOfLiteral(a.Scale, b.Scale) &&
		a.Operator == b.Operator
}

// CloneRefOfDelete creates a deep clone of the input.
func CloneRefOfDelete(n *Delete) *Delete {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.Targets = CloneTableNames(n.Targets)
	out.TableExprs = CloneTableExprs(n.TableExprs)
	out.Partitions = ClonePartitions(n.Partitions)
	out.Where = CloneRefOfWhere(n.Where)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// EqualsRefOfDelete does deep equals between the two objects.
func EqualsRefOfDelete(a, b *Delete) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Ignore == b.Ignore &&
		EqualsComments(a.Comments, b.Comments) &&
		EqualsTableNames(a.Targets, b.Targets) &&
		EqualsTableExprs(a.TableExprs, b.TableExprs) &&
		EqualsPartitions(a.Partitions, b.Partitions) &&
		EqualsRefOfWhere(a.Where, b.Where) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy) &&
		EqualsRefOfLimit(a.Limit, b.Limit)
}

// CloneRefOfDerivedTable creates a deep clone of the input.
func CloneRefOfDerivedTable(n *DerivedTable) *DerivedTable {
	if n == nil {
		return nil
	}
	out := *n
	out.Select = CloneSelectStatement(n.Select)
	return &out
}

// EqualsRefOfDerivedTable does deep equals between the two objects.
func EqualsRefOfDerivedTable(a, b *DerivedTable) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSelectStatement(a.Select, b.Select)
}

// CloneExprs creates a deep clone of the input.
func CloneExprs(n Exprs) Exprs {
	res := make(Exprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// EqualsExprs does deep equals between the two objects.
func EqualsExprs(a, b Exprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfFlush creates a deep clone of the input.
func CloneRefOfFlush(n *Flush) *Flush {
	if n == nil {
		return nil
	}
	out := *n
	out.FlushOptions = CloneSliceOfString(n.FlushOptions)
	out.TableNames = CloneTableNames(n.TableNames)
	return &out
}

// EqualsRefOfFlush does deep equals between the two objects.
func EqualsRefOfFlush(a, b *Flush) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsLocal == b.IsLocal &&
		a.WithLock == b.WithLock &&
		a.ForExport == b.ForExport &&
		EqualsSliceOfString(a.FlushOptions, b.FlushOptions) &&
		EqualsTableNames(a.TableNames, b.TableNames)
}

// CloneGroupBy creates a deep clone of the input.
func CloneGroupBy(n GroupBy) GroupBy {
	res := make(GroupBy, 0, len(n))
	for _, x := range n {
		res = append(res, CloneExpr(x))
	}
	return res
}

// EqualsGroupBy does deep equals between the two objects.
func EqualsGroupBy(a, b GroupBy) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfIndexDefinition creates a deep clone of the input.
func CloneRefOfIndexDefinition(n *IndexDefinition) *IndexDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Info = CloneRefOfIndexInfo(n.Info)
	out.Columns = CloneSliceOfRefOfIndexColumn(n.Columns)
	out.Options = CloneSliceOfRefOfIndexOption(n.Options)
	return &out
}

// EqualsRefOfIndexDefinition does deep equals between the two objects.
func EqualsRefOfIndexDefinition(a, b *IndexDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfIndexInfo(a.Info, b.Info) &&
		EqualsSliceOfRefOfIndexColumn(a.Columns, b.Columns) &&
		EqualsSliceOfRefOfIndexOption(a.Options, b.Options)
}

// CloneRefOfIndexHints creates a deep clone of the input.
func CloneRefOfIndexHints(n *IndexHints) *IndexHints {
	if n == nil {
		return nil
	}
	out := *n
	out.Indexes = CloneSliceOfColIdent(n.Indexes)
	return &out
}

// EqualsRefOfIndexHints does deep equals between the two objects.
func EqualsRefOfIndexHints(a, b *IndexHints) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsSliceOfColIdent(a.Indexes, b.Indexes)
}

// CloneRefOfIndexInfo creates a deep clone of the input.
func CloneRefOfIndexInfo(n *IndexInfo) *IndexInfo {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.ConstraintName = CloneColIdent(n.ConstraintName)
	return &out
}

// EqualsRefOfIndexInfo does deep equals between the two objects.
func EqualsRefOfIndexInfo(a, b *IndexInfo) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		a.Primary == b.Primary &&
		a.Spatial == b.Spatial &&
		a.Fulltext == b.Fulltext &&
		a.Unique == b.Unique &&
		EqualsColIdent(a.Name, b.Name) &&
		EqualsColIdent(a.ConstraintName, b.ConstraintName)
}

// CloneRefOfInsert creates a deep clone of the input.
func CloneRefOfInsert(n *Insert) *Insert {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.Table = CloneTableName(n.Table)
	out.Partitions = ClonePartitions(n.Partitions)
	out.Columns = CloneColumns(n.Columns)
	out.Rows = CloneInsertRows(n.Rows)
	out.OnDup = CloneOnDup(n.OnDup)
	return &out
}

// EqualsRefOfInsert does deep equals between the two objects.
func EqualsRefOfInsert(a, b *Insert) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Action == b.Action &&
		EqualsComments(a.Comments, b.Comments) &&
		a.Ignore == b.Ignore &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsPartitions(a.Partitions, b.Partitions) &&
		EqualsColumns(a.Columns, b.Columns) &&
		EqualsInsertRows(a.Rows, b.Rows) &&
		EqualsOnDup(a.OnDup, b.OnDup)
}

// CloneJoinCondition creates a deep clone of the input.
func CloneJoinCondition(n JoinCondition) JoinCondition {
	return *CloneRefOfJoinCondition(&n)
}

// EqualsJoinCondition does deep equals between the two objects.
func EqualsJoinCondition(a, b JoinCondition) bool {
	return EqualsExpr(a.On, b.On) &&
		EqualsColumns(a.Using, b.Using)
}

// CloneRefOfJoinTableExpr creates a deep clone of the input.
func CloneRefOfJoinTableExpr(n *JoinTableExpr) *JoinTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.LeftExpr = CloneTableExpr(n.LeftExpr)
	out.RightExpr = CloneTableExpr(n.RightExpr)
	out.Condition = CloneJoinCondition(n.Condition)
	return &out
}

// EqualsRefOfJoinTableExpr does deep equals between the two objects.
func EqualsRefOfJoinTableExpr(a, b *JoinTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExpr(a.LeftExpr, b.LeftExpr) &&
		a.Join == b.Join &&
		EqualsTableExpr(a.RightExpr, b.RightExpr) &&
		EqualsJoinCondition(a.Condition, b.Condition)
}

// CloneRefOfLimit creates a deep clone of the input.
func CloneRefOfLimit(n *Limit) *Limit {
	if n == nil {
		return nil
	}
	out := *n
	out.Offset = CloneExpr(n.Offset)
	out.Rowcount = CloneExpr(n.Rowcount)
	return &out
}

// EqualsRefOfLimit does deep equals between the two objects.
func EqualsRefOfLimit(a, b *Limit) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Offset, b.Offset) &&
		EqualsExpr(a.Rowcount, b.Rowcount)
}

// CloneRefOfLoad creates a deep clone of the input.
func CloneRefOfLoad(n *Load) *Load {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfLoad does deep equals between the two objects.
func EqualsRefOfLoad(a, b *Load) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfLockTables creates a deep clone of the input.
func CloneRefOfLockTables(n *LockTables) *LockTables {
	if n == nil {
		return nil
	}
	out := *n
	out.Tables = CloneTableAndLockTypes(n.Tables)
	return &out
}

// EqualsRefOfLockTables does deep equals between the two objects.
func EqualsRefOfLockTables(a, b *LockTables) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableAndLockTypes(a.Tables, b.Tables)
}

// CloneRefOfNextval creates a deep clone of the input.
func CloneRefOfNextval(n *Nextval) *Nextval {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfNextval does deep equals between the two objects.
func EqualsRefOfNextval(a, b *Nextval) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr)
}

// CloneOnDup creates a deep clone of the input.
func CloneOnDup(n OnDup) OnDup {
	res := make(OnDup, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfUpdateExpr(x))
	}
	return res
}

// EqualsOnDup does deep equals between the two objects.
func EqualsOnDup(a, b OnDup) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfUpdateExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfOptLike creates a deep clone of the input.
func CloneRefOfOptLike(n *OptLike) *OptLike {
	if n == nil {
		return nil
	}
	out := *n
	out.LikeTable = CloneTableName(n.LikeTable)
	return &out
}

// EqualsRefOfOptLike does deep equals between the two objects.
func EqualsRefOfOptLike(a, b *OptLike) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.LikeTable, b.LikeTable)
}

// CloneRefOfOrder creates a deep clone of the input.
func CloneRefOfOrder(n *Order) *Order {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfOrder does deep equals between the two objects.
func EqualsRefOfOrder(a, b *Order) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Expr, b.Expr) &&
		a.Direction == b.Direction
}

// CloneOrderBy creates a deep clone of the input.
func CloneOrderBy(n OrderBy) OrderBy {
	res := make(OrderBy, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfOrder(x))
	}
	return res
}

// EqualsOrderBy does deep equals between the two objects.
func EqualsOrderBy(a, b OrderBy) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfOrder(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfOtherAdmin creates a deep clone of the input.
func CloneRefOfOtherAdmin(n *OtherAdmin) *OtherAdmin {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfOtherAdmin does deep equals between the two objects.
func EqualsRefOfOtherAdmin(a, b *OtherAdmin) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfOtherRead creates a deep clone of the input.
func CloneRefOfOtherRead(n *OtherRead) *OtherRead {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfOtherRead does deep equals between the two objects.
func EqualsRefOfOtherRead(a, b *OtherRead) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfParenTableExpr creates a deep clone of the input.
func CloneRefOfParenTableExpr(n *ParenTableExpr) *ParenTableExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Exprs = CloneTableExprs(n.Exprs)
	return &out
}

// EqualsRefOfParenTableExpr does deep equals between the two objects.
func EqualsRefOfParenTableExpr(a, b *ParenTableExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExprs(a.Exprs, b.Exprs)
}

// CloneRefOfPartitionDefinition creates a deep clone of the input.
func CloneRefOfPartitionDefinition(n *PartitionDefinition) *PartitionDefinition {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Limit = CloneExpr(n.Limit)
	return &out
}

// EqualsRefOfPartitionDefinition does deep equals between the two objects.
func EqualsRefOfPartitionDefinition(a, b *PartitionDefinition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Maxvalue == b.Maxvalue &&
		EqualsColIdent(a.Name, b.Name) &&
		EqualsExpr(a.Limit, b.Limit)
}

// CloneRefOfPartitionSpec creates a deep clone of the input.
func CloneRefOfPartitionSpec(n *PartitionSpec) *PartitionSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Names = ClonePartitions(n.Names)
	out.Number = CloneRefOfLiteral(n.Number)
	out.TableName = CloneTableName(n.TableName)
	out.Definitions = CloneSliceOfRefOfPartitionDefinition(n.Definitions)
	return &out
}

// EqualsRefOfPartitionSpec does deep equals between the two objects.
func EqualsRefOfPartitionSpec(a, b *PartitionSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsAll == b.IsAll &&
		a.WithoutValidation == b.WithoutValidation &&
		a.Action == b.Action &&
		EqualsPartitions(a.Names, b.Names) &&
		EqualsRefOfLiteral(a.Number, b.Number) &&
		EqualsTableName(a.TableName, b.TableName) &&
		EqualsSliceOfRefOfPartitionDefinition(a.Definitions, b.Definitions)
}

// ClonePartitions creates a deep clone of the input.
func ClonePartitions(n Partitions) Partitions {
	res := make(Partitions, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// EqualsPartitions does deep equals between the two objects.
func EqualsPartitions(a, b Partitions) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsColIdent(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfRelease creates a deep clone of the input.
func CloneRefOfRelease(n *Release) *Release {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// EqualsRefOfRelease does deep equals between the two objects.
func EqualsRefOfRelease(a, b *Release) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name)
}

// CloneRefOfRevertMigration creates a deep clone of the input.
func CloneRefOfRevertMigration(n *RevertMigration) *RevertMigration {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfRevertMigration does deep equals between the two objects.
func EqualsRefOfRevertMigration(a, b *RevertMigration) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.UUID == b.UUID
}

// CloneRefOfRollback creates a deep clone of the input.
func CloneRefOfRollback(n *Rollback) *Rollback {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfRollback does deep equals between the two objects.
func EqualsRefOfRollback(a, b *Rollback) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfSRollback creates a deep clone of the input.
func CloneRefOfSRollback(n *SRollback) *SRollback {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// EqualsRefOfSRollback does deep equals between the two objects.
func EqualsRefOfSRollback(a, b *SRollback) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name)
}

// CloneRefOfSavepoint creates a deep clone of the input.
func CloneRefOfSavepoint(n *Savepoint) *Savepoint {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	return &out
}

// EqualsRefOfSavepoint does deep equals between the two objects.
func EqualsRefOfSavepoint(a, b *Savepoint) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name)
}

// CloneSelectExprs creates a deep clone of the input.
func CloneSelectExprs(n SelectExprs) SelectExprs {
	res := make(SelectExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneSelectExpr(x))
	}
	return res
}

// EqualsSelectExprs does deep equals between the two objects.
func EqualsSelectExprs(a, b SelectExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsSelectExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfSelectInto creates a deep clone of the input.
func CloneRefOfSelectInto(n *SelectInto) *SelectInto {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfSelectInto does deep equals between the two objects.
func EqualsRefOfSelectInto(a, b *SelectInto) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.FileName == b.FileName &&
		a.Charset == b.Charset &&
		a.FormatOption == b.FormatOption &&
		a.ExportOption == b.ExportOption &&
		a.Manifest == b.Manifest &&
		a.Overwrite == b.Overwrite &&
		a.Type == b.Type
}

// CloneRefOfSet creates a deep clone of the input.
func CloneRefOfSet(n *Set) *Set {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.Exprs = CloneSetExprs(n.Exprs)
	return &out
}

// EqualsRefOfSet does deep equals between the two objects.
func EqualsRefOfSet(a, b *Set) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments) &&
		EqualsSetExprs(a.Exprs, b.Exprs)
}

// CloneRefOfSetExpr creates a deep clone of the input.
func CloneRefOfSetExpr(n *SetExpr) *SetExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfSetExpr does deep equals between the two objects.
func EqualsRefOfSetExpr(a, b *SetExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Scope == b.Scope &&
		EqualsColIdent(a.Name, b.Name) &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneSetExprs creates a deep clone of the input.
func CloneSetExprs(n SetExprs) SetExprs {
	res := make(SetExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfSetExpr(x))
	}
	return res
}

// EqualsSetExprs does deep equals between the two objects.
func EqualsSetExprs(a, b SetExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfSetExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfSetTransaction creates a deep clone of the input.
func CloneRefOfSetTransaction(n *SetTransaction) *SetTransaction {
	if n == nil {
		return nil
	}
	out := *n
	out.SQLNode = CloneSQLNode(n.SQLNode)
	out.Comments = CloneComments(n.Comments)
	out.Characteristics = CloneSliceOfCharacteristic(n.Characteristics)
	return &out
}

// EqualsRefOfSetTransaction does deep equals between the two objects.
func EqualsRefOfSetTransaction(a, b *SetTransaction) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSQLNode(a.SQLNode, b.SQLNode) &&
		EqualsComments(a.Comments, b.Comments) &&
		a.Scope == b.Scope &&
		EqualsSliceOfCharacteristic(a.Characteristics, b.Characteristics)
}

// CloneRefOfShow creates a deep clone of the input.
func CloneRefOfShow(n *Show) *Show {
	if n == nil {
		return nil
	}
	out := *n
	out.Internal = CloneShowInternal(n.Internal)
	return &out
}

// EqualsRefOfShow does deep equals between the two objects.
func EqualsRefOfShow(a, b *Show) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsShowInternal(a.Internal, b.Internal)
}

// CloneRefOfShowBasic creates a deep clone of the input.
func CloneRefOfShowBasic(n *ShowBasic) *ShowBasic {
	if n == nil {
		return nil
	}
	out := *n
	out.Tbl = CloneTableName(n.Tbl)
	out.Filter = CloneRefOfShowFilter(n.Filter)
	return &out
}

// EqualsRefOfShowBasic does deep equals between the two objects.
func EqualsRefOfShowBasic(a, b *ShowBasic) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Full == b.Full &&
		a.DbName == b.DbName &&
		a.Command == b.Command &&
		EqualsTableName(a.Tbl, b.Tbl) &&
		EqualsRefOfShowFilter(a.Filter, b.Filter)
}

// CloneRefOfShowCreate creates a deep clone of the input.
func CloneRefOfShowCreate(n *ShowCreate) *ShowCreate {
	if n == nil {
		return nil
	}
	out := *n
	out.Op = CloneTableName(n.Op)
	return &out
}

// EqualsRefOfShowCreate does deep equals between the two objects.
func EqualsRefOfShowCreate(a, b *ShowCreate) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Command == b.Command &&
		EqualsTableName(a.Op, b.Op)
}

// CloneRefOfShowFilter creates a deep clone of the input.
func CloneRefOfShowFilter(n *ShowFilter) *ShowFilter {
	if n == nil {
		return nil
	}
	out := *n
	out.Filter = CloneExpr(n.Filter)
	return &out
}

// EqualsRefOfShowFilter does deep equals between the two objects.
func EqualsRefOfShowFilter(a, b *ShowFilter) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Like == b.Like &&
		EqualsExpr(a.Filter, b.Filter)
}

// CloneRefOfShowLegacy creates a deep clone of the input.
func CloneRefOfShowLegacy(n *ShowLegacy) *ShowLegacy {
	if n == nil {
		return nil
	}
	out := *n
	out.OnTable = CloneTableName(n.OnTable)
	out.Table = CloneTableName(n.Table)
	out.ShowTablesOpt = CloneRefOfShowTablesOpt(n.ShowTablesOpt)
	out.ShowCollationFilterOpt = CloneExpr(n.ShowCollationFilterOpt)
	return &out
}

// EqualsRefOfShowLegacy does deep equals between the two objects.
func EqualsRefOfShowLegacy(a, b *ShowLegacy) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Extended == b.Extended &&
		a.Type == b.Type &&
		EqualsTableName(a.OnTable, b.OnTable) &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsRefOfShowTablesOpt(a.ShowTablesOpt, b.ShowTablesOpt) &&
		a.Scope == b.Scope &&
		EqualsExpr(a.ShowCollationFilterOpt, b.ShowCollationFilterOpt)
}

// CloneRefOfStarExpr creates a deep clone of the input.
func CloneRefOfStarExpr(n *StarExpr) *StarExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.TableName = CloneTableName(n.TableName)
	return &out
}

// EqualsRefOfStarExpr does deep equals between the two objects.
func EqualsRefOfStarExpr(a, b *StarExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.TableName, b.TableName)
}

// CloneRefOfStream creates a deep clone of the input.
func CloneRefOfStream(n *Stream) *Stream {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.SelectExpr = CloneSelectExpr(n.SelectExpr)
	out.Table = CloneTableName(n.Table)
	return &out
}

// EqualsRefOfStream does deep equals between the two objects.
func EqualsRefOfStream(a, b *Stream) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments) &&
		EqualsSelectExpr(a.SelectExpr, b.SelectExpr) &&
		EqualsTableName(a.Table, b.Table)
}

// CloneTableExprs creates a deep clone of the input.
func CloneTableExprs(n TableExprs) TableExprs {
	res := make(TableExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneTableExpr(x))
	}
	return res
}

// EqualsTableExprs does deep equals between the two objects.
func EqualsTableExprs(a, b TableExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsTableExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneTableIdent creates a deep clone of the input.
func CloneTableIdent(n TableIdent) TableIdent {
	return *CloneRefOfTableIdent(&n)
}

// EqualsTableIdent does deep equals between the two objects.
func EqualsTableIdent(a, b TableIdent) bool {
	return a.v == b.v
}

// CloneTableName creates a deep clone of the input.
func CloneTableName(n TableName) TableName {
	return *CloneRefOfTableName(&n)
}

// EqualsTableName does deep equals between the two objects.
func EqualsTableName(a, b TableName) bool {
	return EqualsTableIdent(a.Name, b.Name) &&
		EqualsTableIdent(a.Qualifier, b.Qualifier)
}

// CloneTableNames creates a deep clone of the input.
func CloneTableNames(n TableNames) TableNames {
	res := make(TableNames, 0, len(n))
	for _, x := range n {
		res = append(res, CloneTableName(x))
	}
	return res
}

// EqualsTableNames does deep equals between the two objects.
func EqualsTableNames(a, b TableNames) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsTableName(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfTableSpec creates a deep clone of the input.
func CloneRefOfTableSpec(n *TableSpec) *TableSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Columns = CloneSliceOfRefOfColumnDefinition(n.Columns)
	out.Indexes = CloneSliceOfRefOfIndexDefinition(n.Indexes)
	out.Constraints = CloneSliceOfRefOfConstraintDefinition(n.Constraints)
	out.Options = CloneTableOptions(n.Options)
	return &out
}

// EqualsRefOfTableSpec does deep equals between the two objects.
func EqualsRefOfTableSpec(a, b *TableSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsSliceOfRefOfColumnDefinition(a.Columns, b.Columns) &&
		EqualsSliceOfRefOfIndexDefinition(a.Indexes, b.Indexes) &&
		EqualsSliceOfRefOfConstraintDefinition(a.Constraints, b.Constraints) &&
		EqualsTableOptions(a.Options, b.Options)
}

// CloneRefOfUnionSelect creates a deep clone of the input.
func CloneRefOfUnionSelect(n *UnionSelect) *UnionSelect {
	if n == nil {
		return nil
	}
	out := *n
	out.Statement = CloneSelectStatement(n.Statement)
	return &out
}

// EqualsRefOfUnionSelect does deep equals between the two objects.
func EqualsRefOfUnionSelect(a, b *UnionSelect) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Distinct == b.Distinct &&
		EqualsSelectStatement(a.Statement, b.Statement)
}

// CloneRefOfUnlockTables creates a deep clone of the input.
func CloneRefOfUnlockTables(n *UnlockTables) *UnlockTables {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfUnlockTables does deep equals between the two objects.
func EqualsRefOfUnlockTables(a, b *UnlockTables) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return true
}

// CloneRefOfUpdate creates a deep clone of the input.
func CloneRefOfUpdate(n *Update) *Update {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.TableExprs = CloneTableExprs(n.TableExprs)
	out.Exprs = CloneUpdateExprs(n.Exprs)
	out.Where = CloneRefOfWhere(n.Where)
	out.OrderBy = CloneOrderBy(n.OrderBy)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// EqualsRefOfUpdate does deep equals between the two objects.
func EqualsRefOfUpdate(a, b *Update) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments) &&
		a.Ignore == b.Ignore &&
		EqualsTableExprs(a.TableExprs, b.TableExprs) &&
		EqualsUpdateExprs(a.Exprs, b.Exprs) &&
		EqualsRefOfWhere(a.Where, b.Where) &&
		EqualsOrderBy(a.OrderBy, b.OrderBy) &&
		EqualsRefOfLimit(a.Limit, b.Limit)
}

// CloneRefOfUpdateExpr creates a deep clone of the input.
func CloneRefOfUpdateExpr(n *UpdateExpr) *UpdateExpr {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneRefOfColName(n.Name)
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfUpdateExpr does deep equals between the two objects.
func EqualsRefOfUpdateExpr(a, b *UpdateExpr) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsRefOfColName(a.Name, b.Name) &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneUpdateExprs creates a deep clone of the input.
func CloneUpdateExprs(n UpdateExprs) UpdateExprs {
	res := make(UpdateExprs, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfUpdateExpr(x))
	}
	return res
}

// EqualsUpdateExprs does deep equals between the two objects.
func EqualsUpdateExprs(a, b UpdateExprs) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfUpdateExpr(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfUse creates a deep clone of the input.
func CloneRefOfUse(n *Use) *Use {
	if n == nil {
		return nil
	}
	out := *n
	out.DBName = CloneTableIdent(n.DBName)
	return &out
}

// EqualsRefOfUse does deep equals between the two objects.
func EqualsRefOfUse(a, b *Use) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableIdent(a.DBName, b.DBName)
}

// CloneRefOfVStream creates a deep clone of the input.
func CloneRefOfVStream(n *VStream) *VStream {
	if n == nil {
		return nil
	}
	out := *n
	out.Comments = CloneComments(n.Comments)
	out.SelectExpr = CloneSelectExpr(n.SelectExpr)
	out.Table = CloneTableName(n.Table)
	out.Where = CloneRefOfWhere(n.Where)
	out.Limit = CloneRefOfLimit(n.Limit)
	return &out
}

// EqualsRefOfVStream does deep equals between the two objects.
func EqualsRefOfVStream(a, b *VStream) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsComments(a.Comments, b.Comments) &&
		EqualsSelectExpr(a.SelectExpr, b.SelectExpr) &&
		EqualsTableName(a.Table, b.Table) &&
		EqualsRefOfWhere(a.Where, b.Where) &&
		EqualsRefOfLimit(a.Limit, b.Limit)
}

// CloneVindexParam creates a deep clone of the input.
func CloneVindexParam(n VindexParam) VindexParam {
	return *CloneRefOfVindexParam(&n)
}

// EqualsVindexParam does deep equals between the two objects.
func EqualsVindexParam(a, b VindexParam) bool {
	return a.Val == b.Val &&
		EqualsColIdent(a.Key, b.Key)
}

// CloneRefOfVindexSpec creates a deep clone of the input.
func CloneRefOfVindexSpec(n *VindexSpec) *VindexSpec {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneColIdent(n.Name)
	out.Type = CloneColIdent(n.Type)
	out.Params = CloneSliceOfVindexParam(n.Params)
	return &out
}

// EqualsRefOfVindexSpec does deep equals between the two objects.
func EqualsRefOfVindexSpec(a, b *VindexSpec) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Name, b.Name) &&
		EqualsColIdent(a.Type, b.Type) &&
		EqualsSliceOfVindexParam(a.Params, b.Params)
}

// CloneRefOfWhen creates a deep clone of the input.
func CloneRefOfWhen(n *When) *When {
	if n == nil {
		return nil
	}
	out := *n
	out.Cond = CloneExpr(n.Cond)
	out.Val = CloneExpr(n.Val)
	return &out
}

// EqualsRefOfWhen does deep equals between the two objects.
func EqualsRefOfWhen(a, b *When) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.Cond, b.Cond) &&
		EqualsExpr(a.Val, b.Val)
}

// CloneRefOfWhere creates a deep clone of the input.
func CloneRefOfWhere(n *Where) *Where {
	if n == nil {
		return nil
	}
	out := *n
	out.Expr = CloneExpr(n.Expr)
	return &out
}

// EqualsRefOfWhere does deep equals between the two objects.
func EqualsRefOfWhere(a, b *Where) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Type == b.Type &&
		EqualsExpr(a.Expr, b.Expr)
}

// CloneSliceOfRefOfColumnDefinition creates a deep clone of the input.
func CloneSliceOfRefOfColumnDefinition(n []*ColumnDefinition) []*ColumnDefinition {
	res := make([]*ColumnDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfColumnDefinition(x))
	}
	return res
}

// EqualsSliceOfRefOfColumnDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfColumnDefinition(a, b []*ColumnDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfColumnDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfTableOption creates a deep clone of the input.
func CloneRefOfTableOption(n *TableOption) *TableOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = CloneRefOfLiteral(n.Value)
	out.Tables = CloneTableNames(n.Tables)
	return &out
}

// EqualsRefOfTableOption does deep equals between the two objects.
func EqualsRefOfTableOption(a, b *TableOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		EqualsRefOfLiteral(a.Value, b.Value) &&
		EqualsTableNames(a.Tables, b.Tables)
}

// CloneSliceOfCollateAndCharset creates a deep clone of the input.
func CloneSliceOfCollateAndCharset(n []CollateAndCharset) []CollateAndCharset {
	res := make([]CollateAndCharset, 0, len(n))
	for _, x := range n {
		res = append(res, CloneCollateAndCharset(x))
	}
	return res
}

// EqualsSliceOfCollateAndCharset does deep equals between the two objects.
func EqualsSliceOfCollateAndCharset(a, b []CollateAndCharset) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsCollateAndCharset(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfAlterOption creates a deep clone of the input.
func CloneSliceOfAlterOption(n []AlterOption) []AlterOption {
	res := make([]AlterOption, 0, len(n))
	for _, x := range n {
		res = append(res, CloneAlterOption(x))
	}
	return res
}

// EqualsSliceOfAlterOption does deep equals between the two objects.
func EqualsSliceOfAlterOption(a, b []AlterOption) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsAlterOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfRenameTablePair creates a deep clone of the input.
func CloneSliceOfRefOfRenameTablePair(n []*RenameTablePair) []*RenameTablePair {
	res := make([]*RenameTablePair, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfRenameTablePair(x))
	}
	return res
}

// EqualsSliceOfRefOfRenameTablePair does deep equals between the two objects.
func EqualsSliceOfRefOfRenameTablePair(a, b []*RenameTablePair) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfRenameTablePair(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfWhen creates a deep clone of the input.
func CloneSliceOfRefOfWhen(n []*When) []*When {
	res := make([]*When, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfWhen(x))
	}
	return res
}

// EqualsSliceOfRefOfWhen does deep equals between the two objects.
func EqualsSliceOfRefOfWhen(a, b []*When) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfWhen(a[i], b[i]) {
			return false
		}
	}
	return true
}

// EqualsRefOfBool does deep equals between the two objects.
func EqualsRefOfBool(a, b *bool) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return *a == *b
}

// CloneRefOfBool creates a deep clone of the input.
func CloneRefOfBool(n *bool) *bool {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// CloneSliceOfRefOfUnionSelect creates a deep clone of the input.
func CloneSliceOfRefOfUnionSelect(n []*UnionSelect) []*UnionSelect {
	res := make([]*UnionSelect, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfUnionSelect(x))
	}
	return res
}

// EqualsSliceOfRefOfUnionSelect does deep equals between the two objects.
func EqualsSliceOfRefOfUnionSelect(a, b []*UnionSelect) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfUnionSelect(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfColIdent creates a deep clone of the input.
func CloneSliceOfColIdent(n []ColIdent) []ColIdent {
	res := make([]ColIdent, 0, len(n))
	for _, x := range n {
		res = append(res, CloneColIdent(x))
	}
	return res
}

// EqualsSliceOfColIdent does deep equals between the two objects.
func EqualsSliceOfColIdent(a, b []ColIdent) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsColIdent(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfColIdent creates a deep clone of the input.
func CloneRefOfColIdent(n *ColIdent) *ColIdent {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfColIdent does deep equals between the two objects.
func EqualsRefOfColIdent(a, b *ColIdent) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.val == b.val &&
		a.lowered == b.lowered &&
		a.at == b.at
}

// CloneColumnType creates a deep clone of the input.
func CloneColumnType(n ColumnType) ColumnType {
	return *CloneRefOfColumnType(&n)
}

// EqualsColumnType does deep equals between the two objects.
func EqualsColumnType(a, b ColumnType) bool {
	return a.Type == b.Type &&
		a.Unsigned == b.Unsigned &&
		a.Zerofill == b.Zerofill &&
		a.Charset == b.Charset &&
		a.Collate == b.Collate &&
		EqualsRefOfColumnTypeOptions(a.Options, b.Options) &&
		EqualsRefOfLiteral(a.Length, b.Length) &&
		EqualsRefOfLiteral(a.Scale, b.Scale) &&
		EqualsSliceOfString(a.EnumValues, b.EnumValues)
}

// CloneRefOfColumnTypeOptions creates a deep clone of the input.
func CloneRefOfColumnTypeOptions(n *ColumnTypeOptions) *ColumnTypeOptions {
	if n == nil {
		return nil
	}
	out := *n
	out.Default = CloneExpr(n.Default)
	out.OnUpdate = CloneExpr(n.OnUpdate)
	out.Comment = CloneRefOfLiteral(n.Comment)
	return &out
}

// EqualsRefOfColumnTypeOptions does deep equals between the two objects.
func EqualsRefOfColumnTypeOptions(a, b *ColumnTypeOptions) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.NotNull == b.NotNull &&
		a.Autoincrement == b.Autoincrement &&
		EqualsExpr(a.Default, b.Default) &&
		EqualsExpr(a.OnUpdate, b.OnUpdate) &&
		EqualsRefOfLiteral(a.Comment, b.Comment) &&
		a.KeyOpt == b.KeyOpt
}

// CloneSliceOfString creates a deep clone of the input.
func CloneSliceOfString(n []string) []string {
	res := make([]string, 0, len(n))
	copy(res, n)
	return res
}

// EqualsSliceOfString does deep equals between the two objects.
func EqualsSliceOfString(a, b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfIndexColumn creates a deep clone of the input.
func CloneSliceOfRefOfIndexColumn(n []*IndexColumn) []*IndexColumn {
	res := make([]*IndexColumn, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexColumn(x))
	}
	return res
}

// EqualsSliceOfRefOfIndexColumn does deep equals between the two objects.
func EqualsSliceOfRefOfIndexColumn(a, b []*IndexColumn) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexColumn(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfIndexOption creates a deep clone of the input.
func CloneSliceOfRefOfIndexOption(n []*IndexOption) []*IndexOption {
	res := make([]*IndexOption, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexOption(x))
	}
	return res
}

// EqualsSliceOfRefOfIndexOption does deep equals between the two objects.
func EqualsSliceOfRefOfIndexOption(a, b []*IndexOption) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexOption(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfJoinCondition creates a deep clone of the input.
func CloneRefOfJoinCondition(n *JoinCondition) *JoinCondition {
	if n == nil {
		return nil
	}
	out := *n
	out.On = CloneExpr(n.On)
	out.Using = CloneColumns(n.Using)
	return &out
}

// EqualsRefOfJoinCondition does deep equals between the two objects.
func EqualsRefOfJoinCondition(a, b *JoinCondition) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsExpr(a.On, b.On) &&
		EqualsColumns(a.Using, b.Using)
}

// CloneTableAndLockTypes creates a deep clone of the input.
func CloneTableAndLockTypes(n TableAndLockTypes) TableAndLockTypes {
	res := make(TableAndLockTypes, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfTableAndLockType(x))
	}
	return res
}

// EqualsTableAndLockTypes does deep equals between the two objects.
func EqualsTableAndLockTypes(a, b TableAndLockTypes) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfTableAndLockType(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfPartitionDefinition creates a deep clone of the input.
func CloneSliceOfRefOfPartitionDefinition(n []*PartitionDefinition) []*PartitionDefinition {
	res := make([]*PartitionDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfPartitionDefinition(x))
	}
	return res
}

// EqualsSliceOfRefOfPartitionDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfPartitionDefinition(a, b []*PartitionDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfPartitionDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfCharacteristic creates a deep clone of the input.
func CloneSliceOfCharacteristic(n []Characteristic) []Characteristic {
	res := make([]Characteristic, 0, len(n))
	for _, x := range n {
		res = append(res, CloneCharacteristic(x))
	}
	return res
}

// EqualsSliceOfCharacteristic does deep equals between the two objects.
func EqualsSliceOfCharacteristic(a, b []Characteristic) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsCharacteristic(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfShowTablesOpt creates a deep clone of the input.
func CloneRefOfShowTablesOpt(n *ShowTablesOpt) *ShowTablesOpt {
	if n == nil {
		return nil
	}
	out := *n
	out.Filter = CloneRefOfShowFilter(n.Filter)
	return &out
}

// EqualsRefOfShowTablesOpt does deep equals between the two objects.
func EqualsRefOfShowTablesOpt(a, b *ShowTablesOpt) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Full == b.Full &&
		a.DbName == b.DbName &&
		EqualsRefOfShowFilter(a.Filter, b.Filter)
}

// CloneRefOfTableIdent creates a deep clone of the input.
func CloneRefOfTableIdent(n *TableIdent) *TableIdent {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfTableIdent does deep equals between the two objects.
func EqualsRefOfTableIdent(a, b *TableIdent) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.v == b.v
}

// CloneRefOfTableName creates a deep clone of the input.
func CloneRefOfTableName(n *TableName) *TableName {
	if n == nil {
		return nil
	}
	out := *n
	out.Name = CloneTableIdent(n.Name)
	out.Qualifier = CloneTableIdent(n.Qualifier)
	return &out
}

// EqualsRefOfTableName does deep equals between the two objects.
func EqualsRefOfTableName(a, b *TableName) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableIdent(a.Name, b.Name) &&
		EqualsTableIdent(a.Qualifier, b.Qualifier)
}

// CloneSliceOfRefOfIndexDefinition creates a deep clone of the input.
func CloneSliceOfRefOfIndexDefinition(n []*IndexDefinition) []*IndexDefinition {
	res := make([]*IndexDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfIndexDefinition(x))
	}
	return res
}

// EqualsSliceOfRefOfIndexDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfIndexDefinition(a, b []*IndexDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfIndexDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneSliceOfRefOfConstraintDefinition creates a deep clone of the input.
func CloneSliceOfRefOfConstraintDefinition(n []*ConstraintDefinition) []*ConstraintDefinition {
	res := make([]*ConstraintDefinition, 0, len(n))
	for _, x := range n {
		res = append(res, CloneRefOfConstraintDefinition(x))
	}
	return res
}

// EqualsSliceOfRefOfConstraintDefinition does deep equals between the two objects.
func EqualsSliceOfRefOfConstraintDefinition(a, b []*ConstraintDefinition) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsRefOfConstraintDefinition(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneRefOfVindexParam creates a deep clone of the input.
func CloneRefOfVindexParam(n *VindexParam) *VindexParam {
	if n == nil {
		return nil
	}
	out := *n
	out.Key = CloneColIdent(n.Key)
	return &out
}

// EqualsRefOfVindexParam does deep equals between the two objects.
func EqualsRefOfVindexParam(a, b *VindexParam) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Val == b.Val &&
		EqualsColIdent(a.Key, b.Key)
}

// CloneSliceOfVindexParam creates a deep clone of the input.
func CloneSliceOfVindexParam(n []VindexParam) []VindexParam {
	res := make([]VindexParam, 0, len(n))
	for _, x := range n {
		res = append(res, CloneVindexParam(x))
	}
	return res
}

// EqualsSliceOfVindexParam does deep equals between the two objects.
func EqualsSliceOfVindexParam(a, b []VindexParam) bool {
	if len(a) != len(b) {
		return false
	}
	for i := 0; i < len(a); i++ {
		if !EqualsVindexParam(a[i], b[i]) {
			return false
		}
	}
	return true
}

// CloneCollateAndCharset creates a deep clone of the input.
func CloneCollateAndCharset(n CollateAndCharset) CollateAndCharset {
	return *CloneRefOfCollateAndCharset(&n)
}

// EqualsCollateAndCharset does deep equals between the two objects.
func EqualsCollateAndCharset(a, b CollateAndCharset) bool {
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}

// CloneRefOfRenameTablePair creates a deep clone of the input.
func CloneRefOfRenameTablePair(n *RenameTablePair) *RenameTablePair {
	if n == nil {
		return nil
	}
	out := *n
	out.FromTable = CloneTableName(n.FromTable)
	out.ToTable = CloneTableName(n.ToTable)
	return &out
}

// EqualsRefOfRenameTablePair does deep equals between the two objects.
func EqualsRefOfRenameTablePair(a, b *RenameTablePair) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableName(a.FromTable, b.FromTable) &&
		EqualsTableName(a.ToTable, b.ToTable)
}

// CloneRefOfIndexColumn creates a deep clone of the input.
func CloneRefOfIndexColumn(n *IndexColumn) *IndexColumn {
	if n == nil {
		return nil
	}
	out := *n
	out.Column = CloneColIdent(n.Column)
	out.Length = CloneRefOfLiteral(n.Length)
	return &out
}

// EqualsRefOfIndexColumn does deep equals between the two objects.
func EqualsRefOfIndexColumn(a, b *IndexColumn) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsColIdent(a.Column, b.Column) &&
		EqualsRefOfLiteral(a.Length, b.Length) &&
		a.Direction == b.Direction
}

// CloneRefOfIndexOption creates a deep clone of the input.
func CloneRefOfIndexOption(n *IndexOption) *IndexOption {
	if n == nil {
		return nil
	}
	out := *n
	out.Value = CloneRefOfLiteral(n.Value)
	return &out
}

// EqualsRefOfIndexOption does deep equals between the two objects.
func EqualsRefOfIndexOption(a, b *IndexOption) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.Name == b.Name &&
		a.String == b.String &&
		EqualsRefOfLiteral(a.Value, b.Value)
}

// CloneRefOfTableAndLockType creates a deep clone of the input.
func CloneRefOfTableAndLockType(n *TableAndLockType) *TableAndLockType {
	if n == nil {
		return nil
	}
	out := *n
	out.Table = CloneTableExpr(n.Table)
	return &out
}

// EqualsRefOfTableAndLockType does deep equals between the two objects.
func EqualsRefOfTableAndLockType(a, b *TableAndLockType) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return EqualsTableExpr(a.Table, b.Table) &&
		a.Lock == b.Lock
}

// CloneRefOfCollateAndCharset creates a deep clone of the input.
func CloneRefOfCollateAndCharset(n *CollateAndCharset) *CollateAndCharset {
	if n == nil {
		return nil
	}
	out := *n
	return &out
}

// EqualsRefOfCollateAndCharset does deep equals between the two objects.
func EqualsRefOfCollateAndCharset(a, b *CollateAndCharset) bool {
	if a == b {
		return true
	}
	if a == nil || b == nil {
		return false
	}
	return a.IsDefault == b.IsDefault &&
		a.Value == b.Value &&
		a.Type == b.Type
}
