// Code generated by protoc-gen-go. DO NOT EDIT.
// source: vtctlservice.proto

package vtctlservice

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	vtctldata "vitess.io/vitess/go/vt/proto/vtctldata"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("vtctlservice.proto", fileDescriptor_27055cdbb1148d2b) }

var fileDescriptor_27055cdbb1148d2b = []byte{
	// 263 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xdf, 0x4b, 0xc3, 0x30,
	0x10, 0xc7, 0x55, 0x70, 0x0f, 0x71, 0xa0, 0x9c, 0x0f, 0xc2, 0x40, 0x85, 0x89, 0xc2, 0x14, 0x1a,
	0x99, 0x7f, 0x81, 0x8a, 0xca, 0x10, 0xc4, 0x1f, 0xe0, 0x83, 0xe0, 0x43, 0x6c, 0x0e, 0x17, 0x68,
	0x93, 0x2e, 0x77, 0x2b, 0xee, 0x9f, 0x17, 0x31, 0x25, 0x35, 0x88, 0x55, 0xdf, 0x7a, 0xdf, 0x1f,
	0x9f, 0x6b, 0xe0, 0x04, 0xd4, 0x9c, 0x73, 0x41, 0xe8, 0x6b, 0x93, 0x63, 0x56, 0x79, 0xc7, 0x0e,
	0xfa, 0xa9, 0x36, 0x58, 0x0f, 0x93, 0x56, 0xac, 0x1a, 0x7b, 0x3c, 0x13, 0xab, 0x8f, 0x9f, 0x12,
	0x4c, 0xc5, 0xe6, 0xc5, 0x1b, 0xe6, 0x73, 0xc6, 0x30, 0x9f, 0xbb, 0xb2, 0x54, 0x56, 0xc3, 0x7e,
	0xf6, 0xd5, 0xf8, 0xc1, 0xbf, 0xc7, 0xd9, 0x1c, 0x89, 0x07, 0x07, 0x7f, 0xc5, 0xa8, 0x72, 0x96,
	0x70, 0xb8, 0x74, 0xbc, 0x3c, 0x7e, 0x5f, 0x11, 0xbd, 0x60, 0x6a, 0xf0, 0x62, 0xeb, 0xd2, 0x58,
	0x7d, 0x5a, 0x14, 0x0f, 0x53, 0xe5, 0x35, 0x4d, 0xec, 0x35, 0x2e, 0xa8, 0x52, 0x39, 0xc2, 0x28,
	0x21, 0x76, 0x64, 0xe2, 0xf2, 0xc3, 0xff, 0x44, 0xe3, 0x0f, 0xc0, 0x8d, 0x58, 0xbb, 0x42, 0x6e,
	0xf7, 0x6c, 0x27, 0xe5, 0x44, 0x8f, 0xec, 0x9d, 0x2e, 0xbb, 0xe5, 0xdd, 0x89, 0x7e, 0x62, 0x10,
	0x74, 0x34, 0x28, 0x12, 0x77, 0x3b, 0xfd, 0x16, 0xf9, 0x2c, 0x36, 0x26, 0xd6, 0x70, 0x78, 0xc4,
	0xad, 0x37, 0xa5, 0xf2, 0x0b, 0x18, 0x26, 0xb5, 0xef, 0x66, 0x44, 0xef, 0xfd, 0x9a, 0x89, 0xf8,
	0xb3, 0xa3, 0xa7, 0x51, 0x6d, 0x18, 0x89, 0x32, 0xe3, 0x64, 0xf3, 0x25, 0x5f, 0x9d, 0xac, 0x59,
	0x86, 0x9b, 0x90, 0xe9, 0xc5, 0xbc, 0xf4, 0x82, 0x76, 0xf2, 0x11, 0x00, 0x00, 0xff, 0xff, 0xae,
	0x74, 0xb6, 0x52, 0x5c, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// VtctlClient is the client API for Vtctl service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VtctlClient interface {
	ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error)
}

type vtctlClient struct {
	cc *grpc.ClientConn
}

func NewVtctlClient(cc *grpc.ClientConn) VtctlClient {
	return &vtctlClient{cc}
}

func (c *vtctlClient) ExecuteVtctlCommand(ctx context.Context, in *vtctldata.ExecuteVtctlCommandRequest, opts ...grpc.CallOption) (Vtctl_ExecuteVtctlCommandClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Vtctl_serviceDesc.Streams[0], "/vtctlservice.Vtctl/ExecuteVtctlCommand", opts...)
	if err != nil {
		return nil, err
	}
	x := &vtctlExecuteVtctlCommandClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Vtctl_ExecuteVtctlCommandClient interface {
	Recv() (*vtctldata.ExecuteVtctlCommandResponse, error)
	grpc.ClientStream
}

type vtctlExecuteVtctlCommandClient struct {
	grpc.ClientStream
}

func (x *vtctlExecuteVtctlCommandClient) Recv() (*vtctldata.ExecuteVtctlCommandResponse, error) {
	m := new(vtctldata.ExecuteVtctlCommandResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// VtctlServer is the server API for Vtctl service.
type VtctlServer interface {
	ExecuteVtctlCommand(*vtctldata.ExecuteVtctlCommandRequest, Vtctl_ExecuteVtctlCommandServer) error
}

// UnimplementedVtctlServer can be embedded to have forward compatible implementations.
type UnimplementedVtctlServer struct {
}

func (*UnimplementedVtctlServer) ExecuteVtctlCommand(req *vtctldata.ExecuteVtctlCommandRequest, srv Vtctl_ExecuteVtctlCommandServer) error {
	return status.Errorf(codes.Unimplemented, "method ExecuteVtctlCommand not implemented")
}

func RegisterVtctlServer(s *grpc.Server, srv VtctlServer) {
	s.RegisterService(&_Vtctl_serviceDesc, srv)
}

func _Vtctl_ExecuteVtctlCommand_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtctldata.ExecuteVtctlCommandRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VtctlServer).ExecuteVtctlCommand(m, &vtctlExecuteVtctlCommandServer{stream})
}

type Vtctl_ExecuteVtctlCommandServer interface {
	Send(*vtctldata.ExecuteVtctlCommandResponse) error
	grpc.ServerStream
}

type vtctlExecuteVtctlCommandServer struct {
	grpc.ServerStream
}

func (x *vtctlExecuteVtctlCommandServer) Send(m *vtctldata.ExecuteVtctlCommandResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Vtctl_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctl",
	HandlerType: (*VtctlServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ExecuteVtctlCommand",
			Handler:       _Vtctl_ExecuteVtctlCommand_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "vtctlservice.proto",
}

// VtctldClient is the client API for Vtctld service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type VtctldClient interface {
	// FindAllShardsInKeyspace returns a map of shard names to shard references for a given keyspace.
	FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error)
}

type vtctldClient struct {
	cc *grpc.ClientConn
}

func NewVtctldClient(cc *grpc.ClientConn) VtctldClient {
	return &vtctldClient{cc}
}

func (c *vtctldClient) FindAllShardsInKeyspace(ctx context.Context, in *vtctldata.FindAllShardsInKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	out := new(vtctldata.FindAllShardsInKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/FindAllShardsInKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspace(ctx context.Context, in *vtctldata.GetKeyspaceRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspaceResponse, error) {
	out := new(vtctldata.GetKeyspaceResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) GetKeyspaces(ctx context.Context, in *vtctldata.GetKeyspacesRequest, opts ...grpc.CallOption) (*vtctldata.GetKeyspacesResponse, error) {
	out := new(vtctldata.GetKeyspacesResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/GetKeyspaces", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vtctldClient) InitShardPrimary(ctx context.Context, in *vtctldata.InitShardPrimaryRequest, opts ...grpc.CallOption) (*vtctldata.InitShardPrimaryResponse, error) {
	out := new(vtctldata.InitShardPrimaryResponse)
	err := c.cc.Invoke(ctx, "/vtctlservice.Vtctld/InitShardPrimary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VtctldServer is the server API for Vtctld service.
type VtctldServer interface {
	// FindAllShardsInKeyspace returns a map of shard names to shard references for a given keyspace.
	FindAllShardsInKeyspace(context.Context, *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error)
	// GetKeyspace reads the given keyspace from the topo and returns it.
	GetKeyspace(context.Context, *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error)
	// GetKeyspaces returns the keyspace struct of all keyspaces in the topo.
	GetKeyspaces(context.Context, *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error)
	// InitShardPrimary sets the initial primary for a shard. Will make all other
	// tablets in the shard replicas of the provided primary.
	//
	// WARNING: This could cause data loss on an already replicating shard.
	// PlannedReparentShard or EmergencyReparentShard should be used in those
	// cases instead.
	InitShardPrimary(context.Context, *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error)
}

// UnimplementedVtctldServer can be embedded to have forward compatible implementations.
type UnimplementedVtctldServer struct {
}

func (*UnimplementedVtctldServer) FindAllShardsInKeyspace(ctx context.Context, req *vtctldata.FindAllShardsInKeyspaceRequest) (*vtctldata.FindAllShardsInKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindAllShardsInKeyspace not implemented")
}
func (*UnimplementedVtctldServer) GetKeyspace(ctx context.Context, req *vtctldata.GetKeyspaceRequest) (*vtctldata.GetKeyspaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspace not implemented")
}
func (*UnimplementedVtctldServer) GetKeyspaces(ctx context.Context, req *vtctldata.GetKeyspacesRequest) (*vtctldata.GetKeyspacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyspaces not implemented")
}
func (*UnimplementedVtctldServer) InitShardPrimary(ctx context.Context, req *vtctldata.InitShardPrimaryRequest) (*vtctldata.InitShardPrimaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitShardPrimary not implemented")
}

func RegisterVtctldServer(s *grpc.Server, srv VtctldServer) {
	s.RegisterService(&_Vtctld_serviceDesc, srv)
}

func _Vtctld_FindAllShardsInKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.FindAllShardsInKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/FindAllShardsInKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).FindAllShardsInKeyspace(ctx, req.(*vtctldata.FindAllShardsInKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspace(ctx, req.(*vtctldata.GetKeyspaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_GetKeyspaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.GetKeyspacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).GetKeyspaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/GetKeyspaces",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).GetKeyspaces(ctx, req.(*vtctldata.GetKeyspacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Vtctld_InitShardPrimary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(vtctldata.InitShardPrimaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VtctldServer).InitShardPrimary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vtctlservice.Vtctld/InitShardPrimary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VtctldServer).InitShardPrimary(ctx, req.(*vtctldata.InitShardPrimaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Vtctld_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtctlservice.Vtctld",
	HandlerType: (*VtctldServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "FindAllShardsInKeyspace",
			Handler:    _Vtctld_FindAllShardsInKeyspace_Handler,
		},
		{
			MethodName: "GetKeyspace",
			Handler:    _Vtctld_GetKeyspace_Handler,
		},
		{
			MethodName: "GetKeyspaces",
			Handler:    _Vtctld_GetKeyspaces_Handler,
		},
		{
			MethodName: "InitShardPrimary",
			Handler:    _Vtctld_InitShardPrimary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vtctlservice.proto",
}
