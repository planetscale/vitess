// Code generated by protoc-gen-go. DO NOT EDIT.
// source: queryservice.proto

package queryservice

import (
	context "context"
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	binlogdata "vitess.io/vitess/go/vt/proto/binlogdata"
	query "vitess.io/vitess/go/vt/proto/query"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

func init() { proto.RegisterFile("queryservice.proto", fileDescriptor_4bd2dde8711f22e3) }

var fileDescriptor_4bd2dde8711f22e3 = []byte{
	// 584 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0xfd, 0xbe, 0x8b, 0xb6, 0x68, 0x1a, 0x42, 0xd9, 0x52, 0xa0, 0x4e, 0x08, 0x24, 0x77, 0x08,
	0x29, 0x41, 0x80, 0x84, 0x54, 0x89, 0x8b, 0x26, 0xa2, 0x02, 0x21, 0xfe, 0x5c, 0xa8, 0x10, 0x48,
	0x48, 0x1b, 0x67, 0x14, 0xac, 0x3a, 0xde, 0xd4, 0xbb, 0x49, 0xe1, 0x71, 0x78, 0x53, 0x14, 0xdb,
	0x33, 0xde, 0xdd, 0x38, 0xb9, 0xeb, 0x9c, 0x33, 0x73, 0x3a, 0x9e, 0xc9, 0x99, 0x05, 0x71, 0xb5,
	0xc0, 0xec, 0x8f, 0xc6, 0x6c, 0x19, 0x47, 0xd8, 0x9f, 0x67, 0xca, 0x28, 0xd1, 0xb0, 0xb1, 0x60,
	0x3f, 0x8f, 0x0a, 0x2a, 0x38, 0x18, 0xc7, 0x69, 0xa2, 0xa6, 0x13, 0x69, 0x64, 0x81, 0x3c, 0xfb,
	0xdb, 0x84, 0x9d, 0xcf, 0xab, 0x0c, 0x71, 0x02, 0x7b, 0xaf, 0x7f, 0x63, 0xb4, 0x30, 0x28, 0x8e,
	0xfa, 0x45, 0x51, 0x19, 0x87, 0x78, 0xb5, 0x40, 0x6d, 0x82, 0xbb, 0x3e, 0xac, 0xe7, 0x2a, 0xd5,
	0xd8, 0xfb, 0x4f, 0xbc, 0x85, 0x46, 0x09, 0x0e, 0xa5, 0x89, 0x7e, 0x89, 0xc0, 0xcd, 0xcc, 0x41,
	0x52, 0x69, 0xd5, 0x72, 0x2c, 0xf5, 0x01, 0x6e, 0x9e, 0x9b, 0x0c, 0xe5, 0x8c, 0x9a, 0xa1, 0x7c,
	0x07, 0x25, 0xb1, 0x76, 0x3d, 0x49, 0x6a, 0x4f, 0xff, 0x17, 0x2f, 0x60, 0x67, 0x88, 0xd3, 0x38,
	0x15, 0x87, 0x65, 0x6a, 0x1e, 0x51, 0xfd, 0x1d, 0x17, 0xe4, 0x2e, 0x5e, 0xc2, 0xee, 0x48, 0xcd,
	0x66, 0xb1, 0x11, 0x94, 0x51, 0x84, 0x54, 0x77, 0xe4, 0xa1, 0x5c, 0xf8, 0x0a, 0x6e, 0x84, 0x2a,
	0x49, 0xc6, 0x32, 0xba, 0x14, 0x34, 0x2f, 0x02, 0xa8, 0xf8, 0xde, 0x1a, 0xce, 0xe5, 0x27, 0xb0,
	0xf7, 0x29, 0xc3, 0xb9, 0xcc, 0xaa, 0x25, 0x94, 0xb1, 0xbf, 0x04, 0x86, 0xb9, 0xf6, 0x23, 0x34,
	0x8b, 0x76, 0x4a, 0x6a, 0x22, 0xda, 0x4e, 0x97, 0x04, 0x93, 0xd2, 0x83, 0x0d, 0x2c, 0x0b, 0x7e,
	0x85, 0x03, 0x6a, 0x91, 0x25, 0x3b, 0x5e, 0xef, 0xbe, 0xe8, 0xc3, 0x8d, 0x3c, 0xcb, 0x7e, 0x83,
	0xdb, 0xa3, 0x0c, 0xa5, 0xc1, 0x2f, 0x99, 0x4c, 0xb5, 0x8c, 0x4c, 0xac, 0x52, 0x41, 0x75, 0x6b,
	0x0c, 0x09, 0x3f, 0xda, 0x9c, 0xc0, 0xca, 0x67, 0xb0, 0x7f, 0x6e, 0x64, 0x66, 0xca, 0xd5, 0x1d,
	0xf3, 0x8f, 0x83, 0x31, 0x52, 0x0b, 0xea, 0x28, 0x47, 0x07, 0x0d, 0xef, 0x91, 0x75, 0x2a, 0x6c,
	0x4d, 0xc7, 0xa6, 0x58, 0xe7, 0x27, 0x1c, 0x8e, 0x54, 0x1a, 0x25, 0x8b, 0x89, 0xf3, 0xad, 0x5d,
	0x1e, 0xfc, 0x1a, 0x47, 0xba, 0xbd, 0x6d, 0x29, 0xac, 0x1f, 0xc2, 0xad, 0x10, 0xe5, 0xc4, 0xd6,
	0xa6, 0xa5, 0x7a, 0x38, 0xe9, 0x76, 0x36, 0xd1, 0xb6, 0x95, 0x73, 0x33, 0x90, 0xfd, 0x02, 0xdb,
	0x21, 0x9e, 0xfb, 0x5a, 0xb5, 0x9c, 0x6d, 0xe5, 0xf7, 0xa8, 0xb5, 0x9c, 0x62, 0x61, 0x4f, 0xb6,
	0xb2, 0x83, 0xfa, 0x56, 0xf6, 0x48, 0xcb, 0xca, 0x23, 0x80, 0x92, 0x3c, 0x8d, 0x2e, 0xc5, 0x7d,
	0x37, 0xff, 0xb4, 0x5a, 0xca, 0x71, 0x0d, 0x63, 0xbb, 0x24, 0xc4, 0xd5, 0x71, 0x44, 0xfa, 0xc2,
	0x36, 0xcf, 0xc4, 0x86, 0x7d, 0x97, 0xf8, 0xac, 0xbd, 0xe4, 0x92, 0x73, 0xe6, 0xd6, 0x75, 0xeb,
	0xea, 0xc6, 0xd7, 0xdb, 0x96, 0x62, 0x9f, 0x84, 0x10, 0x13, 0x94, 0xba, 0x3a, 0x09, 0x65, 0xec,
	0x9f, 0x04, 0x86, 0xb9, 0xf6, 0x1d, 0x34, 0x8a, 0x39, 0xbe, 0x41, 0x99, 0x98, 0xea, 0x2e, 0xdb,
	0xa0, 0xbf, 0x4c, 0x97, 0xb3, 0xc6, 0x7f, 0x06, 0x7b, 0x17, 0xe5, 0x22, 0x83, 0xbe, 0xf5, 0x90,
	0x5c, 0xb8, 0x7b, 0x6c, 0xd5, 0x72, 0x96, 0x4e, 0x08, 0xfb, 0x04, 0xab, 0x6b, 0x2d, 0x3a, 0x75,
	0xf9, 0xea, 0x5a, 0x57, 0x17, 0x65, 0x13, 0x6f, 0x69, 0xfe, 0x80, 0x66, 0xf5, 0xaf, 0x16, 0x89,
	0xd1, 0xa2, 0x5b, 0xdf, 0xc6, 0x8a, 0xab, 0xe6, 0xbf, 0x25, 0xa5, 0x12, 0x1f, 0x3e, 0xf9, 0xfe,
	0x78, 0x19, 0x1b, 0xd4, 0xba, 0x1f, 0xab, 0x41, 0xf1, 0xd7, 0x60, 0xaa, 0x06, 0x4b, 0x33, 0xc8,
	0xdf, 0xd0, 0x81, 0xfd, 0xde, 0x8e, 0x77, 0x73, 0xec, 0xf9, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8a, 0x10, 0xcf, 0xaa, 0x9a, 0x07, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.transaction_id is set).
	Execute(ctx context.Context, in *query.ExecuteRequest, opts ...grpc.CallOption) (*query.ExecuteResponse, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(ctx context.Context, in *query.ExecuteBatchRequest, opts ...grpc.CallOption) (*query.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(ctx context.Context, in *query.StreamExecuteRequest, opts ...grpc.CallOption) (Query_StreamExecuteClient, error)
	// Begin a transaction.
	Begin(ctx context.Context, in *query.BeginRequest, opts ...grpc.CallOption) (*query.BeginResponse, error)
	// Commit a transaction.
	Commit(ctx context.Context, in *query.CommitRequest, opts ...grpc.CallOption) (*query.CommitResponse, error)
	// Rollback a transaction.
	Rollback(ctx context.Context, in *query.RollbackRequest, opts ...grpc.CallOption) (*query.RollbackResponse, error)
	// Prepare preares a transaction.
	Prepare(ctx context.Context, in *query.PrepareRequest, opts ...grpc.CallOption) (*query.PrepareResponse, error)
	// CommitPrepared commits a prepared transaction.
	CommitPrepared(ctx context.Context, in *query.CommitPreparedRequest, opts ...grpc.CallOption) (*query.CommitPreparedResponse, error)
	// RollbackPrepared rolls back a prepared transaction.
	RollbackPrepared(ctx context.Context, in *query.RollbackPreparedRequest, opts ...grpc.CallOption) (*query.RollbackPreparedResponse, error)
	// CreateTransaction creates the metadata for a 2pc transaction.
	CreateTransaction(ctx context.Context, in *query.CreateTransactionRequest, opts ...grpc.CallOption) (*query.CreateTransactionResponse, error)
	// StartCommit initiates a commit for a 2pc transaction.
	StartCommit(ctx context.Context, in *query.StartCommitRequest, opts ...grpc.CallOption) (*query.StartCommitResponse, error)
	// SetRollback marks the 2pc transaction for rollback.
	SetRollback(ctx context.Context, in *query.SetRollbackRequest, opts ...grpc.CallOption) (*query.SetRollbackResponse, error)
	// ConcludeTransaction marks the 2pc transaction as resolved.
	ConcludeTransaction(ctx context.Context, in *query.ConcludeTransactionRequest, opts ...grpc.CallOption) (*query.ConcludeTransactionResponse, error)
	// ReadTransaction returns the 2pc transaction info.
	ReadTransaction(ctx context.Context, in *query.ReadTransactionRequest, opts ...grpc.CallOption) (*query.ReadTransactionResponse, error)
	// BeginExecute executes a begin and the specified SQL query.
	BeginExecute(ctx context.Context, in *query.BeginExecuteRequest, opts ...grpc.CallOption) (*query.BeginExecuteResponse, error)
	// MessageStream streams messages from a message table.
	MessageStream(ctx context.Context, in *query.MessageStreamRequest, opts ...grpc.CallOption) (Query_MessageStreamClient, error)
	// MessageAck acks messages for a table.
	MessageAck(ctx context.Context, in *query.MessageAckRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error)
	ReserveExecute(ctx context.Context, in *query.ReserveExecuteRequest, opts ...grpc.CallOption) (*query.ReserveExecuteResponse, error)
	ReserveBeginExecute(ctx context.Context, in *query.ReserveBeginExecuteRequest, opts ...grpc.CallOption) (*query.ReserveBeginExecuteResponse, error)
	Release(ctx context.Context, in *query.ReleaseRequest, opts ...grpc.CallOption) (*query.ReleaseResponse, error)
	// StreamHealth runs a streaming RPC to the tablet, that returns the
	// current health of the tablet on a regular basis.
	StreamHealth(ctx context.Context, in *query.StreamHealthRequest, opts ...grpc.CallOption) (Query_StreamHealthClient, error)
	// VStream streams vreplication events.
	VStream(ctx context.Context, in *binlogdata.VStreamRequest, opts ...grpc.CallOption) (Query_VStreamClient, error)
	// VStreamRows streams rows from the specified starting point.
	VStreamRows(ctx context.Context, in *binlogdata.VStreamRowsRequest, opts ...grpc.CallOption) (Query_VStreamRowsClient, error)
	// VStreamResults streams results along with the gtid of the snapshot.
	VStreamResults(ctx context.Context, in *binlogdata.VStreamResultsRequest, opts ...grpc.CallOption) (Query_VStreamResultsClient, error)
}

type queryClient struct {
	cc *grpc.ClientConn
}

func NewQueryClient(cc *grpc.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Execute(ctx context.Context, in *query.ExecuteRequest, opts ...grpc.CallOption) (*query.ExecuteResponse, error) {
	out := new(query.ExecuteResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ExecuteBatch(ctx context.Context, in *query.ExecuteBatchRequest, opts ...grpc.CallOption) (*query.ExecuteBatchResponse, error) {
	out := new(query.ExecuteBatchResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/ExecuteBatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StreamExecute(ctx context.Context, in *query.StreamExecuteRequest, opts ...grpc.CallOption) (Query_StreamExecuteClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[0], "/queryservice.Query/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_StreamExecuteClient interface {
	Recv() (*query.StreamExecuteResponse, error)
	grpc.ClientStream
}

type queryStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *queryStreamExecuteClient) Recv() (*query.StreamExecuteResponse, error) {
	m := new(query.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) Begin(ctx context.Context, in *query.BeginRequest, opts ...grpc.CallOption) (*query.BeginResponse, error) {
	out := new(query.BeginResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Begin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Commit(ctx context.Context, in *query.CommitRequest, opts ...grpc.CallOption) (*query.CommitResponse, error) {
	out := new(query.CommitResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Commit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Rollback(ctx context.Context, in *query.RollbackRequest, opts ...grpc.CallOption) (*query.RollbackResponse, error) {
	out := new(query.RollbackResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Rollback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Prepare(ctx context.Context, in *query.PrepareRequest, opts ...grpc.CallOption) (*query.PrepareResponse, error) {
	out := new(query.PrepareResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Prepare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CommitPrepared(ctx context.Context, in *query.CommitPreparedRequest, opts ...grpc.CallOption) (*query.CommitPreparedResponse, error) {
	out := new(query.CommitPreparedResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/CommitPrepared", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RollbackPrepared(ctx context.Context, in *query.RollbackPreparedRequest, opts ...grpc.CallOption) (*query.RollbackPreparedResponse, error) {
	out := new(query.RollbackPreparedResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/RollbackPrepared", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) CreateTransaction(ctx context.Context, in *query.CreateTransactionRequest, opts ...grpc.CallOption) (*query.CreateTransactionResponse, error) {
	out := new(query.CreateTransactionResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/CreateTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StartCommit(ctx context.Context, in *query.StartCommitRequest, opts ...grpc.CallOption) (*query.StartCommitResponse, error) {
	out := new(query.StartCommitResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/StartCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SetRollback(ctx context.Context, in *query.SetRollbackRequest, opts ...grpc.CallOption) (*query.SetRollbackResponse, error) {
	out := new(query.SetRollbackResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/SetRollback", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConcludeTransaction(ctx context.Context, in *query.ConcludeTransactionRequest, opts ...grpc.CallOption) (*query.ConcludeTransactionResponse, error) {
	out := new(query.ConcludeTransactionResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/ConcludeTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ReadTransaction(ctx context.Context, in *query.ReadTransactionRequest, opts ...grpc.CallOption) (*query.ReadTransactionResponse, error) {
	out := new(query.ReadTransactionResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/ReadTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BeginExecute(ctx context.Context, in *query.BeginExecuteRequest, opts ...grpc.CallOption) (*query.BeginExecuteResponse, error) {
	out := new(query.BeginExecuteResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/BeginExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) MessageStream(ctx context.Context, in *query.MessageStreamRequest, opts ...grpc.CallOption) (Query_MessageStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[1], "/queryservice.Query/MessageStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryMessageStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_MessageStreamClient interface {
	Recv() (*query.MessageStreamResponse, error)
	grpc.ClientStream
}

type queryMessageStreamClient struct {
	grpc.ClientStream
}

func (x *queryMessageStreamClient) Recv() (*query.MessageStreamResponse, error) {
	m := new(query.MessageStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) MessageAck(ctx context.Context, in *query.MessageAckRequest, opts ...grpc.CallOption) (*query.MessageAckResponse, error) {
	out := new(query.MessageAckResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/MessageAck", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ReserveExecute(ctx context.Context, in *query.ReserveExecuteRequest, opts ...grpc.CallOption) (*query.ReserveExecuteResponse, error) {
	out := new(query.ReserveExecuteResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/ReserveExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ReserveBeginExecute(ctx context.Context, in *query.ReserveBeginExecuteRequest, opts ...grpc.CallOption) (*query.ReserveBeginExecuteResponse, error) {
	out := new(query.ReserveBeginExecuteResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/ReserveBeginExecute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Release(ctx context.Context, in *query.ReleaseRequest, opts ...grpc.CallOption) (*query.ReleaseResponse, error) {
	out := new(query.ReleaseResponse)
	err := c.cc.Invoke(ctx, "/queryservice.Query/Release", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) StreamHealth(ctx context.Context, in *query.StreamHealthRequest, opts ...grpc.CallOption) (Query_StreamHealthClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[2], "/queryservice.Query/StreamHealth", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryStreamHealthClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_StreamHealthClient interface {
	Recv() (*query.StreamHealthResponse, error)
	grpc.ClientStream
}

type queryStreamHealthClient struct {
	grpc.ClientStream
}

func (x *queryStreamHealthClient) Recv() (*query.StreamHealthResponse, error) {
	m := new(query.StreamHealthResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) VStream(ctx context.Context, in *binlogdata.VStreamRequest, opts ...grpc.CallOption) (Query_VStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[3], "/queryservice.Query/VStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryVStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_VStreamClient interface {
	Recv() (*binlogdata.VStreamResponse, error)
	grpc.ClientStream
}

type queryVStreamClient struct {
	grpc.ClientStream
}

func (x *queryVStreamClient) Recv() (*binlogdata.VStreamResponse, error) {
	m := new(binlogdata.VStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) VStreamRows(ctx context.Context, in *binlogdata.VStreamRowsRequest, opts ...grpc.CallOption) (Query_VStreamRowsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[4], "/queryservice.Query/VStreamRows", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryVStreamRowsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_VStreamRowsClient interface {
	Recv() (*binlogdata.VStreamRowsResponse, error)
	grpc.ClientStream
}

type queryVStreamRowsClient struct {
	grpc.ClientStream
}

func (x *queryVStreamRowsClient) Recv() (*binlogdata.VStreamRowsResponse, error) {
	m := new(binlogdata.VStreamRowsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *queryClient) VStreamResults(ctx context.Context, in *binlogdata.VStreamResultsRequest, opts ...grpc.CallOption) (Query_VStreamResultsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Query_serviceDesc.Streams[5], "/queryservice.Query/VStreamResults", opts...)
	if err != nil {
		return nil, err
	}
	x := &queryVStreamResultsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Query_VStreamResultsClient interface {
	Recv() (*binlogdata.VStreamResultsResponse, error)
	grpc.ClientStream
}

type queryVStreamResultsClient struct {
	grpc.ClientStream
}

func (x *queryVStreamResultsClient) Recv() (*binlogdata.VStreamResultsResponse, error) {
	m := new(binlogdata.VStreamResultsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// Execute executes the specified SQL query (might be in a
	// transaction context, if Query.transaction_id is set).
	Execute(context.Context, *query.ExecuteRequest) (*query.ExecuteResponse, error)
	// ExecuteBatch executes a list of queries, and returns the result
	// for each query.
	ExecuteBatch(context.Context, *query.ExecuteBatchRequest) (*query.ExecuteBatchResponse, error)
	// StreamExecute executes a streaming query. Use this method if the
	// query returns a large number of rows. The first QueryResult will
	// contain the Fields, subsequent QueryResult messages will contain
	// the rows.
	StreamExecute(*query.StreamExecuteRequest, Query_StreamExecuteServer) error
	// Begin a transaction.
	Begin(context.Context, *query.BeginRequest) (*query.BeginResponse, error)
	// Commit a transaction.
	Commit(context.Context, *query.CommitRequest) (*query.CommitResponse, error)
	// Rollback a transaction.
	Rollback(context.Context, *query.RollbackRequest) (*query.RollbackResponse, error)
	// Prepare preares a transaction.
	Prepare(context.Context, *query.PrepareRequest) (*query.PrepareResponse, error)
	// CommitPrepared commits a prepared transaction.
	CommitPrepared(context.Context, *query.CommitPreparedRequest) (*query.CommitPreparedResponse, error)
	// RollbackPrepared rolls back a prepared transaction.
	RollbackPrepared(context.Context, *query.RollbackPreparedRequest) (*query.RollbackPreparedResponse, error)
	// CreateTransaction creates the metadata for a 2pc transaction.
	CreateTransaction(context.Context, *query.CreateTransactionRequest) (*query.CreateTransactionResponse, error)
	// StartCommit initiates a commit for a 2pc transaction.
	StartCommit(context.Context, *query.StartCommitRequest) (*query.StartCommitResponse, error)
	// SetRollback marks the 2pc transaction for rollback.
	SetRollback(context.Context, *query.SetRollbackRequest) (*query.SetRollbackResponse, error)
	// ConcludeTransaction marks the 2pc transaction as resolved.
	ConcludeTransaction(context.Context, *query.ConcludeTransactionRequest) (*query.ConcludeTransactionResponse, error)
	// ReadTransaction returns the 2pc transaction info.
	ReadTransaction(context.Context, *query.ReadTransactionRequest) (*query.ReadTransactionResponse, error)
	// BeginExecute executes a begin and the specified SQL query.
	BeginExecute(context.Context, *query.BeginExecuteRequest) (*query.BeginExecuteResponse, error)
	// MessageStream streams messages from a message table.
	MessageStream(*query.MessageStreamRequest, Query_MessageStreamServer) error
	// MessageAck acks messages for a table.
	MessageAck(context.Context, *query.MessageAckRequest) (*query.MessageAckResponse, error)
	ReserveExecute(context.Context, *query.ReserveExecuteRequest) (*query.ReserveExecuteResponse, error)
	ReserveBeginExecute(context.Context, *query.ReserveBeginExecuteRequest) (*query.ReserveBeginExecuteResponse, error)
	Release(context.Context, *query.ReleaseRequest) (*query.ReleaseResponse, error)
	// StreamHealth runs a streaming RPC to the tablet, that returns the
	// current health of the tablet on a regular basis.
	StreamHealth(*query.StreamHealthRequest, Query_StreamHealthServer) error
	// VStream streams vreplication events.
	VStream(*binlogdata.VStreamRequest, Query_VStreamServer) error
	// VStreamRows streams rows from the specified starting point.
	VStreamRows(*binlogdata.VStreamRowsRequest, Query_VStreamRowsServer) error
	// VStreamResults streams results along with the gtid of the snapshot.
	VStreamResults(*binlogdata.VStreamResultsRequest, Query_VStreamResultsServer) error
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Execute(ctx context.Context, req *query.ExecuteRequest) (*query.ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (*UnimplementedQueryServer) ExecuteBatch(ctx context.Context, req *query.ExecuteBatchRequest) (*query.ExecuteBatchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteBatch not implemented")
}
func (*UnimplementedQueryServer) StreamExecute(req *query.StreamExecuteRequest, srv Query_StreamExecuteServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamExecute not implemented")
}
func (*UnimplementedQueryServer) Begin(ctx context.Context, req *query.BeginRequest) (*query.BeginResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Begin not implemented")
}
func (*UnimplementedQueryServer) Commit(ctx context.Context, req *query.CommitRequest) (*query.CommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Commit not implemented")
}
func (*UnimplementedQueryServer) Rollback(ctx context.Context, req *query.RollbackRequest) (*query.RollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (*UnimplementedQueryServer) Prepare(ctx context.Context, req *query.PrepareRequest) (*query.PrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prepare not implemented")
}
func (*UnimplementedQueryServer) CommitPrepared(ctx context.Context, req *query.CommitPreparedRequest) (*query.CommitPreparedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitPrepared not implemented")
}
func (*UnimplementedQueryServer) RollbackPrepared(ctx context.Context, req *query.RollbackPreparedRequest) (*query.RollbackPreparedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackPrepared not implemented")
}
func (*UnimplementedQueryServer) CreateTransaction(ctx context.Context, req *query.CreateTransactionRequest) (*query.CreateTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTransaction not implemented")
}
func (*UnimplementedQueryServer) StartCommit(ctx context.Context, req *query.StartCommitRequest) (*query.StartCommitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCommit not implemented")
}
func (*UnimplementedQueryServer) SetRollback(ctx context.Context, req *query.SetRollbackRequest) (*query.SetRollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetRollback not implemented")
}
func (*UnimplementedQueryServer) ConcludeTransaction(ctx context.Context, req *query.ConcludeTransactionRequest) (*query.ConcludeTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConcludeTransaction not implemented")
}
func (*UnimplementedQueryServer) ReadTransaction(ctx context.Context, req *query.ReadTransactionRequest) (*query.ReadTransactionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadTransaction not implemented")
}
func (*UnimplementedQueryServer) BeginExecute(ctx context.Context, req *query.BeginExecuteRequest) (*query.BeginExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginExecute not implemented")
}
func (*UnimplementedQueryServer) MessageStream(req *query.MessageStreamRequest, srv Query_MessageStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method MessageStream not implemented")
}
func (*UnimplementedQueryServer) MessageAck(ctx context.Context, req *query.MessageAckRequest) (*query.MessageAckResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MessageAck not implemented")
}
func (*UnimplementedQueryServer) ReserveExecute(ctx context.Context, req *query.ReserveExecuteRequest) (*query.ReserveExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveExecute not implemented")
}
func (*UnimplementedQueryServer) ReserveBeginExecute(ctx context.Context, req *query.ReserveBeginExecuteRequest) (*query.ReserveBeginExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReserveBeginExecute not implemented")
}
func (*UnimplementedQueryServer) Release(ctx context.Context, req *query.ReleaseRequest) (*query.ReleaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Release not implemented")
}
func (*UnimplementedQueryServer) StreamHealth(req *query.StreamHealthRequest, srv Query_StreamHealthServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamHealth not implemented")
}
func (*UnimplementedQueryServer) VStream(req *binlogdata.VStreamRequest, srv Query_VStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method VStream not implemented")
}
func (*UnimplementedQueryServer) VStreamRows(req *binlogdata.VStreamRowsRequest, srv Query_VStreamRowsServer) error {
	return status.Errorf(codes.Unimplemented, "method VStreamRows not implemented")
}
func (*UnimplementedQueryServer) VStreamResults(req *binlogdata.VStreamResultsRequest, srv Query_VStreamResultsServer) error {
	return status.Errorf(codes.Unimplemented, "method VStreamResults not implemented")
}

func RegisterQueryServer(s *grpc.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Execute(ctx, req.(*query.ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ExecuteBatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ExecuteBatchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ExecuteBatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/ExecuteBatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ExecuteBatch(ctx, req.(*query.ExecuteBatchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(query.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).StreamExecute(m, &queryStreamExecuteServer{stream})
}

type Query_StreamExecuteServer interface {
	Send(*query.StreamExecuteResponse) error
	grpc.ServerStream
}

type queryStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *queryStreamExecuteServer) Send(m *query.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_Begin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.BeginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Begin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Begin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Begin(ctx, req.(*query.BeginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Commit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.CommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Commit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Commit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Commit(ctx, req.(*query.CommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Rollback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Rollback(ctx, req.(*query.RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.PrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Prepare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Prepare(ctx, req.(*query.PrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CommitPrepared_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.CommitPreparedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CommitPrepared(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/CommitPrepared",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CommitPrepared(ctx, req.(*query.CommitPreparedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RollbackPrepared_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.RollbackPreparedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RollbackPrepared(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/RollbackPrepared",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RollbackPrepared(ctx, req.(*query.RollbackPreparedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_CreateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.CreateTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).CreateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/CreateTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).CreateTransaction(ctx, req.(*query.CreateTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_StartCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.StartCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).StartCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/StartCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).StartCommit(ctx, req.(*query.StartCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SetRollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.SetRollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SetRollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/SetRollback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SetRollback(ctx, req.(*query.SetRollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConcludeTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ConcludeTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConcludeTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/ConcludeTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConcludeTransaction(ctx, req.(*query.ConcludeTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ReadTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ReadTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ReadTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/ReadTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ReadTransaction(ctx, req.(*query.ReadTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BeginExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.BeginExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BeginExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/BeginExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BeginExecute(ctx, req.(*query.BeginExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_MessageStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(query.MessageStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).MessageStream(m, &queryMessageStreamServer{stream})
}

type Query_MessageStreamServer interface {
	Send(*query.MessageStreamResponse) error
	grpc.ServerStream
}

type queryMessageStreamServer struct {
	grpc.ServerStream
}

func (x *queryMessageStreamServer) Send(m *query.MessageStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_MessageAck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.MessageAckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).MessageAck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/MessageAck",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).MessageAck(ctx, req.(*query.MessageAckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ReserveExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ReserveExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ReserveExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/ReserveExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ReserveExecute(ctx, req.(*query.ReserveExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ReserveBeginExecute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ReserveBeginExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ReserveBeginExecute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/ReserveBeginExecute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ReserveBeginExecute(ctx, req.(*query.ReserveBeginExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Release_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(query.ReleaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Release(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/queryservice.Query/Release",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Release(ctx, req.(*query.ReleaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_StreamHealth_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(query.StreamHealthRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).StreamHealth(m, &queryStreamHealthServer{stream})
}

type Query_StreamHealthServer interface {
	Send(*query.StreamHealthResponse) error
	grpc.ServerStream
}

type queryStreamHealthServer struct {
	grpc.ServerStream
}

func (x *queryStreamHealthServer) Send(m *query.StreamHealthResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_VStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(binlogdata.VStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).VStream(m, &queryVStreamServer{stream})
}

type Query_VStreamServer interface {
	Send(*binlogdata.VStreamResponse) error
	grpc.ServerStream
}

type queryVStreamServer struct {
	grpc.ServerStream
}

func (x *queryVStreamServer) Send(m *binlogdata.VStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_VStreamRows_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(binlogdata.VStreamRowsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).VStreamRows(m, &queryVStreamRowsServer{stream})
}

type Query_VStreamRowsServer interface {
	Send(*binlogdata.VStreamRowsResponse) error
	grpc.ServerStream
}

type queryVStreamRowsServer struct {
	grpc.ServerStream
}

func (x *queryVStreamRowsServer) Send(m *binlogdata.VStreamRowsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Query_VStreamResults_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(binlogdata.VStreamResultsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(QueryServer).VStreamResults(m, &queryVStreamResultsServer{stream})
}

type Query_VStreamResultsServer interface {
	Send(*binlogdata.VStreamResultsResponse) error
	grpc.ServerStream
}

type queryVStreamResultsServer struct {
	grpc.ServerStream
}

func (x *queryVStreamResultsServer) Send(m *binlogdata.VStreamResultsResponse) error {
	return x.ServerStream.SendMsg(m)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "queryservice.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _Query_Execute_Handler,
		},
		{
			MethodName: "ExecuteBatch",
			Handler:    _Query_ExecuteBatch_Handler,
		},
		{
			MethodName: "Begin",
			Handler:    _Query_Begin_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _Query_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _Query_Rollback_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _Query_Prepare_Handler,
		},
		{
			MethodName: "CommitPrepared",
			Handler:    _Query_CommitPrepared_Handler,
		},
		{
			MethodName: "RollbackPrepared",
			Handler:    _Query_RollbackPrepared_Handler,
		},
		{
			MethodName: "CreateTransaction",
			Handler:    _Query_CreateTransaction_Handler,
		},
		{
			MethodName: "StartCommit",
			Handler:    _Query_StartCommit_Handler,
		},
		{
			MethodName: "SetRollback",
			Handler:    _Query_SetRollback_Handler,
		},
		{
			MethodName: "ConcludeTransaction",
			Handler:    _Query_ConcludeTransaction_Handler,
		},
		{
			MethodName: "ReadTransaction",
			Handler:    _Query_ReadTransaction_Handler,
		},
		{
			MethodName: "BeginExecute",
			Handler:    _Query_BeginExecute_Handler,
		},
		{
			MethodName: "MessageAck",
			Handler:    _Query_MessageAck_Handler,
		},
		{
			MethodName: "ReserveExecute",
			Handler:    _Query_ReserveExecute_Handler,
		},
		{
			MethodName: "ReserveBeginExecute",
			Handler:    _Query_ReserveBeginExecute_Handler,
		},
		{
			MethodName: "Release",
			Handler:    _Query_Release_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _Query_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MessageStream",
			Handler:       _Query_MessageStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamHealth",
			Handler:       _Query_StreamHealth_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VStream",
			Handler:       _Query_VStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VStreamRows",
			Handler:       _Query_VStreamRows_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "VStreamResults",
			Handler:       _Query_VStreamResults_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "queryservice.proto",
}
