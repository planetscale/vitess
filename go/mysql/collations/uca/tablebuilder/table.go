package tablebuilder

import (
	"fmt"
	"io"
	"reflect"

	"vitess.io/vitess/go/mysql/collations/uca"
)

const MaxColumns = 16

type entry struct {
	weights []uint16
}

func (e *entry) adjustHangulWeights(tb *TableBuilder, jamos []rune) {
	for _, jamo := range jamos {
		_, entry := tb.entryForCodepoint(jamo)
		e.weights = append(e.weights, entry.weights[0], entry.weights[1], entry.weights[2]+1)
	}
}

type page struct {
	n          int
	entryCount int
	entries    [uca.CodepointsPerPage]entry
}

func (p *page) equals(other *page) bool {
	return reflect.DeepEqual(p, other)
}

func (p *page) name(uca, prefix string) string {
	if p.entryCount == 0 {
		return "nil"
	}
	return fmt.Sprintf("%sweightTable_%s_page%03X", prefix, uca, p.n)
}

func (p *page) findMaxCollationElements() int {
	var weightn int
	for _, entry := range p.entries {
		if len(entry.weights) > weightn {
			weightn = len(entry.weights)
		}
	}
	return weightn
}

func (p *page) adjustImplicitWeights(tb *TableBuilder) {
	if p.entryCount == uca.CodepointsPerPage {
		return
	}

	baseCodepoint := p.n * uca.CodepointsPerPage
	for n := range p.entries {
		codepoint := rune(baseCodepoint + n)
		entry := &p.entries[n]
		if len(entry.weights) > 0 {
			continue
		}

		if jamos := uca.UnicodeDecomposeHangulSyllable(codepoint); jamos != nil {
			entry.adjustHangulWeights(tb, jamos)
			continue
		}

		entry.weights = make([]uint16, 6)
		uca.UnicodeImplicitWeights900(entry.weights, codepoint)
	}
}

var WeightTypeNames = []string{"primary", "secondary", "tertiary"}

func (p *page) dump900(ucav string, w io.Writer) {
	if p.entryCount == 0 {
		return
	}

	maxCollations := p.findMaxCollationElements()

	fmt.Fprintf(w, "var %s = []uint16{", p.name(ucav, ""))
	for col, entry := range p.entries {
		if col%MaxColumns == 0 {
			fmt.Fprintf(w, "\n\t")
		} else {
			fmt.Fprintf(w, " ")
		}
		fmt.Fprintf(w, "%d,", len(entry.weights)/3)
	}
	fmt.Fprintf(w, "\n")
	for level := 0; level < maxCollations; level++ {
		for col, entry := range p.entries {
			if col%MaxColumns == 0 {
				fmt.Fprintf(w, "\n\t")
			} else {
				fmt.Fprintf(w, " ")
			}
			var weight uint16
			if level < len(entry.weights) {
				weight = entry.weights[level]
			}
			fmt.Fprintf(w, "0x%X,", weight)
		}
	}
	fmt.Fprintf(w, "\n}\n\n")
}

func (p *page) dumpLegacy(ucav string, w io.Writer) {
	if p.entryCount == 0 {
		return
	}

	stride := p.findMaxCollationElements()

	fmt.Fprintf(w, "var %s = []uint16{", p.name(ucav, ""))
	fmt.Fprintf(w, "\n\t%d,\n", stride)
	for col, entry := range p.entries {
		if col%MaxColumns == 0 {
			fmt.Fprintf(w, "\n\t")
		} else {
			fmt.Fprintf(w, " ")
		}
		var i int
		for i < len(entry.weights) {
			fmt.Fprintf(w, "0x%04X,", entry.weights[i])
			i++
		}
		for i < stride {
			fmt.Fprintf(w, "0x0000,")
			i++
		}
	}
	fmt.Fprintf(w, "\n}\n\n")
}

type TableBuilder struct {
	pages   []page
	maxChar rune
	ucav    string
	base    *TableBuilder
}

func (tb *TableBuilder) entryForCodepoint(codepoint rune) (*page, *entry) {
	page := &tb.pages[int(codepoint)/uca.CodepointsPerPage]
	entry := &page.entries[int(codepoint)%uca.CodepointsPerPage]
	return page, entry
}

func (tb *TableBuilder) Add900(codepoint rune, rhs [][3]uint16) {
	page, entry := tb.entryForCodepoint(codepoint)
	page.entryCount++

	for i, weights := range rhs {
		if i >= uca.MaxCollationElementsPerCodepoint {
			break
		}
		for _, we := range weights {
			entry.weights = append(entry.weights, we)
		}
	}
}

func (tb *TableBuilder) Add(codepoint rune, weights []uint16) {
	page, entry := tb.entryForCodepoint(codepoint)
	page.entryCount++

	if entry.weights != nil {
		panic("duplicate codepoint inserted")
	}
	entry.weights = append(entry.weights, weights...)
}

func (tb *TableBuilder) AddFromAllkeys(lhs []rune, rhs [][]int, vars []int) {
	if len(lhs) > 1 || lhs[0] > tb.maxChar {
		// TODO: support contractions
		return
	}

	var weights [][3]uint16
	for _, we := range rhs {
		if len(we) != 3 {
			panic("non-triplet weight in allkeys.txt")
		}
		weights = append(weights, [3]uint16{uint16(we[0]), uint16(we[1]), uint16(we[2])})
	}
	tb.Add900(lhs[0], weights)
}

func (tb *TableBuilder) finalize900() {
	for n := range tb.pages {
		tb.pages[n].adjustImplicitWeights(tb)
	}
}

func (tb *TableBuilder) DumpTables900(w io.Writer) {
	tb.finalize900()

	fmt.Fprintf(w, "// DO NOT MODIFY: this file is autogenerated by maketables.go\n\n")
	fmt.Fprintf(w, "package uca\n\n")

	for n, page := range tb.pages {
		if tb.base != nil && page.equals(&tb.base.pages[n]) {
			continue
		}
		page.dump900(tb.ucav, w)
	}
	fmt.Fprintf(w, "var WeightTable_%s = []*[]uint16{", tb.ucav)
	for n, page := range tb.pages {
		if n%MaxColumns == 0 {
			fmt.Fprintf(w, "\n\t")
		} else {
			fmt.Fprintf(w, " ")
		}

		if tb.base != nil && page.equals(&tb.base.pages[n]) {
			fmt.Fprintf(w, "%s,", page.name(tb.base.ucav, "&"))
		} else {
			fmt.Fprintf(w, "%s,", page.name(tb.ucav, "&"))
		}
	}
	fmt.Fprintf(w, "\n}\n")
}

func (tb *TableBuilder) DumpTablesLegacy(w io.Writer) {
	fmt.Fprintf(w, "// DO NOT MODIFY: this file is autogenerated by maketables.go\n\n")
	fmt.Fprintf(w, "package uca\n\n")

	for _, page := range tb.pages {
		page.dumpLegacy(tb.ucav, w)
	}
	fmt.Fprintf(w, "var WeightTable_%s = []*[]uint16{", tb.ucav)
	for n, page := range tb.pages {
		if n%MaxColumns == 0 {
			fmt.Fprintf(w, "\n\t")
		} else {
			fmt.Fprintf(w, " ")
		}
		fmt.Fprintf(w, "%s,", page.name(tb.ucav, "&"))
	}
	fmt.Fprintf(w, "\n}\n")
}

func NewTableBuilder(ucav string, base *TableBuilder) *TableBuilder {
	var maxChar rune
	switch ucav {
	case "uca520", "uca900", "uca900_zh", "uca900_ja":
		maxChar = uca.MaxCodepoint
	case "uca400":
		maxChar = 0xFFFF + 1
	default:
		panic("unknown UCA version")
	}

	tb := &TableBuilder{
		pages:   make([]page, maxChar/uca.CodepointsPerPage),
		maxChar: maxChar,
		ucav:    ucav,
		base:    base,
	}

	for n := range tb.pages {
		tb.pages[n].n = n
	}

	return tb
}
